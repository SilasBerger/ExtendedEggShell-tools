<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.002011">
<title confidence="0.760944">
The Death of Object-Oriented Programming?
</title>
<author confidence="0.766342">
Oscar Nierstrasz1
</author>
<affiliation confidence="0.803271">
Software Composition Group, University of Bern, Switzerland
</affiliation>
<email confidence="0.624622">
http://scg.unibe.ch/
</email>
<bodyText confidence="0.993328434782608">
Abstract. Modern software systems are increasingly long-lived. In or-
der to gracefully evolve these systems as they address new requirements,
developers need to navigate effectively between domain concepts and
the code that addresses those domains. One of the original promises
of object-orientation was that the same object-oriented models would
be used throughout requirements analysis, design and implementation.
Software systems today however are commonly constructed from a het-
erogeneous Ã¢ÂÂlanguage soupÃ¢ÂÂ of mainstream code and dedicated DSLs
addressing a variety of application and technical domains. Has object-
oriented programming outlived its purpose?
In this essay we argue that we need to rethink the original goals of
object-orientation and their relevance for modern software development.
We propose as a driving maxim, Ã¢ÂÂProgramming is Modeling,Ã¢ÂÂ and ex-
plore what this implies for programming languages, tools and environ-
ments. In particular, we argue that: (1) source code should serve not
only to specify an implementation of a software system, but should en-
code a queryable and manipulable model of the application and technical
domains concerned; (2) IDEs should exploit these domain models to en-
able inexpensive browsing, querying and analysis by developers; and (3)
barriers between the code base, the running application, and the soft-
ware ecosystem at large need to be broken down, and their connections
exploited and monitored to support developers in comprehension and
evolution tasks.
</bodyText>
<sectionHeader confidence="0.997755" genericHeader="abstract">
1 Introduction
</sectionHeader>
<bodyText confidence="0.973990375">
Is object-oriented programming dying?
The code of real software systems is structured around a number of inter-
acting and overlapping technical and application domains. As we shall see, this
fact is not well supported by mainstream languages and development environ-
ments. Although object-oriented software development made early promises to
close the gaps between analysis, design and implementation by offering a uni-
fying object-oriented modeling paradigm for these activities, we still struggle to
navigate between these worlds. Do the emergence of domain-specific languages
</bodyText>
<listItem confidence="0.824052666666667">
(DSLs) and model-driven development (MDD) prove that object-orientation has
failed?
? Preprint of an invited paper. To appear in Proceedings of FASE 2016, Springer
</listItem>
<sectionHeader confidence="0.7812925" genericHeader="method">
LNCS 9633.
2 Oscar Nierstrasz
</sectionHeader>
<bodyText confidence="0.997700326086957">
In this essay we explore some of the symptoms of this apparent failure, and
argue that we need to be bolder in interpreting the vision of object-orientation.
We propose the slogan Ã¢ÂÂProgramming is ModelingÃ¢ÂÂ and identify a number of
challenges this leads us to.
Let us briefly summarize the key symptoms:
There exists a large gap between models and code. In an ideal world, requirements
and domain models are clearly visible in the implementation of a software system.
In reality, most mainstream programming languages seem to be ill-equipped to
represent domain concepts in a concise way, leading to a proliferation of DSLs.
Internal DSLs, for example, Ã¢ÂÂfluent interfacesÃ¢ÂÂ that exploit the syntax of a host
language, are often less fluent and readable than they should be. External DSLs
(i.e. with their own dedicated syntax) can lead to a Ã¢ÂÂsoupÃ¢ÂÂ of heterogeneous
code that is hard to navigate, understand, and analyse.
MDD represents another important trend, in which high-level models are
typically transformed to implementations, but such Ã¢ÂÂmodel compilersÃ¢ÂÂ tend to
pay off only in well-understood domains where changes in requirements can be
well-expressed by corresponding changes to models.
Mainstream IDEs are glorified text editors. Although software developers spend
much of their time reading and analyzing code, mainstream IDEs mostly treat
source code as text. In general, the IDE is not aware of application or technical
domain concepts, and does not help the developer to formulate domain-specific
queries or custom analyses, such as: Where is this feature implemented? Will
this change impact the system architecture? Who is an expert on this part of the
code? Similarly classical development tools belonging to the IDE are unaware of
the application domain. A classical example is the interactive debugger, which
offers a uniform interface to debugging based on the run-time stack, without any
knowledge of the underlying application domain. Although popular IDEs offer
plugin architectures that allow third-party developers to integrate new tools
into the IDE, the barrier to building such tools remains relatively high, and
the application domain models of the underlying code base remain relatively
inaccessible.
Programming languages and tools live in a closed world. Mainstream program-
ming languages assume the world is closed and frozen. Static type systems, for
example, assume that the type of an entity is fixed and will never change or
evolve. When a type changes, the entire world must change with it. In reality,
complex software systems have to cope with evolving and possibly inconsistent
entities. Another symptom is the strict divide between Ã¢ÂÂcompile timeÃ¢ÂÂ and Ã¢ÂÂrun
timeÃ¢ÂÂ in mainstream programming. For example, it is not possible to navigate
seamlessly from a feature of a running system to the code that implements it.
Finally, we see that developers often resort to web search engines and dedicated
Q&amp;A fora to answer questions that the IDE cannot. We need to acknowledge
that code lives within a much larger ecosystem than the current code base.
The Death of Object-Oriented Programming 3
In this essay we argue that we should revisit the object-oriented paradigm to
address these issues by adopting the maxim that Ã¢ÂÂProgramming is Modeling.Ã¢ÂÂ
We further propose a number of research challenges along the following lines:
</bodyText>
<listItem confidence="0.9960345">
1. Bring models closer to code by expressing queryable and manipulable domain
models directly in source code;
2. Exploit domain models in the IDE to enable custom analyses by developers;
3. Link the code to its ecosystem and monitor them both to steer their evolution.
</listItem>
<bodyText confidence="0.976190766666666">
Caveat: we apologize in advance for referencing only little of the vast amount
of relevant related work.1
2 Bring models closer to code
When we develop and evolve code, we need to comprehend the relationships
between requirements that refer to domain models, and the underlying code that
realizes those requirements. Ideally we want to see domain concepts directly in
the code. We therefore argue that a program should not just serve to specify an
implementation of a set of requirements, but it should encode domain models
suitable for querying and analysis.
This, we believe, was one of the early promises of object-oriented program-
ming as expressed in the 1980s. Nowadays, however, complex software systems
are implemented as a soup of mainstream and domain-specific languages. DSLs
can be used to address either technical or application domains. Typically several
DSLs are needed to address a complex application. Despite the availability of
many dedicated DSLs, important aspects of a software system may not be explic-
itly modeled at all. Notoriously, architectural constraints are implemented with
the help of frameworks and architectural styles, but rarely represented explicitly
or checked as the system evolves.
Introducing ever more DSLs is not a solution. Having many external DSLs
complicates program comprehension and makes it difficult for tools to reason
about the relationships between them.2
Internal (or embedded) DSLs are hard to achieve because (1) the syntax
of many mainstream object-oriented languages does not support well the de-
sign of truly fluent interfaces (with some notable exceptions, such as Smalltalk,
Ruby, Scala, ...), and (2) design methods emphasize the development of Ã¢ÂÂfluent
interfaces,Ã¢ÂÂ so they can be hard to achieve post hoc.
We think that many of these problems have their roots in a fundamental mis-
understanding of the object-oriented paradigm. While the imperative program-
ming paradigm can be summarized as programs = algorithms + data structures,
object-oriented programming is often explained (following Alan Kay [8][p 78]) as
</bodyText>
<footnote confidence="0.967489">
1 A representative selection of related work can be found in the research plan of our
SNSF project, Ã¢ÂÂAgile Software AnalysisÃ¢ÂÂ: http://scg.unibe.ch/research/snf16
2 Coping with this complexity is one of the goals of the GEMOC initiative [6]. See
http://gemoc.org.
</footnote>
<sectionHeader confidence="0.943676" genericHeader="method">
4 Oscar Nierstrasz
</sectionHeader>
<bodyText confidence="0.997503153846154">
programs = objects + messages. While this is not incorrect, it is a mechanistic
interpretation that misses the key point.
In our view, the object-oriented paradigm is better expressed as: Ã¢ÂÂdesign your
own paradigmÃ¢ÂÂ (i.e. programming is modeling). A well-designed object-oriented
system consists of objects representing exactly the domain abstractions that
are needed for your application and suitable operations over them (if you like, a
many-sorted algebra). Code can be separated into the objects (or Ã¢ÂÂcomponentsÃ¢ÂÂ)
representing domain concepts, and scripts that configure them [1].
We therefore posit as a challenge to revive object-oriented programming by
viewing OO languages as modeling languages, not just implementation languages.
Rather than viewing DSLs and MDD as the competition, we should encourage
the use of OO languages as modeling tools, and even as language workbenches
for developing embedded DSLs.3
</bodyText>
<sectionHeader confidence="0.552557" genericHeader="method">
3 Exploit domain models in the IDE
</sectionHeader>
<bodyText confidence="0.898752933333333">
Although developers are known to spend much of their development time read-
ing and analyzing code, mainstream IDEs do not do a good job of supporting
program comprehension. IDEs are basically glorified text editors.
Developers need custom analyses to answer the questions that arise during
typical development tasks [16,7]. Building a dedicated analysis tool is expensive,
even using a plugin architecture such as that of Eclipse. Dedicated analysis
platforms like Moose [12] and Rascal [9] reduce the cost of custom queries, but
they rely on the existence of a queryable model of the target software.
As we have seen in the previous section, even though we would like to see
programs as models, they are not in a form useful for querying and analysis, so
we need to do extra work to extract these models and work with them.
We see two important challenges. The first is Ã¢ÂÂAgile Model ExtractionÃ¢ÂÂ, i.e.
the ability to efficiently extract models from source code. This is not just a
problem of parsing heterogeneous code and linking concepts encoded in different
languages (e.g. Java, SQL, XML), but also of recognizing concepts coming from
numerous and intertwined domain models. We are experimenting with approxi-
mate parsing technology, inexpensive heuristics, and other techniques [10,13] to
quickly and cheaply extract models from heterogeneous source code.
The second challenge is Ã¢ÂÂContext-Aware ToolingÃ¢ÂÂ, i.e. the ability to cheaply
construct dedicated, custom analyses and tools that close the gap between IDEs
and application software. The key idea is, once we have access to the underlying
domain model of of code (whether it is offered by the underlying infrastructure
or obtained by Agile Model Extraction), to make it easy to exploit that model
in tools used by developers to produce code, browse and query it, analyze it and
debug it. On the one hand, generic core functionality is needed for querying and
navigating models. On the other hand, tools and environments need to be aware
3 See, for example, Helvetia, a workbench for integrating DSLs into the IDE and
toolchain of the host language [15].
The Death of Object-Oriented Programming 5
of the context of the domain model of the code under study so they can adapt
</bodyText>
<figureCaption confidence="0.9355765">
themselves accordingly.
Fig. 1. A domain-specific debugger for PetitParser. The debugging view displays rel-
</figureCaption>
<bodyText confidence="0.995439315789474">
evant information for debugging parsers ((4) Input, (5) Production structure). Each
widget loads relevant debugging operations (1, 2, 4).
An example is the Ã¢ÂÂmoldable debuggerÃ¢ÂÂ which, instead of presenting only a
generic stack-based interface to the run-time environment, is aware of relevant
domain concepts, such as notifications in an event-driven system, or grammar
rules in a parser [4]. In Figure 1 we see a screenshot of a domain-specific debugger
for PetitParser, a parser combinator framework for Pharo Smalltalk [14]. Each
widget of the debugger is context-sensitive and loads the appropriate debugging
operations for the current context. The debugger is aware of a grammarÃ¢ÂÂs pro-
duction rules and is capable, for example, of stepping to the next production or
the next parser failure, rather than simply to the next expression, statement or
method. Custom visualizations are also loaded to display the production struc-
ture in a suitable way. Custom debuggers can be defined in a straightforward way
by leveraging the explicit representation of the underlying application domain.
The same principles have been applied to the Ã¢ÂÂmoldable inspector,Ã¢ÂÂ a context-
aware tool for querying and exploring an object space [5]. Domain-specific views
are automatically loaded depending on the entities being inspected. As with the
moldable debugger, custom views are commonly expressed with just a few lines
of code.
</bodyText>
<sectionHeader confidence="0.983601" genericHeader="method">
6 Oscar Nierstrasz
</sectionHeader>
<bodyText confidence="0.991339897959184">
In the long run we envision a development environment in which we are not
forced to extract models from code, but in which the code is actually a model
that we can interact with, query and analyze.
The Death of Object-Oriented Programming 7
4 Link the code to its ecosystem
Conventional software systems are trapped behind a number of artificial barri-
ers. The most obvious is the barrier between the source code and the running
application. This is manifested in the usual program/compile/run cycle. This
makes it difficult to navigate between application features and source code. The
debugger is classically the only place where the developer can navigate between
the two worlds. It does not have to be that way, as seen in the Morphic frame-
work of Self, in which one may navigate freely between user interface widgets and
the source code related to them [11]. (This is just one dramatic manifestation of
Ã¢ÂÂlive programmingÃ¢ÂÂ, but perhaps one of the most important ones for program
comprehension.)
A second barrier is that between a current version of a system and other
related versions. In order to extract useful information about the evolution of
the system, one must resort to Ã¢ÂÂmining software repositoriesÃ¢ÂÂ, but this possibility
is not readily available to average developers who do not have spare capacity to
carry out such studies. Furthermore, different versions cannot normally co-exist
within a single running system, complicating integration and migration. (There
has been much interesting research but not much is available for mainstream
development.)
A third barrier exists between the system under development and the larger
ecosystem of related software. Countless research efforts in the past decade have
shown that, by mining the ecosystem, much useful knowledge can be gleaned
about common coding practices, bugs and bug fixes, and so on. Unfortunately
this information is not readily accessible to developers, so they often turn instead
to question and answer fora.
We see two main challenges, namely Ã¢ÂÂEcosystem MiningÃ¢ÂÂ and Ã¢ÂÂEvolution-
ary Monitoring.Ã¢ÂÂ By mining software ecosystems and offering platforms to ana-
lyze them [2], we hope to automatically discover intelligence relevant to a given
project. Examples are opportunities for code reuse, automatically-generated and
evolving documentation, and usage information than can influence maintainers
of libraries and frameworks.
Evolutionary Monitoring refers to steering the evolution of a software system
by monitoring stakeholder needs. An example of this is architectural monitor-
ing [3] which formalizes architectural constraints and monitors conformance as
the application evolves. Other examples include tracking the needs of stake-
holders (i.e. both developers and users) to determine chronic pain points and
opportunities for improvements; tracking technical debt to assess priorities for
reengineering and replacement; and monitoring technical trends, especially with
respect to relevent technical debt.
In the long run, we envision a development environment that integrates not
just the current code base and the running application, enabling easy naviga-
tion between them, but also knowledge mined from the evolution of the software
under development as well as from the software ecosystem at large. The develop-
ment environment should support active monitoring of the target system as well
as the ecosystem to identify and assess opportunities for code improvements.
</bodyText>
<sectionHeader confidence="0.9985565" genericHeader="method">
8 Oscar Nierstrasz
5 Conclusion
</sectionHeader>
<bodyText confidence="0.9998035">
Object-oriented programming has fulfilled many of its promises. Software sys-
tems today are longer-lived and more amenable to change and extension than
ever. Nevertheless we observe that object orientation is slowly dying, with the
introduction of ever more complex and heterogeneous systems.
We propose to rejuvenate object-oriented programming and let ourselves be
guided by the maxim that Ã¢ÂÂprogramming is modeling.Ã¢ÂÂ We need programming
languages, tools and environments that enable models to be directly expressed
in code in such a way that they can be queried, manipulated and analyzed.
</bodyText>
<sectionHeader confidence="0.966921" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.9918854">
We thank Mircea Lungu for his comments on an early draft of this essay. We
also gratefully acknowledge the financial support of the Swiss National Science
Foundation for the project Ã¢ÂÂAgile Software AnalysisÃ¢ÂÂ (SNSF project No. 200020-
162352, Jan 1, 2016 - Dec. 30, 2018), and its predecessor, Ã¢ÂÂAgile Software As-
sessmentÃ¢ÂÂ (SNSF project No. 200020-144126/1, Jan 1, 2013 - Dec. 30, 2015)
</bodyText>
<sectionHeader confidence="0.982749" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.998309672413793">
1. Franz Achermann and Oscar Nierstrasz. Applications = components + scripts Ã¢ÂÂ
a tour of Piccola. In Mehmet Aksit, editor, Software Architectures and Component
Technology, pages 261Ã¢ÂÂ292. Kluwer, 2001.
2. Andrea Caracciolo, Andrei ChisÃÂ§, Boris SpasojevicÃÂ, and Mircea Lungu. Pangea:
A workbench for statically analyzing multi-language software corpora. In Source
Code Analysis and Manipulation (SCAM), 2014 IEEE 14th International Working
Conference on, pages 71Ã¢ÂÂ76. IEEE, September 2014.
3. Andrea Caracciolo, Mircea Lungu, and Oscar Nierstrasz. A unified approach to
architecture conformance checking. In Proceedings of the 12th Working IEEE/IFIP
Conference on Software Architecture (WICSA), pages 41Ã¢ÂÂ50. ACM Press, May
2015.
4. Andrei ChisÃÂ§, Marcus Denker, Tudor GÃÂ±ÃÂrba, and Oscar Nierstrasz. Practical domain-
specific debuggers using the moldable debugger framework. Computer Languages,
Systems &amp; Structures, 44, Part A:89Ã¢ÂÂ113, 2015. Special issue on the 6th and 7th
International Conference on Software Language Engineering (SLE 2013 and SLE
2014).
5. Andrei ChisÃÂ§, Tudor GÃÂ±ÃÂrba, Oscar Nierstrasz, and Aliaksei Syrel. The moldable
inspector. In Proceedings of the 2015 ACM International Symposium on New
Ideas, New Paradigms, and Reflections on Programming and Software, Onward!
2015, page to appear, New York, NY, USA, 2015. ACM.
6. Benoit Combemale, Julien Deantoni, Benoit Baudry, Robert B France, Jean-Marc
JeÃÂzeÃÂquel, and Jordan Gray. Globalizing modeling languages. Computer, 47(6):68Ã¢ÂÂ
71, 2014.
7. Thomas Fritz and Gail C. Murphy. Using information fragments to answer the
questions developers ask. In Proceedings of the 32nd ACM/IEEE International
Conference on Software Engineering - Volume 1, ICSE Ã¢ÂÂ10, pages 175Ã¢ÂÂ184, New
York, NY, USA, 2010. ACM.
The Death of Object-Oriented Programming 9
8. Alan C. Kay. The early history of Smalltalk. In ACM SIGPLAN Notices, vol-
ume 28, pages 69Ã¢ÂÂ95. ACM Press, March 1993.
9. Paul Klint, Tijs van der Storm, and Jurgen Vinju. RASCAL: A domain specific
language for source code analysis and manipulation. In Source Code Analysis and
Manipulation, 2009. SCAM Ã¢ÂÂ09. Ninth IEEE International Working Conference
on, pages 168Ã¢ÂÂ177, 2009.
10. Jan KursÃÂ, Mircea Lungu, Rathesan Iyadurai, and Oscar Nierstrasz. Bounded seas.
Computer Languages, Systems &amp; Structures, 44, Part A:114 Ã¢ÂÂ 140, 2015. Special is-
sue on the 6th and 7th International Conference on Software Language Engineering
(SLE 2013 and {SLE} 2014).
11. John H. Maloney and Randall B. Smith. Directness and liveness in the Morphic
user interface construction environment. In Proceedings of the 8th annual ACM
symposium on User interface and software technology, UIST Ã¢ÂÂ95, pages 21Ã¢ÂÂ28, New
York, NY, USA, 1995. ACM.
12. Oscar Nierstrasz, SteÃÂphane Ducasse, and Tudor GÃÂ±ÃÂrba. The story of Moose: an agile
reengineering environment. In Proceedings of the European Software Engineering
Conference (ESEC/FSEÃ¢ÂÂ05), pages 1Ã¢ÂÂ10, New York, NY, USA, September 2005.
ACM Press. Invited paper.
13. Oscar Nierstrasz and Jan KursÃÂ. Parsing for agile modeling. Science of Computer
Programming, 97, Part 1(0):150Ã¢ÂÂ156, 2015.
14. Lukas Renggli, SteÃÂphane Ducasse, Tudor GÃÂ±ÃÂrba, and Oscar Nierstrasz. Practical
dynamic grammars for dynamic languages. In 4th Workshop on Dynamic Lan-
guages and Applications (DYLA 2010), pages 1Ã¢ÂÂ4, Malaga, Spain, June 2010.
15. Lukas Renggli, Tudor GÃÂ±ÃÂrba, and Oscar Nierstrasz. Embedding languages without
breaking tools. In Theo DÃ¢ÂÂHondt, editor, ECOOPÃ¢ÂÂ10: Proceedings of the 24th
European Conference on Object-Oriented Programming, volume 6183 of LNCS,
pages 380Ã¢ÂÂ404, Maribor, Slovenia, 2010. Springer-Verlag.
16. Jonathan Sillito, Gail C. Murphy, and Kris De Volder. Asking and answering
questions during a programming change task. IEEE Trans. Softw. Eng., 34:434Ã¢ÂÂ
451, July 2008.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.286881">
<title confidence="0.978011">The Death of Object-Oriented Programming?</title>
<address confidence="0.450132">Oscar Nierstrasz1 Software Composition Group, University of Bern, Switzerland</address>
<web confidence="0.999354">http://scg.unibe.ch/</web>
<abstract confidence="0.999207304347826">Modern software systems are increasingly long-lived. In order to gracefully evolve these systems as they address new requirements, developers need to navigate effectively between domain concepts and the code that addresses those domains. One of the original promises of object-orientation was that the same object-oriented models would be used throughout requirements analysis, design and implementation. Software systems today however are commonly constructed from a heterogeneous Ã¢ÂÂlanguage soupÃ¢ÂÂ of mainstream code and dedicated DSLs addressing a variety of application and technical domains. Has objectoriented programming outlived its purpose? In this essay we argue that we need to rethink the original goals of object-orientation and their relevance for modern software development. We propose as a driving maxim, Ã¢ÂÂProgramming is Modeling,Ã¢ÂÂ and explore what this implies for programming languages, tools and environments. In particular, we argue that: (1) source code should serve not only to specify an implementation of a software system, but should encode a queryable and manipulable model of the application and technical domains concerned; (2) IDEs should exploit these domain models to enable inexpensive browsing, querying and analysis by developers; and (3) barriers between the code base, the running application, and the software ecosystem at large need to be broken down, and their connections exploited and monitored to support developers in comprehension and evolution tasks.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Franz Achermann</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Applications = components + scripts Ã¢ a tour of Piccola.</title>
<date>2001</date>
<booktitle>In Mehmet Aksit, editor, Software Architectures and Component Technology,</booktitle>
<pages>261--292</pages>
<publisher>Kluwer,</publisher>
<contexts>
<context position="9044" citStr="[1]" startWordPosition="1370" endWordPosition="1370">r Nierstrasz programs = objects + messages. While this is not incorrect, it is a mechanistic interpretation that misses the key point. In our view, the object-oriented paradigm is better expressed as: Ã¢design your own paradigmÃ¢ (i.e. programming is modeling). A well-designed object-oriented system consists of objects representing exactly the domain abstractions that are needed for your application and suitable operations over them (if you like, a many-sorted algebra). Code can be separated into the objects (or Ã¢componentsÃ¢) representing domain concepts, and scripts that configure them [1]. We therefore posit as a challenge to revive object-oriented programming by viewing OO languages as modeling languages, not just implementation languages. Rather than viewing DSLs and MDD as the competition, we should encourage the use of OO languages as modeling tools, and even as language workbenches for developing embedded DSLs.3 3 Exploit domain models in the IDE Although developers are known to spend much of their development time reading and analyzing code, mainstream IDEs do not do a good job of supporting program comprehension. IDEs are basically glorified text editors. Developers nee</context>
</contexts>
<marker>1.</marker>
<rawString>Franz Achermann and Oscar Nierstrasz. Applications = components + scripts Ã¢ÂÂ a tour of Piccola. In Mehmet Aksit, editor, Software Architectures and Component Technology, pages 261Ã¢ÂÂ292. Kluwer, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrea Caracciolo</author>
<author>Andrei ChisÃÂ§</author>
<author>Boris SpasojevicÃ</author>
<author>Mircea Lungu</author>
</authors>
<title>Pangea: A workbench for statically analyzing multi-language software corpora.</title>
<date>2014</date>
<booktitle>In Source Code Analysis and Manipulation (SCAM), 2014 IEEE 14th International Working Conference on,</booktitle>
<pages>71--76</pages>
<publisher>IEEE,</publisher>
<contexts>
<context position="15361" citStr="[2]" startWordPosition="2367" endWordPosition="2367">am development.) A third barrier exists between the system under development and the larger ecosystem of related software. Countless research efforts in the past decade have shown that, by mining the ecosystem, much useful knowledge can be gleaned about common coding practices, bugs and bug fixes, and so on. Unfortunately this information is not readily accessible to developers, so they often turn instead to question and answer fora. We see two main challenges, namely Ã¢Ecosystem MiningÃ¢ and Ã¢Evolutionary Monitoring.Ã¢ By mining software ecosystems and offering platforms to analyze them [2], we hope to automatically discover intelligence relevant to a given project. Examples are opportunities for code reuse, automatically-generated and evolving documentation, and usage information than can influence maintainers of libraries and frameworks. Evolutionary Monitoring refers to steering the evolution of a software system by monitoring stakeholder needs. An example of this is architectural monitoring [3] which formalizes architectural constraints and monitors conformance as the application evolves. Other examples include tracking the needs of stakeholders (i.e. both developers and use</context>
</contexts>
<marker>2.</marker>
<rawString>Andrea Caracciolo, Andrei ChisÃÂ§, Boris SpasojevicÃÂ, and Mircea Lungu. Pangea: A workbench for statically analyzing multi-language software corpora. In Source Code Analysis and Manipulation (SCAM), 2014 IEEE 14th International Working Conference on, pages 71Ã¢ÂÂ76. IEEE, September 2014.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrea Caracciolo</author>
<author>Mircea Lungu</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>A unified approach to architecture conformance checking.</title>
<date></date>
<booktitle>In Proceedings of the 12th Working IEEE/IFIP Conference on Software Architecture (WICSA),</booktitle>
<pages>41--50</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="15777" citStr="[3]" startWordPosition="2423" endWordPosition="2423">tion and answer fora. We see two main challenges, namely Ã¢Ecosystem MiningÃ¢ and Ã¢Evolutionary Monitoring.Ã¢ By mining software ecosystems and offering platforms to analyze them [2], we hope to automatically discover intelligence relevant to a given project. Examples are opportunities for code reuse, automatically-generated and evolving documentation, and usage information than can influence maintainers of libraries and frameworks. Evolutionary Monitoring refers to steering the evolution of a software system by monitoring stakeholder needs. An example of this is architectural monitoring [3] which formalizes architectural constraints and monitors conformance as the application evolves. Other examples include tracking the needs of stakeholders (i.e. both developers and users) to determine chronic pain points and opportunities for improvements; tracking technical debt to assess priorities for reengineering and replacement; and monitoring technical trends, especially with respect to relevent technical debt. In the long run, we envision a development environment that integrates not just the current code base and the running application, enabling easy navigation between them, but also</context>
</contexts>
<marker>3.</marker>
<rawString>Andrea Caracciolo, Mircea Lungu, and Oscar Nierstrasz. A unified approach to architecture conformance checking. In Proceedings of the 12th Working IEEE/IFIP Conference on Software Architecture (WICSA), pages 41Ã¢ÂÂ50. ACM Press, May</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrei ChisÃÂ§</author>
<author>Marcus Denker</author>
<author>Tudor GÃÂ±Ãrba</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Practical domainspecific debuggers using the moldable debugger framework.</title>
<date>2014</date>
<booktitle>Computer Languages, Systems &amp; Structures, 44, Part A:89Ã¢113, 2015. Special issue on the 6th and 7th International Conference on Software Language Engineering (SLE 2013 and SLE</booktitle>
<contexts>
<context position="12155" citStr="[4]" startWordPosition="1864" endWordPosition="1864">t-Oriented Programming 5 of the context of the domain model of the code under study so they can adapt themselves accordingly. Fig. 1. A domain-specific debugger for PetitParser. The debugging view displays relevant information for debugging parsers ((4) Input, (5) Production structure). Each widget loads relevant debugging operations (1, 2, 4). An example is the Ã¢moldable debuggerÃ¢ which, instead of presenting only a generic stack-based interface to the run-time environment, is aware of relevant domain concepts, such as notifications in an event-driven system, or grammar rules in a parser [4]. In Figure 1 we see a screenshot of a domain-specific debugger for PetitParser, a parser combinator framework for Pharo Smalltalk [14]. Each widget of the debugger is context-sensitive and loads the appropriate debugging operations for the current context. The debugger is aware of a grammarÃ¢s production rules and is capable, for example, of stepping to the next production or the next parser failure, rather than simply to the next expression, statement or method. Custom visualizations are also loaded to display the production structure in a suitable way. Custom debuggers can be defined in a </context>
</contexts>
<marker>4.</marker>
<rawString>Andrei ChisÃÂ§, Marcus Denker, Tudor GÃÂ±ÃÂrba, and Oscar Nierstrasz. Practical domainspecific debuggers using the moldable debugger framework. Computer Languages, Systems &amp; Structures, 44, Part A:89Ã¢ÂÂ113, 2015. Special issue on the 6th and 7th International Conference on Software Language Engineering (SLE 2013 and SLE 2014).</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrei ChisÃÂ§</author>
<author>Tudor GÃÂ±Ãrba</author>
<author>Oscar Nierstrasz</author>
<author>Aliaksei Syrel</author>
</authors>
<title>The moldable inspector.</title>
<date>2015</date>
<booktitle>In Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software, Onward!</booktitle>
<publisher>ACM.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="12992" citStr="[5]" startWordPosition="1994" endWordPosition="1994">or the current context. The debugger is aware of a grammarÃ¢s production rules and is capable, for example, of stepping to the next production or the next parser failure, rather than simply to the next expression, statement or method. Custom visualizations are also loaded to display the production structure in a suitable way. Custom debuggers can be defined in a straightforward way by leveraging the explicit representation of the underlying application domain. The same principles have been applied to the Ã¢moldable inspector,Ã¢ a contextaware tool for querying and exploring an object space [5]. Domain-specific views are automatically loaded depending on the entities being inspected. As with the moldable debugger, custom views are commonly expressed with just a few lines of code. 6 Oscar Nierstrasz In the long run we envision a development environment in which we are not forced to extract models from code, but in which the code is actually a model that we can interact with, query and analyze. The Death of Object-Oriented Programming 7 4 Link the code to its ecosystem Conventional software systems are trapped behind a number of artificial barriers. The most obvious is the barrier bet</context>
</contexts>
<marker>5.</marker>
<rawString>Andrei ChisÃÂ§, Tudor GÃÂ±ÃÂrba, Oscar Nierstrasz, and Aliaksei Syrel. The moldable inspector. In Proceedings of the 2015 ACM International Symposium on New Ideas, New Paradigms, and Reflections on Programming and Software, Onward! 2015, page to appear, New York, NY, USA, 2015. ACM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benoit Combemale</author>
<author>Julien Deantoni</author>
<author>Benoit Baudry</author>
<author>Robert B France</author>
<author>Jean-Marc JeÃzeÃquel</author>
<author>Jordan Gray</author>
</authors>
<title>Globalizing modeling languages.</title>
<date>2014</date>
<journal>Computer,</journal>
<volume>47</volume>
<issue>6</issue>
<contexts>
<context position="8411" citStr="[6]" startWordPosition="1280" endWordPosition="1280">terfaces,Ã¢ so they can be hard to achieve post hoc. We think that many of these problems have their roots in a fundamental misunderstanding of the object-oriented paradigm. While the imperative programming paradigm can be summarized as programs = algorithms + data structures, object-oriented programming is often explained (following Alan Kay [8][p 78]) as 1 A representative selection of related work can be found in the research plan of our SNSF project, Ã¢Agile Software AnalysisÃ¢: http://scg.unibe.ch/research/snf16 2 Coping with this complexity is one of the goals of the GEMOC initiative [6]. See http://gemoc.org. 4 Oscar Nierstrasz programs = objects + messages. While this is not incorrect, it is a mechanistic interpretation that misses the key point. In our view, the object-oriented paradigm is better expressed as: Ã¢design your own paradigmÃ¢ (i.e. programming is modeling). A well-designed object-oriented system consists of objects representing exactly the domain abstractions that are needed for your application and suitable operations over them (if you like, a many-sorted algebra). Code can be separated into the objects (or Ã¢componentsÃ¢) representing domain concepts, an</context>
</contexts>
<marker>6.</marker>
<rawString>Benoit Combemale, Julien Deantoni, Benoit Baudry, Robert B France, Jean-Marc JeÃÂzeÃÂquel, and Jordan Gray. Globalizing modeling languages. Computer, 47(6):68Ã¢ÂÂ 71, 2014.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thomas Fritz</author>
<author>Gail C Murphy</author>
</authors>
<title>Using information fragments to answer the questions developers ask.</title>
<date>2010</date>
<journal>ACM. The Death of Object-Oriented Programming</journal>
<booktitle>In Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 1, ICSE Ã¢10,</booktitle>
<volume>9</volume>
<pages>175--184</pages>
<location>New York, NY, USA,</location>
<contexts>
<context position="9736" citStr="[16,7]" startWordPosition="1476" endWordPosition="1476">O languages as modeling languages, not just implementation languages. Rather than viewing DSLs and MDD as the competition, we should encourage the use of OO languages as modeling tools, and even as language workbenches for developing embedded DSLs.3 3 Exploit domain models in the IDE Although developers are known to spend much of their development time reading and analyzing code, mainstream IDEs do not do a good job of supporting program comprehension. IDEs are basically glorified text editors. Developers need custom analyses to answer the questions that arise during typical development tasks [16,7]. Building a dedicated analysis tool is expensive, even using a plugin architecture such as that of Eclipse. Dedicated analysis platforms like Moose [12] and Rascal [9] reduce the cost of custom queries, but they rely on the existence of a queryable model of the target software. As we have seen in the previous section, even though we would like to see programs as models, they are not in a form useful for querying and analysis, so we need to do extra work to extract these models and work with them. We see two important challenges. The first is Ã¢Agile Model ExtractionÃ¢, i.e. the ability to e</context>
</contexts>
<marker>7.</marker>
<rawString>Thomas Fritz and Gail C. Murphy. Using information fragments to answer the questions developers ask. In Proceedings of the 32nd ACM/IEEE International Conference on Software Engineering - Volume 1, ICSE Ã¢ÂÂ10, pages 175Ã¢ÂÂ184, New York, NY, USA, 2010. ACM. The Death of Object-Oriented Programming 9</rawString>
</citation>
<citation valid="true">
<authors>
<author>Alan C Kay</author>
</authors>
<title>The early history of Smalltalk. In</title>
<date>1993</date>
<journal>ACM SIGPLAN Notices,</journal>
<volume>28</volume>
<pages>69--95</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="8157" citStr="[8]" startWordPosition="1241" endWordPosition="1241"> (1) the syntax of many mainstream object-oriented languages does not support well the design of truly fluent interfaces (with some notable exceptions, such as Smalltalk, Ruby, Scala, ...), and (2) design methods emphasize the development of Ã¢fluent interfaces,Ã¢ so they can be hard to achieve post hoc. We think that many of these problems have their roots in a fundamental misunderstanding of the object-oriented paradigm. While the imperative programming paradigm can be summarized as programs = algorithms + data structures, object-oriented programming is often explained (following Alan Kay [8][p 78]) as 1 A representative selection of related work can be found in the research plan of our SNSF project, Ã¢Agile Software AnalysisÃ¢: http://scg.unibe.ch/research/snf16 2 Coping with this complexity is one of the goals of the GEMOC initiative [6]. See http://gemoc.org. 4 Oscar Nierstrasz programs = objects + messages. While this is not incorrect, it is a mechanistic interpretation that misses the key point. In our view, the object-oriented paradigm is better expressed as: Ã¢design your own paradigmÃ¢ (i.e. programming is modeling). A well-designed object-oriented system consists of o</context>
</contexts>
<marker>8.</marker>
<rawString>Alan C. Kay. The early history of Smalltalk. In ACM SIGPLAN Notices, volume 28, pages 69Ã¢ÂÂ95. ACM Press, March 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Paul Klint</author>
<author>Tijs van der Storm</author>
<author>Jurgen Vinju</author>
</authors>
<title>RASCAL: A domain specific language for source code analysis and manipulation.</title>
<date>2009</date>
<booktitle>In Source Code Analysis and Manipulation,</booktitle>
<pages>168--177</pages>
<contexts>
<context position="9904" citStr="[9]" startWordPosition="1502" endWordPosition="1502">odeling tools, and even as language workbenches for developing embedded DSLs.3 3 Exploit domain models in the IDE Although developers are known to spend much of their development time reading and analyzing code, mainstream IDEs do not do a good job of supporting program comprehension. IDEs are basically glorified text editors. Developers need custom analyses to answer the questions that arise during typical development tasks [16,7]. Building a dedicated analysis tool is expensive, even using a plugin architecture such as that of Eclipse. Dedicated analysis platforms like Moose [12] and Rascal [9] reduce the cost of custom queries, but they rely on the existence of a queryable model of the target software. As we have seen in the previous section, even though we would like to see programs as models, they are not in a form useful for querying and analysis, so we need to do extra work to extract these models and work with them. We see two important challenges. The first is Ã¢Agile Model ExtractionÃ¢, i.e. the ability to efficiently extract models from source code. This is not just a problem of parsing heterogeneous code and linking concepts encoded in different languages (e.g. Java, SQL</context>
</contexts>
<marker>9.</marker>
<rawString>Paul Klint, Tijs van der Storm, and Jurgen Vinju. RASCAL: A domain specific language for source code analysis and manipulation. In Source Code Analysis and Manipulation, 2009. SCAM Ã¢ÂÂ09. Ninth IEEE International Working Conference on, pages 168Ã¢ÂÂ177, 2009.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jan KursÃ</author>
<author>Mircea Lungu</author>
<author>Rathesan Iyadurai</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Bounded seas.</title>
<date>2014</date>
<booktitle>Computer Languages, Systems &amp; Structures, 44, Part A:114 Ã¢ 140, 2015. Special issue on the 6th and 7th International Conference on Software Language Engineering (SLE 2013 and {SLE}</booktitle>
<contexts>
<context position="10707" citStr="[10,13]" startWordPosition="1634" endWordPosition="1634">s models, they are not in a form useful for querying and analysis, so we need to do extra work to extract these models and work with them. We see two important challenges. The first is Ã¢Agile Model ExtractionÃ¢, i.e. the ability to efficiently extract models from source code. This is not just a problem of parsing heterogeneous code and linking concepts encoded in different languages (e.g. Java, SQL, XML), but also of recognizing concepts coming from numerous and intertwined domain models. We are experimenting with approximate parsing technology, inexpensive heuristics, and other techniques [10,13] to quickly and cheaply extract models from heterogeneous source code. The second challenge is Ã¢Context-Aware ToolingÃ¢, i.e. the ability to cheaply construct dedicated, custom analyses and tools that close the gap between IDEs and application software. The key idea is, once we have access to the underlying domain model of of code (whether it is offered by the underlying infrastructure or obtained by Agile Model Extraction), to make it easy to exploit that model in tools used by developers to produce code, browse and query it, analyze it and debug it. On the one hand, generic core functiona</context>
</contexts>
<marker>10.</marker>
<rawString>Jan KursÃÂ, Mircea Lungu, Rathesan Iyadurai, and Oscar Nierstrasz. Bounded seas. Computer Languages, Systems &amp; Structures, 44, Part A:114 Ã¢ÂÂ 140, 2015. Special issue on the 6th and 7th International Conference on Software Language Engineering (SLE 2013 and {SLE} 2014).</rawString>
</citation>
<citation valid="true">
<authors>
<author>John H Maloney</author>
<author>Randall B Smith</author>
</authors>
<title>Directness and liveness in the Morphic user interface construction environment.</title>
<date>1995</date>
<booktitle>In Proceedings of the 8th annual ACM symposium on User interface and software technology, UIST Ã¢95,</booktitle>
<pages>21--28</pages>
<publisher>ACM.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="14062" citStr="[11]" startWordPosition="2172" endWordPosition="2172">to its ecosystem Conventional software systems are trapped behind a number of artificial barriers. The most obvious is the barrier between the source code and the running application. This is manifested in the usual program/compile/run cycle. This makes it difficult to navigate between application features and source code. The debugger is classically the only place where the developer can navigate between the two worlds. It does not have to be that way, as seen in the Morphic framework of Self, in which one may navigate freely between user interface widgets and the source code related to them [11]. (This is just one dramatic manifestation of Ã¢live programmingÃ¢, but perhaps one of the most important ones for program comprehension.) A second barrier is that between a current version of a system and other related versions. In order to extract useful information about the evolution of the system, one must resort to Ã¢mining software repositoriesÃ¢, but this possibility is not readily available to average developers who do not have spare capacity to carry out such studies. Furthermore, different versions cannot normally co-exist within a single running system, complicating integration</context>
</contexts>
<marker>11.</marker>
<rawString>John H. Maloney and Randall B. Smith. Directness and liveness in the Morphic user interface construction environment. In Proceedings of the 8th annual ACM symposium on User interface and software technology, UIST Ã¢ÂÂ95, pages 21Ã¢ÂÂ28, New York, NY, USA, 1995. ACM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oscar Nierstrasz</author>
<author>SteÃphane Ducasse</author>
<author>Tudor GÃÂ±Ãrba</author>
</authors>
<title>The story of Moose: an agile reengineering environment.</title>
<date>2005</date>
<booktitle>In Proceedings of the European Software Engineering Conference (ESEC/FSEÃ¢05),</booktitle>
<pages>1--10</pages>
<publisher>ACM Press.</publisher>
<location>New York, NY, USA,</location>
<note>Invited paper.</note>
<contexts>
<context position="9889" citStr="[12]" startWordPosition="1499" endWordPosition="1499">O languages as modeling tools, and even as language workbenches for developing embedded DSLs.3 3 Exploit domain models in the IDE Although developers are known to spend much of their development time reading and analyzing code, mainstream IDEs do not do a good job of supporting program comprehension. IDEs are basically glorified text editors. Developers need custom analyses to answer the questions that arise during typical development tasks [16,7]. Building a dedicated analysis tool is expensive, even using a plugin architecture such as that of Eclipse. Dedicated analysis platforms like Moose [12] and Rascal [9] reduce the cost of custom queries, but they rely on the existence of a queryable model of the target software. As we have seen in the previous section, even though we would like to see programs as models, they are not in a form useful for querying and analysis, so we need to do extra work to extract these models and work with them. We see two important challenges. The first is Ã¢Agile Model ExtractionÃ¢, i.e. the ability to efficiently extract models from source code. This is not just a problem of parsing heterogeneous code and linking concepts encoded in different languages </context>
</contexts>
<marker>12.</marker>
<rawString>Oscar Nierstrasz, SteÃÂphane Ducasse, and Tudor GÃÂ±ÃÂrba. The story of Moose: an agile reengineering environment. In Proceedings of the European Software Engineering Conference (ESEC/FSEÃ¢ÂÂ05), pages 1Ã¢ÂÂ10, New York, NY, USA, September 2005. ACM Press. Invited paper.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oscar Nierstrasz</author>
<author>Jan KursÃ</author>
</authors>
<title>Parsing for agile modeling.</title>
<date>2015</date>
<journal>Science of Computer Programming, 97, Part</journal>
<volume>1</volume>
<issue>0</issue>
<contexts>
<context position="10707" citStr="[10,13]" startWordPosition="1634" endWordPosition="1634">s models, they are not in a form useful for querying and analysis, so we need to do extra work to extract these models and work with them. We see two important challenges. The first is Ã¢Agile Model ExtractionÃ¢, i.e. the ability to efficiently extract models from source code. This is not just a problem of parsing heterogeneous code and linking concepts encoded in different languages (e.g. Java, SQL, XML), but also of recognizing concepts coming from numerous and intertwined domain models. We are experimenting with approximate parsing technology, inexpensive heuristics, and other techniques [10,13] to quickly and cheaply extract models from heterogeneous source code. The second challenge is Ã¢Context-Aware ToolingÃ¢, i.e. the ability to cheaply construct dedicated, custom analyses and tools that close the gap between IDEs and application software. The key idea is, once we have access to the underlying domain model of of code (whether it is offered by the underlying infrastructure or obtained by Agile Model Extraction), to make it easy to exploit that model in tools used by developers to produce code, browse and query it, analyze it and debug it. On the one hand, generic core functiona</context>
</contexts>
<marker>13.</marker>
<rawString>Oscar Nierstrasz and Jan KursÃÂ. Parsing for agile modeling. Science of Computer Programming, 97, Part 1(0):150Ã¢ÂÂ156, 2015.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lukas Renggli</author>
<author>SteÃphane Ducasse</author>
<author>Tudor GÃÂ±Ãrba</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Practical dynamic grammars for dynamic languages.</title>
<date>2010</date>
<booktitle>In 4th Workshop on Dynamic Languages and Applications (DYLA 2010),</booktitle>
<pages>1--4</pages>
<location>Malaga, Spain,</location>
<contexts>
<context position="12290" citStr="[14]" startWordPosition="1885" endWordPosition="1885">A domain-specific debugger for PetitParser. The debugging view displays relevant information for debugging parsers ((4) Input, (5) Production structure). Each widget loads relevant debugging operations (1, 2, 4). An example is the Ã¢moldable debuggerÃ¢ which, instead of presenting only a generic stack-based interface to the run-time environment, is aware of relevant domain concepts, such as notifications in an event-driven system, or grammar rules in a parser [4]. In Figure 1 we see a screenshot of a domain-specific debugger for PetitParser, a parser combinator framework for Pharo Smalltalk [14]. Each widget of the debugger is context-sensitive and loads the appropriate debugging operations for the current context. The debugger is aware of a grammarÃ¢s production rules and is capable, for example, of stepping to the next production or the next parser failure, rather than simply to the next expression, statement or method. Custom visualizations are also loaded to display the production structure in a suitable way. Custom debuggers can be defined in a straightforward way by leveraging the explicit representation of the underlying application domain. The same principles have been appli</context>
</contexts>
<marker>14.</marker>
<rawString>Lukas Renggli, SteÃÂphane Ducasse, Tudor GÃÂ±ÃÂrba, and Oscar Nierstrasz. Practical dynamic grammars for dynamic languages. In 4th Workshop on Dynamic Languages and Applications (DYLA 2010), pages 1Ã¢ÂÂ4, Malaga, Spain, June 2010.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lukas Renggli</author>
<author>Tudor GÃÂ±Ãrba</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Embedding languages without breaking tools.</title>
<date>2010</date>
<booktitle>ECOOPÃ¢10: Proceedings of the 24th European Conference on Object-Oriented Programming,</booktitle>
<volume>6183</volume>
<pages>380--404</pages>
<editor>In Theo DÃ¢Hondt, editor,</editor>
<publisher>Springer-Verlag.</publisher>
<location>Maribor, Slovenia,</location>
<contexts>
<context position="11532" citStr="[15]" startWordPosition="1770" endWordPosition="1770">ween IDEs and application software. The key idea is, once we have access to the underlying domain model of of code (whether it is offered by the underlying infrastructure or obtained by Agile Model Extraction), to make it easy to exploit that model in tools used by developers to produce code, browse and query it, analyze it and debug it. On the one hand, generic core functionality is needed for querying and navigating models. On the other hand, tools and environments need to be aware 3 See, for example, Helvetia, a workbench for integrating DSLs into the IDE and toolchain of the host language [15]. The Death of Object-Oriented Programming 5 of the context of the domain model of the code under study so they can adapt themselves accordingly. Fig. 1. A domain-specific debugger for PetitParser. The debugging view displays relevant information for debugging parsers ((4) Input, (5) Production structure). Each widget loads relevant debugging operations (1, 2, 4). An example is the Ã¢moldable debuggerÃ¢ which, instead of presenting only a generic stack-based interface to the run-time environment, is aware of relevant domain concepts, such as notifications in an event-driven system, or gramma</context>
</contexts>
<marker>15.</marker>
<rawString>Lukas Renggli, Tudor GÃÂ±ÃÂrba, and Oscar Nierstrasz. Embedding languages without breaking tools. In Theo DÃ¢ÂÂHondt, editor, ECOOPÃ¢ÂÂ10: Proceedings of the 24th European Conference on Object-Oriented Programming, volume 6183 of LNCS, pages 380Ã¢ÂÂ404, Maribor, Slovenia, 2010. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jonathan Sillito</author>
<author>Gail C Murphy</author>
<author>Kris De Volder</author>
</authors>
<title>Asking and answering questions during a programming change task.</title>
<date>2008</date>
<journal>IEEE Trans. Softw. Eng.,</journal>
<volume>34</volume>
<pages>451</pages>
<contexts>
<context position="9736" citStr="[16,7]" startWordPosition="1476" endWordPosition="1476">O languages as modeling languages, not just implementation languages. Rather than viewing DSLs and MDD as the competition, we should encourage the use of OO languages as modeling tools, and even as language workbenches for developing embedded DSLs.3 3 Exploit domain models in the IDE Although developers are known to spend much of their development time reading and analyzing code, mainstream IDEs do not do a good job of supporting program comprehension. IDEs are basically glorified text editors. Developers need custom analyses to answer the questions that arise during typical development tasks [16,7]. Building a dedicated analysis tool is expensive, even using a plugin architecture such as that of Eclipse. Dedicated analysis platforms like Moose [12] and Rascal [9] reduce the cost of custom queries, but they rely on the existence of a queryable model of the target software. As we have seen in the previous section, even though we would like to see programs as models, they are not in a form useful for querying and analysis, so we need to do extra work to extract these models and work with them. We see two important challenges. The first is Ã¢Agile Model ExtractionÃ¢, i.e. the ability to e</context>
</contexts>
<marker>16.</marker>
<rawString>Jonathan Sillito, Gail C. Murphy, and Kris De Volder. Asking and answering questions during a programming change task. IEEE Trans. Softw. Eng., 34:434Ã¢ÂÂ 451, July 2008.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>