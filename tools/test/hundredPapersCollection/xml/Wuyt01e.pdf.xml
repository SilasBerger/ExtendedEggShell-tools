<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000030">
<figure confidence="0.956194818181818">
Non-Functional Requirements in a Component Model for
Embedded Systems
Position Paper
Roel Wuyts
Software Composition Group
Institut für Informatik
Universität Bern, Switzerland
roel.wuyts@iam.unibe.ch
Stéphane Ducasse
Software Composition Group
Institut für Informatik
</figure>
<address confidence="0.429286">
Universität Bern, Switzerland
</address>
<email confidence="0.831822">
ducasse@iam.unibe.ch
</email>
<sectionHeader confidence="0.891689" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.991984166666667">
In this paper we describe an interesting context to study
formal methods for component systems: embedded devices.
The context of embedded devices is highly constrained by
the physical requirements the devices have to adhere to.
As a result, component models for embedded devices are
not general purpose but geared towards these constrained
contexts. In this paper we give the concrete setting of the
Pecos project (a project with as goal component engineering
for embedded devices). We describe the Pecos component
model, and show possibilities where we think formal verifi-
cation could be useful. We would like to use this as a very
concrete example to discuss formal verification techniques.
</bodyText>
<sectionHeader confidence="0.998288" genericHeader="introduction">
1. INTRODUCTION
</sectionHeader>
<bodyText confidence="0.999351104166667">
Software for embedded systems is typically monolithic and
platform-dependent. These systems are hard to maintain,
upgrade and customise, and they are almost impossible to
port to other platforms. Component-based software engi-
neering would bring a number of advantages to the embed-
ded systems world such as fast development times, the abil-
ity to secure investments through re-use of existing compo-
nents, and the ability for domain experts to interactively
compose sophisticated embedded systems software [7].
The goal of the PECOS (PErvasive COmponent Systems)
project (a European Esprit project) is to find solutions for
component oriented development (COD) for embedded sys-
tems . In this context we are developping Comes (a general
Component Meta-Model) and the Pecos Model (a special-
ization of Comes targeted towards embedded systems in the
context of the project).
In Comes, components are black-box encapsulations of be-
havior. They have interfaces that consist of properties and
ports, can contain subcomponents, and have consistency
rules that express structural integration internal to the com-
ponent (for example, to check dependencies between prop-
erties). The ports of components are connected by explicit
connectors. Consistency rules of the composite component
can reason about the properties of the composite, but also
on the connectors and the properties of the sub components.
The Pecos Model is a specialization of Comes to explicitly
support components for embedded devices in the context of
the Pecos project. Interesting is that this puts a lot of ex-
tra constraints on the component model. We firmly believe
that this will allow us to use formal (mathematical) tech-
niques to verify non-functional requirements of the modeled
components. More specifically, we want support regarding
timing and scheduling and memory consumption.
For this workshop we see ourselves as the providers of an in-
teresting problem and problem context. We believe that the
extra constraints imposed by the context of our component
model make it a good example to use and assess the func-
tionality of formal techniques. Coming from a practical, less
formal discipline of software engineering and programming
language design, we want to discuss with the more math-
ematically enclined researchers on how to come to formal
support for specifying and checking components.
In the rest of the paper we introduce the specific problem
context of embedded systems in more detail. Then we show
the current version of the component model. Finally we
enumerate the places where we think that formal techniques
could help us, and discuss techniques we think are of interest
to us.
</bodyText>
<sectionHeader confidence="0.998872" genericHeader="method">
2. THE EMBEDDED SYSTEMS CONTEXT
</sectionHeader>
<bodyText confidence="0.999548735294118">
A massive shift is going from desktop applications to em-
bedded systems, where intelligent devices taking over roles
that are currently done in desktop applications. Moreover,
the capabilities of embedded devices augment rapidly, and
their responsibilities increase likewise. Distributed embed-
ded devices (intelligent field devices, smart sensors) not only
acquire but also pre-process data and run more and more
sophisticated application programs (control functions, self-
diagnostics, etc.).
The drawback of this evolution is that the software needs
to follow. Here the story is less positive: the software engi-
neering techniques that are typically employed are lacking
far behind software engineering techniques for mainstream
applications. Currently software for embedded devices is
written in assembly or C, in a monolithic fashion, with a
typical development time of two to three years. The reasons
for this are two-fold. The first reason is the specific con-
text of embedded devices (with all the constraints of power
comsumption and simple hardware as a result of this). The
second reason is that, up until a couple of years ago, the mar-
ket for embedded devices was relatively small, and was thus
neglected by the big players from desktop applications. For
example, operating systems or development environments
are hard to find for embedded systems.
The goal of the PECOS (PErvasive COmponent Systems)
project is to apply solutions for component oriented devel-
opment (COD) in the context of embedded systems. As in
desktop applications, the overall goal is to have more reuse,
higher quality and reduced development time. Key factor
in the project is the component model to support compo-
nents for embedded systems. Before we have a look at this
model, we first introduce the Pecos component development
process, and field devices, the embedded systems the Pecos
model should support.
</bodyText>
<subsectionHeader confidence="0.893957">
2.1 Pecos Process
</subsectionHeader>
<bodyText confidence="0.994571">
Part of the solution of the Pecos project is a component de-
velopment process. In this section we give a quick overview
of this process, as this will help to introduce some choices
made in the Pecos Component Model. The process consists
of two main phases: the component construction phase and
the field device assembly phase.
The component construction phase defines what is needed
to develop a single component (that possibly contains sub-
</bodyText>
<listItem confidence="0.938994454545455">
components), instrument it (to provide information about
runtime aspects of the component), and put it in the com-
ponent repository. It specifies the following workflow:
• the component is created. This means defining the
basic properties and the interface of the component.
• the subcomponents are filled in. If the component has
subcomponents, then these subcomponents need to be
selected from the repository and added to the com-
ponenent. They also need to be connected with each
other.
• the component is checked. In this phase, a structural
</listItem>
<bodyText confidence="0.949873375">
check is performed to make sure that everything is
specified according to the model, and that the given
information follows the rules in the model. For exam-
ple, when the model specifies that a component should
have a name, then this is checked at this moment.
Also, when type information needs to be given it is
checked that the given types exist. Or, if there are
subcomponents, their connections are checked.
</bodyText>
<listItem confidence="0.995287">
• generating skeleton code. When the check succeeds,
meaning that the component’s structure is verified,
skeleton code can be generated.
• filling in the skeleton: the skeleton code has to be ex-
tended into a full working implementation.
• instrumenting the component: the component is then
</listItem>
<bodyText confidence="0.924054166666667">
ready to be instrumented. In this phase it is deployed
in a standard environment so that certain runtime in-
formation can be gathered. What information depends
on the model. Since in the Pecos model we want to
check scheduling information and memory consump-
tion, basic figures need to be extracted. Note that we
need the instrumentation because we see components
as black-box abstractions where we have no idea about
their internals. If this constraint is lifted, the instru-
mentation phase could be made simpler or even omit-
ted. We discuss this in more detail when we discuss
the non-functional checks.
</bodyText>
<listItem confidence="0.886803809523809">
• the instrumented component is then added to the com-
ponent repository.
A second activity is to assemble components into field de-
vices (the actual embedded systems that need to be modeled
in the context of Pecos). This activity consists of the fol-
lowing steps:
• select a template for the field device that needs to be
created
• select the components that need to be filled in to in-
stantiate the field device
• connect the components
• perform structural checks on the instantiated field de-
vice
• perform non-functional checks using the information
provided by the components. For example, make sure
that the total power consumption of the chosen com-
ponents does not exceed the limit of the Field Device,
or that a schedule can be found to schedule the com-
ponents.
• generate the code for the field device
• deploy the component on the actual hardware
</listItem>
<bodyText confidence="0.99892275">
In the next section we have a look at Field Devices, the
actuall embedded systems used in the project. Then we in-
troduce the model to support the specification and checking
of these devices.
</bodyText>
<subsectionHeader confidence="0.992972">
2.2 Field Devices
</subsectionHeader>
<bodyText confidence="0.957824666666667">
Field devices are embedded reactive systems. A field device
can analyze temperature, pressure, and flow, and control
some actuators, positioners of valves or other motors. Field
devices impose certain specific physical constraints For ex-
ample a TZID (a pneumatic positioner) works under the
following very hard constraint: the available power is only
100 mW for the whole device. This limits severely the avail-
able CPU and memory resources. The TZID uses a 16 bit
micro-controller with 256k ROM and 20k RAM (on-chip),
and communicates using fieldbus communication stacks (an
interoperability standard for communication between field
devices). The device has a static software configuration,
i.e., the firmware is updated/replaced completely, and there
is no dynamic loadable functionality.
As a result from the physical constraints (especially the very
harsh power consumption requirements), the runtime envi-
ronment and the software are subject to the following con-
straints:
</bodyText>
<listItem confidence="0.965446147058824">
• One processor: all the components composing a field
device are running on a single processor, that is very
slow when compared to mainstream processors.
• One monolithic piece of code: after assembling the
different components that compose a field device, the
software for the field device forms one single piece that
is deployed.
• No dynamic change: At run-time (after the field de-
vice is initialized) there is no memory allocation, nor
dynamic reconfiguration.
• Single language per application: a component is cre-
ated in a single language like C or C++.
• Multi-threading: field device components can be run-
ning on different threads. The scheduling is carried out
by either the OS or by an explicit scheduler. However,
most of the components are passive and scheduled by
a central scheduler. Components that are active (that
have their own thread) are typically the ones close to
the hardware. They are responsible for regularly read-
ing values from this hardware, such as the current mo-
tor position or speed.
• Components communicate by sharing data contained
in a blackboard-like structure. Components read and
write data they want to communicate to this central
memory location.
• Some components are described by state automata.
Some components have state, others are stateless be-
cause they are only representing algorithms.
• Components only offer interfaces in terms of in/out
ports. The component state automata definition, or
other behavorial descriptions, are not available. This
is a very hard requirement, as this means that a lot of
existing formal verification techniques are not usable.
• A field device architecture is fixed. It is composed by
</listItem>
<bodyText confidence="0.6981286">
an Analog component controlling the overall workings
of the device, a Transducer component that interfaces
to the hardware, a HMI component for the Human-
Machine interaction and an EEPROM component to
store data in non-volatile memory.
</bodyText>
<sectionHeader confidence="0.835112" genericHeader="method">
3. THE PECOS COMPONENT MODEL
</sectionHeader>
<bodyText confidence="0.912338333333333">
The Pecos Component Model is the foundation of the Pecos
project. Its goal is to allow to specify and check components
and Field Devices, given the constraints given above. In
this section we iterate over the requirements for the model,
introduce its main aspects. In the next section we then look
at how formal techniques could be applied in this context.
</bodyText>
<subsectionHeader confidence="0.992467">
3.1 Requirements
</subsectionHeader>
<bodyText confidence="0.752190666666667">
The goal of the Pecos Component Model is to be able to
model and check a field device. More specifically, it has to
allow:
</bodyText>
<listItem confidence="0.936333">
• to specify individual components (that can contain
subcomponents);
• to connect components;
• to assemble components into Field Devices;
• to check the structure and well-formedness of compo-
nent compositions and Field Devices;
• to check non-functional requirements of Field Devices.
More specifically, timing and scheduling of components,
and their memory consumption;
</listItem>
<subsectionHeader confidence="0.99814">
3.2 Model Overview
</subsectionHeader>
<bodyText confidence="0.999270807692307">
In the constraints imposed by the context of embedded sys-
tems on field devices we already saw that Field Devices fol-
low a blackboard-like achitecture. Hence, there is a central
block of memory (called the Object Manager, or OM for
short) that holds all the values that need to be passed be-
tween components in a field device. The OM is filled when
the field device is initializad. At runtime, its structure does
not change (as there is no allocation at runtime after the
initialization). Components that need to share data to do
by writing and reading from the OM.
Normally, when components would all be running in their
own thread and hence in parallel, locking and synchroniza-
tion of the OM would certainly be needed. However, in the
specific context of a field device such a solution,(typical solu-
tion for desktop applications), is not possible. The reason is
that it’s too expensive in both processing power and memory
consumption, and that OS facilities to support locking and
synchronization are not always available or very costly. Field
devices solve the problem by providing one central scheduler
that sequentially schedules all components. Hence, at any
moment in time, only one component has access to the OM
and thus no locking is needed. Of course, this introduces
other problems as well, that we will discuss in detail later
on when we talk about supporting (checking) non-functional
requirements.
The Pecos model builds on our experiences with support-
</bodyText>
<listItem confidence="0.797604444444444">
ing Software Architectures using logic programming lan-
guages [6]. The main constituents are components, ports
and connectors:
• component : a Pecos component has a name, contains
information regarding scheduling and memory consump-
tion (see further), has a list of data ports and possibly
has a list of subcomponents and connectors for these
subcomponents;
• data ports: a data port indicates that the component
</listItem>
<bodyText confidence="0.923669947368421">
provides or needs data for other components. It con-
tains a type (of the data that will be passed, such as
Float), a direction (in, out or inout),
• connectors connect data ports of components, and hence
model a data dependency between two ports. Connec-
tors contain the names of the component and the ports
they connect
Besides this structural information, we also check some Pecos
specific constraints, such as type and range information on
ports. Table 1 lists all the structural checks that can be
performed.
Besides the components and connectors, the Pecos model
also offers a Field Device template. This is a template com-
ponent that has to be instantiated with 4 concrete compo-
nents. The Field Device component specifies the structure
and the behaviour of a field device in such a way that its
structure and semantics can be checked, and that code can
be generated from it. To instantiate the field devoce, four
components and their connections that have to be specified:
</bodyText>
<listItem confidence="0.999059428571429">
• Human Machine Interface Component : a field-device
can be equipped with displays and other devices so
that users can inspect or modify the behaviour from
the device itself
• Non-volatile memory Component : the state of the com-
ponent needs to be written to certain kinds of memory
• Input-Output-Controller Component : the data from
</listItem>
<bodyText confidence="0.971172">
the device component typically consist of raw values
that are immediately related to the hardware contained.
The function of this component is to provide an in-
terface to the other non-hardware related components
that is not hardware specific. For example, it can scale
raw data from the hardware so that the display can
show the value of a temperature controller in degrees
Celsius.
</bodyText>
<listItem confidence="0.945772">
• Device Component : all components that deal with the
</listItem>
<bodyText confidence="0.9934336">
hardware are encapsulated by this component.
The result is a Field Device that can be checked for well-
formedness (making sure that everytthing conforms to the
structural rules) and for non-functional requirements. These
last checks are the topic of the following section.
</bodyText>
<sectionHeader confidence="0.996015" genericHeader="method">
4. CHECKING OF NON-FUNCTIONAL RE-
QUIREMENTS
</sectionHeader>
<bodyText confidence="0.999761923076923">
The previous sections described the context of field devices
and the Pecos component model to model components for
field devices. However, it didn’t give much information
about the checking of non-functional requirements. In this
section we describe what we would like to support, and what
we are currently doing. We also give information about re-
lated formal work that we think could be useful (but that
we not use at the moment of writing).
In the Pecos project we want to support two issues, that we
have already touched upon throughout the paper: schedul-
ing of components and memory consumption. We explain
these two issues in more detail, and then have a look at
opportunities we see for formal verification.
</bodyText>
<subsectionHeader confidence="0.999596">
4.1 Component Scheduling
</subsectionHeader>
<bodyText confidence="0.999866068181818">
We already explained that in field devices we do not want
to use regular locking of data, but instead want to schedule
the components sequentially such that this is not needed.
Hence, a very important aspect that needs to be checked
when a field device component is instantiated is the sched-
uler.
More specifically, we currently instrument every individual
component with information regarding its execution time
(the time it takes to execute its behaviour once) and with in-
formation about its cycletime(the number of times it needs
to be executed in one scheduler cycle). Using this infor-
mation (combined with the information of the data depen-
dency provided by the connectors) we are now investigat-
ing whether it is possible to derive or check a scheduler.
The hardest thing to solve is that we currently identified
three kinds of components: passive components, active com-
ponents and event components. Passive components are
straightforward to handle: they just need to be scheduled
by the scheduler such that their execution and cycling infor-
mation is met. Active components are more difficult. The
reason is that they have their own thread that is running
inside of the component. This thread is typically used to
read-out values directly from hardware, such as the current
speed of a motor. In the current implementation used in
field devices, these values write to internal fields in the com-
ponent, and when the component is scheduled the values
in the internal fields are copied to the OM. Hence, active
components are scheduled and handled exactly as passive
components, even though they have their own thread. We
are currently debating whether this is a good solution, and
what would be alternatives. Event components pose the
same problems as active components. They do not have
their own thread, but act as event sinks that have to cap-
ture and react to events sent by certain pieces of hardware.
Just as with active components, they capture an event, wait
until they are scheduled by the scheduler and then handle
the event.
At the moment of writing we are still investigating possible
solutions to check and generate the scheduler, with proba-
bly the most interesting option to express all the scheduler
constraints using Constraint Logic Programming over Real
Numbers (CLP(R)), and calculate possible schedules. By
the time of the workshop we will have a concrete solution
for this problem, as this is currently under full development.
</bodyText>
<subsectionHeader confidence="0.985477">
4.2 Memory consumption
</subsectionHeader>
<bodyText confidence="0.999724625">
Due to the minimal memory available in field devices, the
memory occupied by a component is a crucial information.
The model should support the computation of the compo-
nent size and checks for component substituability.
To perform the checks, every component is instrumented
with the size it needs for its code and for its data. This
should then be summed and combined with the information
from the blackboard.
</bodyText>
<subsectionHeader confidence="0.981902">
4.3 Possibilities for Formal Verification
</subsectionHeader>
<bodyText confidence="0.987025666666667">
We are thinking to lift the constraint that components are
completely black-box, and adding and using state charts as
a way to describe the behavior of components. When we
</bodyText>
<tableCaption confidence="0.848944">
Table 1: Structural Checks in the Pecos Component Model
</tableCaption>
<bodyText confidence="0.997231846153846">
Port The type of the property can only be one in a fixed set (Float, Tfloat, Tscale, . . . );
The direction should be in, out or inout;
The location of a port has to be ’static’, ’dynamic’, or ’nv’;
The minimum in the range is smaller than the maximum.
Component The State can only be active, passive or ’event’;
All the numbers regarding timing and code sizes should be positive or 0..
Connector Connectors can only connect out and in; ports;
The types of the ports should be compatible;
The ranges of ports should be compatible;
do this, we can think of using synchronous languages such
as Esterel [1], Argo/Argonaute [5], Lustre [3], CRP [2] and
combined approaches [4].
Especially Esterel seems a natural candidate to use in the
context of embedded systems. It is a synchronous and im-
perative concurrent language dedicated to control-dominated
reactive programs which are found in real-time process con-
trol, embedded systems, supervision of complex systems,
communication protocols and HMI. In Esterel, programs
are abstractions that manipulate input signals and gener-
ate output signals. Once programs are expressed in Esterel
they can be formally proved (i.e., non-reachability of state,
timing constraints), compiled to C in a compact form, and
simulated. In the context of Pecos, Esterel seems particu-
larly interesting because the size generated is suitable for
field devices and, more important, timing issues and mem-
ory consumption can be verified:
</bodyText>
<listItem confidence="0.606342">
• it allows the verification that given an input, the out-
put of a program is comprised in a certain amount of
cycles of the input. This means that component sub-
stitution could be verified.
• it allows different code generation schemas. The first
</listItem>
<bodyText confidence="0.9856485">
one is boolean generation. By counting the number
of instructions the exact size of a component and its
exact execution time can be counted. The second is
condition-based and can provide maximum execution
time for a component.
Another possibility would be to look at the formalism of
timed state automata, to take timing information into ac-
count.
</bodyText>
<sectionHeader confidence="0.99957" genericHeader="conclusions">
5. CONCLUSION
</sectionHeader>
<bodyText confidence="0.997608823529412">
In this paper we describe the context of embedded systems,
for which we made a component model to specify and check
Field Devices (a particular kind of embedded system). Due
to the physical constraints imposed on embedded systems,
a component model for embedded devices has very specific
constraints: no runtime allocation, no locking or synchro-
nization, and a simple scheduler. We describe the Pecos
Component Model that we are developing, and that allows
to specify and check Field Devices and their components.
The most interesting aspect of the model is that we want to
check certain non-functional requirements before the soft-
ware for the field device is deployed in the hardware. This
is still under ful development. We showed the current status
of the checks, and where we suspect that formal techniques
could be welcomed. In the workshop we want to discuss
with people from the formal community, using our context
as a test case.
</bodyText>
<sectionHeader confidence="0.998251" genericHeader="references">
6. REFERENCES
</sectionHeader>
<reference confidence="0.99928526923077">
[1] G. Berry. The foundations of Esterel. MIT Press, 2000.
Editors: G. Plotkin, C. Stirling and M. Tofte.
[2] G. Berry, S. Ramesh, and R. K. Shyamasundar.
Communicating reactive processes. In ACM, editor,
Conference Record of the Twentieth Annual ACM
SIGPLAN-SIGACT Symposium on Principles of
Programming Languages: papers presented at the
symposium, Charleston, South Carolina, January
10–13, 1993, pages 85–98. ACM Press, 1993.
[3] N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud.
The synchronous data flow programming language
lustre. In Proceedings of the IEEE, September 1991.
[4] F. M. M. Jourdan, F. Lagnier and P. Raymond. A
multiparadigm language for reactive systems. In
Proceedings of the IEEE Internal Conference on
Computer Languages, 1994.
[5] F. Maraninchi. The argos language: Graphical
representation of automata and description of reactive
systems. In Proceedings of the IEEE Internal
Conference on Visual Languages, 1991.
[6] K. Mens, R. Wuyts, and T. D’Hondt. Declaratively
codifying software architectures using virtual software
classifications. In Proceedings of TOOLS-Europe 99,
pages 33–45, June 1999.
[7] C. A. Szyperski. Component Software. Addison-Wesley,
1998.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.623421">
<title confidence="0.943362">Non-Functional Requirements in a Component Model for Embedded Systems Position Paper</title>
<author confidence="0.942306">Roel Wuyts</author>
<affiliation confidence="0.989279">Software Composition Group Institut für Informatik</affiliation>
<address confidence="0.941365">Universität Bern, Switzerland</address>
<email confidence="0.982711">roel.wuyts@iam.unibe.ch</email>
<author confidence="0.944248">Stéphane Ducasse</author>
<affiliation confidence="0.9978055">Software Composition Group Institut für Informatik</affiliation>
<address confidence="0.966496">Universität Bern, Switzerland</address>
<email confidence="0.974969">ducasse@iam.unibe.ch</email>
<abstract confidence="0.996657692307692">In this paper we describe an interesting context to study formal methods for component systems: embedded devices. The context of embedded devices is highly constrained by the physical requirements the devices have to adhere to. As a result, component models for embedded devices are not general purpose but geared towards these constrained contexts. In this paper we give the concrete setting of the Pecos project (a project with as goal component engineering for embedded devices). We describe the Pecos component model, and show possibilities where we think formal verification could be useful. We would like to use this as a very concrete example to discuss formal verification techniques.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>G Berry</author>
</authors>
<title>The foundations of Esterel.</title>
<date>2000</date>
<publisher>MIT Press,</publisher>
<note>Editors:</note>
<contexts>
<context position="21207" citStr="[1]" startWordPosition="3426" endWordPosition="3426">Port The type of the property can only be one in a fixed set (Float, Tfloat, Tscale, . . . ); The direction should be in, out or inout; The location of a port has to be ’static’, ’dynamic’, or ’nv’; The minimum in the range is smaller than the maximum. Component The State can only be active, passive or ’event’; All the numbers regarding timing and code sizes should be positive or 0.. Connector Connectors can only connect out and in; ports; The types of the ports should be compatible; The ranges of ports should be compatible; do this, we can think of using synchronous languages such as Esterel [1], Argo/Argonaute [5], Lustre [3], CRP [2] and combined approaches [4]. Especially Esterel seems a natural candidate to use in the context of embedded systems. It is a synchronous and imperative concurrent language dedicated to control-dominated reactive programs which are found in real-time process control, embedded systems, supervision of complex systems, communication protocols and HMI. In Esterel, programs are abstractions that manipulate input signals and generate output signals. Once programs are expressed in Esterel they can be formally proved (i.e., non-reachability of state, timing con</context>
</contexts>
<marker>[1]</marker>
<rawString>G. Berry. The foundations of Esterel. MIT Press, 2000. Editors: G. Plotkin, C. Stirling and M. Tofte.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Berry</author>
<author>S Ramesh</author>
<author>R K Shyamasundar</author>
</authors>
<title>Communicating reactive processes.</title>
<date>1993</date>
<booktitle>In ACM, editor, Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages: papers presented at the symposium,</booktitle>
<pages>85--98</pages>
<publisher>ACM Press,</publisher>
<location>Charleston, South Carolina,</location>
<contexts>
<context position="21248" citStr="[2]" startWordPosition="3432" endWordPosition="3432"> one in a fixed set (Float, Tfloat, Tscale, . . . ); The direction should be in, out or inout; The location of a port has to be ’static’, ’dynamic’, or ’nv’; The minimum in the range is smaller than the maximum. Component The State can only be active, passive or ’event’; All the numbers regarding timing and code sizes should be positive or 0.. Connector Connectors can only connect out and in; ports; The types of the ports should be compatible; The ranges of ports should be compatible; do this, we can think of using synchronous languages such as Esterel [1], Argo/Argonaute [5], Lustre [3], CRP [2] and combined approaches [4]. Especially Esterel seems a natural candidate to use in the context of embedded systems. It is a synchronous and imperative concurrent language dedicated to control-dominated reactive programs which are found in real-time process control, embedded systems, supervision of complex systems, communication protocols and HMI. In Esterel, programs are abstractions that manipulate input signals and generate output signals. Once programs are expressed in Esterel they can be formally proved (i.e., non-reachability of state, timing constraints), compiled to C in a compact for</context>
</contexts>
<marker>[2]</marker>
<rawString>G. Berry, S. Ramesh, and R. K. Shyamasundar. Communicating reactive processes. In ACM, editor, Conference Record of the Twentieth Annual ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages: papers presented at the symposium, Charleston, South Carolina, January 10–13, 1993, pages 85–98. ACM Press, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Halbwachs</author>
<author>P Caspi</author>
<author>P Raymond</author>
<author>D Pilaud</author>
</authors>
<title>The synchronous data flow programming language lustre.</title>
<date>1991</date>
<booktitle>In Proceedings of the IEEE,</booktitle>
<contexts>
<context position="21239" citStr="[3]" startWordPosition="3430" endWordPosition="3430">n only be one in a fixed set (Float, Tfloat, Tscale, . . . ); The direction should be in, out or inout; The location of a port has to be ’static’, ’dynamic’, or ’nv’; The minimum in the range is smaller than the maximum. Component The State can only be active, passive or ’event’; All the numbers regarding timing and code sizes should be positive or 0.. Connector Connectors can only connect out and in; ports; The types of the ports should be compatible; The ranges of ports should be compatible; do this, we can think of using synchronous languages such as Esterel [1], Argo/Argonaute [5], Lustre [3], CRP [2] and combined approaches [4]. Especially Esterel seems a natural candidate to use in the context of embedded systems. It is a synchronous and imperative concurrent language dedicated to control-dominated reactive programs which are found in real-time process control, embedded systems, supervision of complex systems, communication protocols and HMI. In Esterel, programs are abstractions that manipulate input signals and generate output signals. Once programs are expressed in Esterel they can be formally proved (i.e., non-reachability of state, timing constraints), compiled to C in a co</context>
</contexts>
<marker>[3]</marker>
<rawString>N. Halbwachs, P. Caspi, P. Raymond, and D. Pilaud. The synchronous data flow programming language lustre. In Proceedings of the IEEE, September 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F M M Jourdan</author>
<author>F Lagnier</author>
<author>P Raymond</author>
</authors>
<title>A multiparadigm language for reactive systems.</title>
<date>1994</date>
<booktitle>In Proceedings of the IEEE Internal Conference on Computer Languages,</booktitle>
<contexts>
<context position="21276" citStr="[4]" startWordPosition="3436" endWordPosition="3436">Tfloat, Tscale, . . . ); The direction should be in, out or inout; The location of a port has to be ’static’, ’dynamic’, or ’nv’; The minimum in the range is smaller than the maximum. Component The State can only be active, passive or ’event’; All the numbers regarding timing and code sizes should be positive or 0.. Connector Connectors can only connect out and in; ports; The types of the ports should be compatible; The ranges of ports should be compatible; do this, we can think of using synchronous languages such as Esterel [1], Argo/Argonaute [5], Lustre [3], CRP [2] and combined approaches [4]. Especially Esterel seems a natural candidate to use in the context of embedded systems. It is a synchronous and imperative concurrent language dedicated to control-dominated reactive programs which are found in real-time process control, embedded systems, supervision of complex systems, communication protocols and HMI. In Esterel, programs are abstractions that manipulate input signals and generate output signals. Once programs are expressed in Esterel they can be formally proved (i.e., non-reachability of state, timing constraints), compiled to C in a compact form, and simulated. In the con</context>
</contexts>
<marker>[4]</marker>
<rawString>F. M. M. Jourdan, F. Lagnier and P. Raymond. A multiparadigm language for reactive systems. In Proceedings of the IEEE Internal Conference on Computer Languages, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Maraninchi</author>
</authors>
<title>The argos language: Graphical representation of automata and description of reactive systems.</title>
<date>1991</date>
<booktitle>In Proceedings of the IEEE Internal Conference on Visual Languages,</booktitle>
<contexts>
<context position="21227" citStr="[5]" startWordPosition="3428" endWordPosition="3428"> property can only be one in a fixed set (Float, Tfloat, Tscale, . . . ); The direction should be in, out or inout; The location of a port has to be ’static’, ’dynamic’, or ’nv’; The minimum in the range is smaller than the maximum. Component The State can only be active, passive or ’event’; All the numbers regarding timing and code sizes should be positive or 0.. Connector Connectors can only connect out and in; ports; The types of the ports should be compatible; The ranges of ports should be compatible; do this, we can think of using synchronous languages such as Esterel [1], Argo/Argonaute [5], Lustre [3], CRP [2] and combined approaches [4]. Especially Esterel seems a natural candidate to use in the context of embedded systems. It is a synchronous and imperative concurrent language dedicated to control-dominated reactive programs which are found in real-time process control, embedded systems, supervision of complex systems, communication protocols and HMI. In Esterel, programs are abstractions that manipulate input signals and generate output signals. Once programs are expressed in Esterel they can be formally proved (i.e., non-reachability of state, timing constraints), compiled </context>
</contexts>
<marker>[5]</marker>
<rawString>F. Maraninchi. The argos language: Graphical representation of automata and description of reactive systems. In Proceedings of the IEEE Internal Conference on Visual Languages, 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Mens</author>
<author>R Wuyts</author>
<author>T D’Hondt</author>
</authors>
<title>Declaratively codifying software architectures using virtual software classifications.</title>
<date>1999</date>
<booktitle>In Proceedings of TOOLS-Europe 99,</booktitle>
<pages>33--45</pages>
<contexts>
<context position="14303" citStr="[6]" startWordPosition="2277" endWordPosition="2277">umption, and that OS facilities to support locking and synchronization are not always available or very costly. Field devices solve the problem by providing one central scheduler that sequentially schedules all components. Hence, at any moment in time, only one component has access to the OM and thus no locking is needed. Of course, this introduces other problems as well, that we will discuss in detail later on when we talk about supporting (checking) non-functional requirements. The Pecos model builds on our experiences with supporting Software Architectures using logic programming languages [6]. The main constituents are components, ports and connectors: • component : a Pecos component has a name, contains information regarding scheduling and memory consumption (see further), has a list of data ports and possibly has a list of subcomponents and connectors for these subcomponents; • data ports: a data port indicates that the component provides or needs data for other components. It contains a type (of the data that will be passed, such as Float), a direction (in, out or inout), • connectors connect data ports of components, and hence model a data dependency between two ports. Connect</context>
</contexts>
<marker>[6]</marker>
<rawString>K. Mens, R. Wuyts, and T. D’Hondt. Declaratively codifying software architectures using virtual software classifications. In Proceedings of TOOLS-Europe 99, pages 33–45, June 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C A Szyperski</author>
</authors>
<title>Component Software.</title>
<date>1998</date>
<publisher>Addison-Wesley,</publisher>
<contexts>
<context position="1549" citStr="[7]" startWordPosition="221" endWordPosition="221">o use this as a very concrete example to discuss formal verification techniques. 1. INTRODUCTION Software for embedded systems is typically monolithic and platform-dependent. These systems are hard to maintain, upgrade and customise, and they are almost impossible to port to other platforms. Component-based software engineering would bring a number of advantages to the embedded systems world such as fast development times, the ability to secure investments through re-use of existing components, and the ability for domain experts to interactively compose sophisticated embedded systems software [7]. The goal of the PECOS (PErvasive COmponent Systems) project (a European Esprit project) is to find solutions for component oriented development (COD) for embedded systems . In this context we are developping Comes (a general Component Meta-Model) and the Pecos Model (a specialization of Comes targeted towards embedded systems in the context of the project). In Comes, components are black-box encapsulations of behavior. They have interfaces that consist of properties and ports, can contain subcomponents, and have consistency rules that express structural integration internal to the component </context>
</contexts>
<marker>[7]</marker>
<rawString>C. A. Szyperski. Component Software. Addison-Wesley, 1998.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>