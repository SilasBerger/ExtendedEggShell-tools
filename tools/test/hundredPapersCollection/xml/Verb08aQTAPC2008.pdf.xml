<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.002386">
<figure confidence="0.459513181818182">
Query Technologies and Applications for Program Comprehension
In Proceedings of ICPC 2008, pp. 285-288
Mathieu Verbaere
Semmle Limited
United Kingdom
Michael W. Godfrey
University of Waterloo
Canada
Tudor Gı̂rba
University of Berne
Switzerland
</figure>
<sectionHeader confidence="0.939204" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.998795421052632">
Industrial software systems are large and complex, both
in terms of the software entities and their relationships.
Consequently, understanding how a software system works
requires the ability to pose queries over the design-level en-
tities of the system. Traditionally, this task has been sup-
ported by simple tools (e.g., grep) combined with the pro-
grammer’s intuition and experience. Recently, however,
specialized code query technologies have matured to the
point where they can be used in industrial situations, pro-
viding more intelligent, timely, and efficient responses to de-
veloper queries.
This working session aims to explore the state of the art
in code query technologies, and discover new ways in which
these technologies may be useful in program comprehen-
sion. The session brings together researchers and prac-
titioners. We survey existing techniques and applications,
trying to understand the strengths and weaknesses of the
various approaches, and sketch out new frontiers that hold
promise.
</bodyText>
<sectionHeader confidence="0.998006" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.999494566666667">
Understanding source code is vital to many tasks in soft-
ware engineering. Developers need to understand the sys-
tem they work on in order to improve quality, enhance
functionality, and re-engineer for new deployment environ-
ments. Querying tools are designed to help developers com-
prehend the varied and complex relationships within their
codebase. They enable the interactive exploration of a sys-
tem and the definition of custom views.
Recently, the use of code queries has spread to other
tasks, e.g., for detecting architectural flaws, identifying
refactoring opportunities, locating project-specific bugs,
finding crosscutting concerns. Queries may also be used
in a diagnostic role, such as for monitoring development
progress, assessing design quality, tracking unwanted de-
pendencies, and gathering quality metrics on every build.
For queries to be effective, we need to integrate them
with the rest of software engineering tools. At the very least,
query results must be presented to the developer. One direc-
tion is to provide visualization techniques that correlate the
results of the queries with the overall structure of the code-
base under study. Another option is to take query results as
input for further queries and analyses.
This short paper is a brief introduction to code queries
and their applications. First, we describe the use of queries
in two major areas of software engineering: quality assur-
ance and reengineering. Then, we highlight the important
role of queries in software visualization, and present differ-
ent code query technologies. Finally, we discuss some chal-
lenges around code queries to foster the initial discussion of
the session.
</bodyText>
<sectionHeader confidence="0.97468" genericHeader="method">
2 Queries for quality assurance
</sectionHeader>
<bodyText confidence="0.998300142857143">
Software quality can be assessed and improved by com-
puting metrics, finding common bugs, checking style rules
and enforcing coding conventions that are specific to an
API.
A wealth of different metrics have been proposed to de-
tect design flaws [20]. Metrics values are usually presented
in isolation or grouped to measure a particular design as-
pect, but design problems are difficult to spot from a large
set of abnormal values. By allowing metrics results to be
filtered and tuned to the specificities of a system, queries
can help developers and architects pin down the real cause
of design flaws [23].
More and more development teams now run static pro-
gram analyzers on a daily basis to check for common bugs.
When expressed as queries, these checks can easily be tuned
per project to reduce the number of false positives. Perhaps
where the greatest benefit lies, however, is in framework-
specific checks. Indeed, modern systems rely on an ever
growing number of frameworks. Queries allow the expres-
sion of concise, executable rules that client code of an API
must follow [5].
</bodyText>
<page confidence="0.93765">
1
</page>
<bodyText confidence="0.9996026">
Naturally, quality checks can be performed on different
versions of the same system, to monitor its development.
Queries are helpful for that purpose too. In particular, they
can be used to check that no design inconsistencies are in-
troduced during the evolution of a system [24].
</bodyText>
<sectionHeader confidence="0.971977" genericHeader="method">
3 Queries for reengineering
</sectionHeader>
<bodyText confidence="0.999590965517241">
Not only can queries detect violations of certain design
principles, but they also play an important role in driving de-
velopment and performing design recovery. The canonical
use of querying for such tasks involves several steps. First,
the source code is run through a fact extractor, which creates
a somewhat higher level model of the source code entities
and their interdependencies than the code itself. Entities are
commonly at the level of files, classes, functions/methods,
global and instance variables, while relationships include
file inclusion, calls, variable set/reference, and instantiation.
Once these models have been created, queries can be
run to infer other relationships, check for design violations,
and create higher level (package, subsystem) entities whose
properties are based on those of their contained elements.
For example, one might wish to know if there are any calls
from subsystem A to B that do not go through module M
(the intended interface for the subsystem). Or one might
assign classes to subsystems and then verify that the sub-
systems form a layered architecture with no calls between
modules that violate the layering.
The Grok query language has been used together with
other tools such as fact extractors, for both reverse engi-
neering of designs from code as well as for ensuring that
architectural rules are enforced by developers [11].
A main concern in reengineering is to bridge the gap
between models and source code. Reflexion models ad-
dress exactly that issue by defining a mapping between the
two [18, 27]. There again, mappings can be declared and
checked with code queries.
</bodyText>
<sectionHeader confidence="0.94007" genericHeader="method">
4 Queries and visualization
</sectionHeader>
<bodyText confidence="0.9884275">
Typically, we need to relate the results of a query to the
context in which they live. Thus, visualization can comple-
</bodyText>
<listItem confidence="0.972724285714286">
ment queries in at least two ways:
• By locating the results in the overall system. For ex-
ample, Seesoft is a tool for visualizing line oriented
software information for several files [9]. Such a vi-
sualization offers a map of the whole system on which
we can highlight the results of queries.
• By providing details about the results so that further
</listItem>
<bodyText confidence="0.985427125">
analyses can be more efficient. For example, Code-
Crawler [19] implements the concept of polymetric
views to map metrics and design flaws on source code
visualizations [20].
Other tools have been proposed to deal with the above
issues. Rigi uses a graph metaphor for displaying software
systems [26]. SHriMP provides an interactive environment
in which the engineer can navigate the system [32]. NDe-
pend highlights the results of queries on treemaps [28].
Visualization transforms the system models into graph-
ical models, which are typically graphs. Gsee provides a
simple interface for specifying the mapping to visualiza-
tion [10]. Mondrian also offers an engine for scripting such
transformations [25]. These approaches aim at reducing the
cost of building custom visualization, and as such they can
be used for showing the results of custom queries.
</bodyText>
<sectionHeader confidence="0.958056" genericHeader="method">
5 Query technologies
</sectionHeader>
<bodyText confidence="0.999468685714286">
There are many different approaches to querying source
code. Perhaps the most natural solution is to store the pro-
gram in a database. One of the earliest proposals of this
kind was Linton’s Omega system [21]; queries were formu-
lated in the Ingres query language QUEL. In the same vein,
the C Information Abstraction system [3] showed how to
store the code structure of a system into a database for gen-
erating graphical views, extracting subsystems, and elimi-
nating dead code. These systems have had quite an impact
on industrial practice, as numerous companies now use a
database system as a code repository, e.g. [2, 31]. Another
natural possibility, given the tree structure of source code,
is to employ an XML representation of the source code. In
Sextant [7] for instance, software engineering tasks are ex-
pressed with XQuery. Of course, the clear advantage of
XQuery and SQL is that they are already familiar to most
programmers. Both languages, however, are quite verbose
and less declarative for expressing recursive queries on the
complex graph representation of a program. A typical ex-
ample of such recursive queries is to search, while cleaning
up a piece of legacy software, for methods that are never
called directly or indirectly from main methods.
Logic programming languages are much better suited for
those tasks. The XL C++ Browser [15] was one of the first
to promote Prolog for expressing typical queries over source
code. More recently, logic programming in the tradition of
Prolog has inspired tools like Soul [24], JQuery [13] and
JTransformer [17]. Yet, the learning curve of Prolog is quite
long and complex queries are also often verbose.
In many systems therefore, a deliberate choice was
made to simplify the set of expressible recursive queries.
GraphLog [4] is a query language with just enough power
to express paths queries on graphs. GReQL [6] is another
graph query language, but with a syntax close to SQL. Fur-
ther examples of domain-specific languages for code search
</bodyText>
<page confidence="0.934224">
2
</page>
<bodyText confidence="0.999203090909091">
are the program query language PQL [14] or pattern-based
languages as enabled by SCRUPLE [29]. A few other sys-
tems went the neat route of relational algebra, e.g. Grok
[11], CrocoPat [1] and RScript [16]. Perhaps the princi-
pal benefit of those systems is in efficient algorithms for
implementing and optimizing relational operations — for
instance, CrocoPat uses BDDs to compactly represent huge
relations. Those systems, however, are usually not restricted
to declarative queries; most of them embed imperative con-
structs to allow the extraction and manipulation of facts.
Interestingly, there is a language that is purely declara-
tive, rule-based like Prolog, and that can be executed us-
ing relational algebra. That is Datalog, a query language
originally put forward in the context of deductive databases.
Datalog has been proposed at various occasions for analyz-
ing source code, e.g. [4, 30]. It has a simple semantics
and can be executed efficiently on top of a traditional rela-
tional database. This is the technique used in SemmleCode
[31] where queries are written in .QL [5], an object-oriented
query language with a syntax familiar to SQL and OO de-
velopers. For their execution, .QL queries are translated to a
variant of Datalog, optimized and further compiled to SQL.
</bodyText>
<sectionHeader confidence="0.882557" genericHeader="conclusions">
6 Open questions and challenges
</sectionHeader>
<bodyText confidence="0.99928202739726">
Although code queries have been long and well stud-
ied (our brief survey above is far from being exhaustive),
there still remain open questions and ongoing research chal-
lenges. We state here a few problems which we believe de-
serve clearer answers.
Heterogeneous models It appears now that there is no
silver-bullet model for all applications in program compre-
hension. The finer a model is, the more interesting queries
can be run, but the more complex it is to express such code
queries. One challenge is to come up with a model that
matches the mental representation that people make of a
program. How do we address the fact that such mental rep-
resentation naturally varies with the skills of the program-
mer and with the nature of the tasks? In addition, modern
software systems are now composed from pieces of code
written in a variety of programming languages, ranging
from dynamic languages to statically-typed OO languages
and the embedding of domain-specific constructs. What are
the best ways to support queries that transcend language
barriers?
Pattern-based vs general-purpose languages Typically,
code query languages fall into one of two very different cat-
egories: pattern-based languages for querying code written
in a specific object language and general-purpose languages
for querying any kind of source code artifact. The former
approach enables queries in concrete syntax, which clearly
facilitates the adoption of queries (at least for simple tasks).
On the other hand, general-purpose query languages seem
to scale to more complex problems. What are the best ways
of adding elements of concrete syntax to a general-purpose
query language?
Mixing implementation strategies Here again, certain
implementation strategies are better suited to certain con-
texts and tasks. For instance, using a database is crucial
when querying very large systems, but slightly better perfor-
mance can be achieved on medium-sized projects by fitting
the whole codebase in memory. Another example is when
querying for the transitive closure of a large call graph. The
resulting relation is often too huge to be materialized on
disk in reasonable time, whereas it could be compressed in
a BDD as in [1]. Although query languages like PQL [14]
and .QL [5] were designed so as to separate the language
from its implementation details, there has been little work
so far on mixing different evaluation strategies.
IDE integration The trend is now to integrate querying
tools into IDEs, e.g. [13, 7, 17, 31]. Queries are run in an
interactive setting where the codebase changes frequently.
To illustrate, one may run a query to spot a refactoring op-
portunity, apply the refactoring, run another query, and so
on. Also, lightweight static checks should be performed
after each change, however minor it is. These querying sce-
narios present two challenges. First, the model representing
the codebase has to be synchronized with the source code.
Second, queries need to be rerun quickly and seamlessly,
i.e. incrementally as in [8].
Code queries for other tasks Code queries have been
proposed to navigate and visualize software systems. They
have been used for the flexible definitions of code metrics,
e.g. [23, 5]. They can also express complex custom code
analyses to enforce project-specific design choice and cod-
ing conventions. We believe, however, that we have only
scratched the surface of potential applications. For instance,
code queries have been proposed to discover and document
cross-cutting concerns [22]. It would be interesting to ex-
ploit further code queries as lightweight contract definitions
to enforce documentation.
Querying all development artifacts Queries should not
be limited to source code, but run on all other development
artifacts: bug reports, version histories, documentation. Ex-
citing work on mining software archives has shown how
queries in such a broader context often reveal hidden but
crucial information about the past, present and future of a
project and its development team [12]. Surely, this work
</bodyText>
<page confidence="0.985515">
3
</page>
<bodyText confidence="0.9986825">
shall benefit from more accurate, more semantic queries
that code querying tools enable.
</bodyText>
<sectionHeader confidence="0.853365" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.88230618018018">
[1] D. Beyer. Relational programming with crocopat. In Pro-
ceedings of the 28th international conference on Software
engineering (ICSE), pages 807–810. ACM, 2006.
[2] Cast. Company website at: http://www.castsoftware.
com.
[3] Y. Chen, M. Nishimoto, and C. V. Ramamoorthy. The C
information abstraction system. IEEE Transactions on Soft-
ware Engineering, 16(3):325–334, 1990.
[4] M. Consens, A. Mendelzon, and A. Ryman. Visualizing and
querying software structures. In Proceedings of the 14th
international conference on Software engineering (ICSE),
pages 138–156, 1992.
[5] O. de Moor, M. Verbaere, E. Hajiyev, P. Avgustinov, T. Ek-
man, N. Ongkingco, D. Sereni, and J. Tibble. .QL for source
code analysis. In Source Code Analysis and Manipulation
(SCAM), 2007.
[6] J. Ebert, B. Kullbach, and A. Winter. Querying as an en-
abling technology in software reengineering. In Proceedings
of the Third European Conference on Software Maintenance
and Reengineering (CSMR), page 42. IEEE Computer Soci-
ety, 1999.
[7] M. Eichberg, M. Haupt, M. Mezini, and T. Schäfer. Compre-
hensive software understanding with Sextant. In Proceed-
ings of the 21st IEEE International Conference on Software
Maintenance (ICSM), pages 315–324, 2005.
[8] M. Eichberg, M. Kahl, D. Saha, M. Mezini, and K. Oster-
mann. Automatic incrementalization of prolog based static
analyses. In Proceedings of the 9th International Symposium
on Practical Aspects of Declarative Languages (PADL),
pages 109–123, 2007.
[9] S. G. Eick, J. L. Steffen, and E. E. Sumner. SeeSoft—a tool
for visualizing line oriented software statistics. IEEE Trans-
actions on Software Engineering, 18(11):957–968, Nov.
1992.
[10] J.-M. Favre. Gsee: a generic software exploration environ-
ment. In Proceedings of the 9th International Workshop on
Program Comprehension, pages 233–244. IEEE, May 2001.
[11] P. Finnigan, R. Holt, I. Kalas, S. Kerr, K. Kontogian-
nis, H. Mller, J. Mylopoulos, S. Perelgut, M. Stanley, and
K. Wong. The software bookshelf. IBM Systems Journal,
36(4):564–593, 1997.
[12] A. E. Hassan, A. Mockus, R. C. Holt, and P. M. Johnson.
Guest editor’s introduction: Special issue on mining soft-
ware repositories. IEEE Transactions on Software Engineer-
ing, 31(6):426–428, 2005.
[13] D. Janzen and K. de Volder. Navigating and querying
code without getting lost. In 2nd International Conference
on Aspect-Oriented Software Development (AOSD), pages
178–187, 2003.
[14] S. Jarzabek. Design of flexible static program analyzers
with PQL. IEEE Transactions on Software Engineering,
24(3):197–215, 1998.
[15] S. Javey, K. Mitsui, H. Nakamura, T. Ohira, K. Yasuda,
K. Kuse, T. Kamimura, and R. Helm. Architecture of the
XL C++ browser. In Proceedings of the 1992 conference of
the Centre for Advanced Studies on Collaborative research
(CASCON), pages 369–379, 1992.
[16] P. Klint. A tutorial introduction to RScript. Centrum voor
Wiskunde en Informatica, draft, 2005.
[17] G. Kniesel, J. Hannemann, and T. Rho. A comparison of
logic-based infrastructures for concern detection and extrac-
tion. In Proceedings of the 3rd workshop on Linking aspect
technology and evolution (LATE), page 6. ACM, 2007.
[18] R. Koschke and D. Simon. Hierarchical reflexion models. In
Proceedings of the 10th Working Conference on Reverse En-
gineering (WCRE), page 36. IEEE Computer Society, 2003.
[19] M. Lanza and S. Ducasse. CodeCrawler–an extensible
and language independent 2d and 3d software visualization
tool. In Tools for Software Maintenance and Reengineering,
RCOST / Software Technology Series, pages 74–94. Franco
Angeli, Milano, 2005.
[20] M. Lanza and R. Marinescu. Object-Oriented Metrics in
Practice. Springer-Verlag, 2006.
[21] M. A. Linton. Implementing relational views of programs.
In P. B. Henderson, editor, Software Development Environ-
ments (SDE), pages 132–140, 1984.
[22] M.Marin, L. Moonen, and A. van Deursen. SoQueT: Query-
based documentation of crosscutting concerns. In Proceed-
ings of the 29th international conference on Software en-
gineering (ICSE), pages 758–761. IEEE Computer Society,
2007.
[23] R. Marinescu. Detection strategies: Metrics-based rules for
detecting design flaws. In 20th IEEE International Con-
ference on Software Maintenance (ICSM), pages 350–359.
IEEE Computer Society Press, 2004.
[24] K. Mens, A. Kellens, F. Pluquet, and R. Wuyts. Co-evolving
code and design with intensional views — a case study.
Journal of Computer Languages, Systems and Structures,
32(2):140–156, 2006.
[25] M. Meyer, T. Gı̂rba, and M. Lungu. Mondrian: An agile
visualization framework. In ACM Symposium on Software
Visualization (SoftVis), pages 135–144. ACM Press, 2006.
[26] H. A. Müller and K. Klashinsky. Rigi — a system for
programming-in-the-large. In Proceedings of the 10th inter-
national conference on Software engineering (ICSE), pages
80–86. IEEE Computer Society Press, 1988.
[27] G. Murphy, D. Notkin, and K. Sullivan. Software reflex-
ion models: Bridging the gap between source and high-level
models. In Proceedings of the 3rd ACM SIGSOFT Sympo-
sium on the Foundations of Software Engineering, pages 18–
28. ACM Press, 1995.
[28] NDepend. Company website at: http://www.ndepend.
com.
[29] S. Paul and A. Prakash. A framework for source code
search using program patterns. IEEE Trans. Softw. Eng.,
20(6):463–475, 1994.
[30] T. W. Reps. Demand interprocedural program analysis using
logic databases. In Workshop on Programming with Logic
Databases (ILPS), pages 163–196, 1993.
[31] Semmle Limited. Company website at: http://semmle.
com.
</reference>
<page confidence="0.801414">
4
</page>
<reference confidence="0.991978">
[32] M.-A. D. Storey and H. A. Müller. Manipulating and doc-
umenting software structures using SHriMP Views. In Pro-
ceedings of the International Conference on Software Main-
tenance (ICSM), pages 275–284. IEEE Computer Society
Press, 1995.
</reference>
<page confidence="0.973219">
5
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.594274">
<title confidence="0.937574">Query Technologies and Applications for Program Comprehension</title>
<note confidence="0.991189">In Proceedings of ICPC 2008, pp. 285-288</note>
<title confidence="0.965204">Mathieu Verbaere Semmle Limited United Kingdom</title>
<author confidence="0.999832">Michael W Godfrey</author>
<affiliation confidence="0.999927">University of Waterloo</affiliation>
<address confidence="0.973938">Canada</address>
<author confidence="0.98877">Tudor Gı̂rba</author>
<affiliation confidence="0.99992">University of Berne</affiliation>
<address confidence="0.753072">Switzerland</address>
<abstract confidence="0.99691405">Industrial software systems are large and complex, both in terms of the software entities and their relationships. Consequently, understanding how a software system works requires the ability to pose queries over the design-level entities of the system. Traditionally, this task has been supported by simple tools (e.g., grep) combined with the programmer’s intuition and experience. Recently, however, specialized code query technologies have matured to the point where they can be used in industrial situations, providing more intelligent, timely, and efficient responses to developer queries. This working session aims to explore the state of the art in code query technologies, and discover new ways in which these technologies may be useful in program comprehension. The session brings together researchers and practitioners. We survey existing techniques and applications, trying to understand the strengths and weaknesses of the various approaches, and sketch out new frontiers that hold promise.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>D Beyer</author>
</authors>
<title>Relational programming with crocopat.</title>
<date>2006</date>
<booktitle>In Proceedings of the 28th international conference on Software engineering (ICSE),</booktitle>
<pages>807--810</pages>
<publisher>ACM,</publisher>
<contexts>
<context position="9546" citStr="[1]" startWordPosition="1529" endWordPosition="1529">g curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat route of relational algebra, e.g. Grok [11], CrocoPat [1] and RScript [16]. Perhaps the principal benefit of those systems is in efficient algorithms for implementing and optimizing relational operations — for instance, CrocoPat uses BDDs to compactly represent huge relations. Those systems, however, are usually not restricted to declarative queries; most of them embed imperative constructs to allow the extraction and manipulation of facts. Interestingly, there is a language that is purely declarative, rule-based like Prolog, and that can be executed using relational algebra. That is Datalog, a query language originally put forward in the context of</context>
<context position="12864" citStr="[1]" startWordPosition="2059" endWordPosition="2059">elements of concrete syntax to a general-purpose query language? Mixing implementation strategies Here again, certain implementation strategies are better suited to certain contexts and tasks. For instance, using a database is crucial when querying very large systems, but slightly better performance can be achieved on medium-sized projects by fitting the whole codebase in memory. Another example is when querying for the transitive closure of a large call graph. The resulting relation is often too huge to be materialized on disk in reasonable time, whereas it could be compressed in a BDD as in [1]. Although query languages like PQL [14] and .QL [5] were designed so as to separate the language from its implementation details, there has been little work so far on mixing different evaluation strategies. IDE integration The trend is now to integrate querying tools into IDEs, e.g. [13, 7, 17, 31]. Queries are run in an interactive setting where the codebase changes frequently. To illustrate, one may run a query to spot a refactoring opportunity, apply the refactoring, run another query, and so on. Also, lightweight static checks should be performed after each change, however minor it is. Th</context>
</contexts>
<marker>[1]</marker>
<rawString>D. Beyer. Relational programming with crocopat. In Proceedings of the 28th international conference on Software engineering (ICSE), pages 807–810. ACM, 2006.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Cast</author>
</authors>
<title>Company website at:</title>
<note>http://www.castsoftware. com.</note>
<contexts>
<context position="7976" citStr="[2, 31]" startWordPosition="1270" endWordPosition="1271"> different approaches to querying source code. Perhaps the most natural solution is to store the program in a database. One of the earliest proposals of this kind was Linton’s Omega system [21]; queries were formulated in the Ingres query language QUEL. In the same vein, the C Information Abstraction system [3] showed how to store the code structure of a system into a database for generating graphical views, extracting subsystems, and eliminating dead code. These systems have had quite an impact on industrial practice, as numerous companies now use a database system as a code repository, e.g. [2, 31]. Another natural possibility, given the tree structure of source code, is to employ an XML representation of the source code. In Sextant [7] for instance, software engineering tasks are expressed with XQuery. Of course, the clear advantage of XQuery and SQL is that they are already familiar to most programmers. Both languages, however, are quite verbose and less declarative for expressing recursive queries on the complex graph representation of a program. A typical example of such recursive queries is to search, while cleaning up a piece of legacy software, for methods that are never called d</context>
</contexts>
<marker>[2]</marker>
<rawString>Cast. Company website at: http://www.castsoftware. com.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Chen</author>
<author>M Nishimoto</author>
<author>C V Ramamoorthy</author>
</authors>
<title>The C information abstraction system.</title>
<date>1990</date>
<journal>IEEE Transactions on Software Engineering,</journal>
<volume>16</volume>
<issue>3</issue>
<contexts>
<context position="7681" citStr="[3]" startWordPosition="1221" endWordPosition="1221"> the mapping to visualization [10]. Mondrian also offers an engine for scripting such transformations [25]. These approaches aim at reducing the cost of building custom visualization, and as such they can be used for showing the results of custom queries. 5 Query technologies There are many different approaches to querying source code. Perhaps the most natural solution is to store the program in a database. One of the earliest proposals of this kind was Linton’s Omega system [21]; queries were formulated in the Ingres query language QUEL. In the same vein, the C Information Abstraction system [3] showed how to store the code structure of a system into a database for generating graphical views, extracting subsystems, and eliminating dead code. These systems have had quite an impact on industrial practice, as numerous companies now use a database system as a code repository, e.g. [2, 31]. Another natural possibility, given the tree structure of source code, is to employ an XML representation of the source code. In Sextant [7] for instance, software engineering tasks are expressed with XQuery. Of course, the clear advantage of XQuery and SQL is that they are already familiar to most prog</context>
</contexts>
<marker>[3]</marker>
<rawString>Y. Chen, M. Nishimoto, and C. V. Ramamoorthy. The C information abstraction system. IEEE Transactions on Software Engineering, 16(3):325–334, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Consens</author>
<author>A Mendelzon</author>
<author>A Ryman</author>
</authors>
<title>Visualizing and querying software structures.</title>
<date>1992</date>
<booktitle>In Proceedings of the 14th international conference on Software engineering (ICSE),</booktitle>
<pages>138--156</pages>
<contexts>
<context position="9141" citStr="[4]" startWordPosition="1459" endWordPosition="1459">e, for methods that are never called directly or indirectly from main methods. Logic programming languages are much better suited for those tasks. The XL C++ Browser [15] was one of the first to promote Prolog for expressing typical queries over source code. More recently, logic programming in the tradition of Prolog has inspired tools like Soul [24], JQuery [13] and JTransformer [17]. Yet, the learning curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat route of relational algebra, e.g. Grok [11], CrocoPat [1] and RScript [16]. Perhaps the principal benefit of those systems is in efficient algorithms for implementing and optimizing relational operations — for instance, CrocoPat uses BDDs to compactly </context>
</contexts>
<marker>[4]</marker>
<rawString>M. Consens, A. Mendelzon, and A. Ryman. Visualizing and querying software structures. In Proceedings of the 14th international conference on Software engineering (ICSE), pages 138–156, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>O de Moor</author>
<author>M Verbaere</author>
<author>E Hajiyev</author>
<author>P Avgustinov</author>
<author>T Ekman</author>
<author>N Ongkingco</author>
<author>D Sereni</author>
<author>J Tibble</author>
</authors>
<title>QL for source code analysis.</title>
<date>2007</date>
<booktitle>In Source Code Analysis and Manipulation (SCAM),</booktitle>
<contexts>
<context position="4047" citStr="[5]" startWordPosition="630" endWordPosition="630">d tuned to the specificities of a system, queries can help developers and architects pin down the real cause of design flaws [23]. More and more development teams now run static program analyzers on a daily basis to check for common bugs. When expressed as queries, these checks can easily be tuned per project to reduce the number of false positives. Perhaps where the greatest benefit lies, however, is in frameworkspecific checks. Indeed, modern systems rely on an ever growing number of frameworks. Queries allow the expression of concise, executable rules that client code of an API must follow [5]. 1 Naturally, quality checks can be performed on different versions of the same system, to monitor its development. Queries are helpful for that purpose too. In particular, they can be used to check that no design inconsistencies are introduced during the evolution of a system [24]. 3 Queries for reengineering Not only can queries detect violations of certain design principles, but they also play an important role in driving development and performing design recovery. The canonical use of querying for such tasks involves several steps. First, the source code is run through a fact extractor, w</context>
<context position="10441" citStr="[5]" startWordPosition="1671" endWordPosition="1671">es; most of them embed imperative constructs to allow the extraction and manipulation of facts. Interestingly, there is a language that is purely declarative, rule-based like Prolog, and that can be executed using relational algebra. That is Datalog, a query language originally put forward in the context of deductive databases. Datalog has been proposed at various occasions for analyzing source code, e.g. [4, 30]. It has a simple semantics and can be executed efficiently on top of a traditional relational database. This is the technique used in SemmleCode [31] where queries are written in .QL [5], an object-oriented query language with a syntax familiar to SQL and OO developers. For their execution, .QL queries are translated to a variant of Datalog, optimized and further compiled to SQL. 6 Open questions and challenges Although code queries have been long and well studied (our brief survey above is far from being exhaustive), there still remain open questions and ongoing research challenges. We state here a few problems which we believe deserve clearer answers. Heterogeneous models It appears now that there is no silver-bullet model for all applications in program comprehension. The </context>
<context position="12916" citStr="[5]" startWordPosition="2068" endWordPosition="2068">ry language? Mixing implementation strategies Here again, certain implementation strategies are better suited to certain contexts and tasks. For instance, using a database is crucial when querying very large systems, but slightly better performance can be achieved on medium-sized projects by fitting the whole codebase in memory. Another example is when querying for the transitive closure of a large call graph. The resulting relation is often too huge to be materialized on disk in reasonable time, whereas it could be compressed in a BDD as in [1]. Although query languages like PQL [14] and .QL [5] were designed so as to separate the language from its implementation details, there has been little work so far on mixing different evaluation strategies. IDE integration The trend is now to integrate querying tools into IDEs, e.g. [13, 7, 17, 31]. Queries are run in an interactive setting where the codebase changes frequently. To illustrate, one may run a query to spot a refactoring opportunity, apply the refactoring, run another query, and so on. Also, lightweight static checks should be performed after each change, however minor it is. These querying scenarios present two challenges. First</context>
</contexts>
<marker>[5]</marker>
<rawString>O. de Moor, M. Verbaere, E. Hajiyev, P. Avgustinov, T. Ekman, N. Ongkingco, D. Sereni, and J. Tibble. .QL for source code analysis. In Source Code Analysis and Manipulation (SCAM), 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Ebert</author>
<author>B Kullbach</author>
<author>A Winter</author>
</authors>
<title>Querying as an enabling technology in software reengineering.</title>
<date>1999</date>
<booktitle>In Proceedings of the Third European Conference on Software Maintenance and Reengineering (CSMR),</booktitle>
<pages>42</pages>
<publisher>IEEE Computer Society,</publisher>
<contexts>
<context position="9230" citStr="[6]" startWordPosition="1475" endWordPosition="1475">ramming languages are much better suited for those tasks. The XL C++ Browser [15] was one of the first to promote Prolog for expressing typical queries over source code. More recently, logic programming in the tradition of Prolog has inspired tools like Soul [24], JQuery [13] and JTransformer [17]. Yet, the learning curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat route of relational algebra, e.g. Grok [11], CrocoPat [1] and RScript [16]. Perhaps the principal benefit of those systems is in efficient algorithms for implementing and optimizing relational operations — for instance, CrocoPat uses BDDs to compactly represent huge relations. Those systems, however, are usually not restricted to declarati</context>
</contexts>
<marker>[6]</marker>
<rawString>J. Ebert, B. Kullbach, and A. Winter. Querying as an enabling technology in software reengineering. In Proceedings of the Third European Conference on Software Maintenance and Reengineering (CSMR), page 42. IEEE Computer Society, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Eichberg</author>
<author>M Haupt</author>
<author>M Mezini</author>
<author>T Schafer</author>
</authors>
<title>Comprehensive software understanding with Sextant.</title>
<date>2005</date>
<booktitle>In Proceedings of the 21st IEEE International Conference on Software Maintenance (ICSM),</booktitle>
<pages>315--324</pages>
<contexts>
<context position="8117" citStr="[7]" startWordPosition="1294" endWordPosition="1294">sals of this kind was Linton’s Omega system [21]; queries were formulated in the Ingres query language QUEL. In the same vein, the C Information Abstraction system [3] showed how to store the code structure of a system into a database for generating graphical views, extracting subsystems, and eliminating dead code. These systems have had quite an impact on industrial practice, as numerous companies now use a database system as a code repository, e.g. [2, 31]. Another natural possibility, given the tree structure of source code, is to employ an XML representation of the source code. In Sextant [7] for instance, software engineering tasks are expressed with XQuery. Of course, the clear advantage of XQuery and SQL is that they are already familiar to most programmers. Both languages, however, are quite verbose and less declarative for expressing recursive queries on the complex graph representation of a program. A typical example of such recursive queries is to search, while cleaning up a piece of legacy software, for methods that are never called directly or indirectly from main methods. Logic programming languages are much better suited for those tasks. The XL C++ Browser [15] was one </context>
<context position="13164" citStr="[13, 7, 17, 31]" startWordPosition="2106" endWordPosition="2109"> performance can be achieved on medium-sized projects by fitting the whole codebase in memory. Another example is when querying for the transitive closure of a large call graph. The resulting relation is often too huge to be materialized on disk in reasonable time, whereas it could be compressed in a BDD as in [1]. Although query languages like PQL [14] and .QL [5] were designed so as to separate the language from its implementation details, there has been little work so far on mixing different evaluation strategies. IDE integration The trend is now to integrate querying tools into IDEs, e.g. [13, 7, 17, 31]. Queries are run in an interactive setting where the codebase changes frequently. To illustrate, one may run a query to spot a refactoring opportunity, apply the refactoring, run another query, and so on. Also, lightweight static checks should be performed after each change, however minor it is. These querying scenarios present two challenges. First, the model representing the codebase has to be synchronized with the source code. Second, queries need to be rerun quickly and seamlessly, i.e. incrementally as in [8]. Code queries for other tasks Code queries have been proposed to navigate and v</context>
</contexts>
<marker>[7]</marker>
<rawString>M. Eichberg, M. Haupt, M. Mezini, and T. Schäfer. Comprehensive software understanding with Sextant. In Proceedings of the 21st IEEE International Conference on Software Maintenance (ICSM), pages 315–324, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Eichberg</author>
<author>M Kahl</author>
<author>D Saha</author>
<author>M Mezini</author>
<author>K Ostermann</author>
</authors>
<title>Automatic incrementalization of prolog based static analyses.</title>
<date>2007</date>
<booktitle>In Proceedings of the 9th International Symposium on Practical Aspects of Declarative Languages (PADL),</booktitle>
<pages>109--123</pages>
<contexts>
<context position="13684" citStr="[8]" startWordPosition="2192" endWordPosition="2192">ration The trend is now to integrate querying tools into IDEs, e.g. [13, 7, 17, 31]. Queries are run in an interactive setting where the codebase changes frequently. To illustrate, one may run a query to spot a refactoring opportunity, apply the refactoring, run another query, and so on. Also, lightweight static checks should be performed after each change, however minor it is. These querying scenarios present two challenges. First, the model representing the codebase has to be synchronized with the source code. Second, queries need to be rerun quickly and seamlessly, i.e. incrementally as in [8]. Code queries for other tasks Code queries have been proposed to navigate and visualize software systems. They have been used for the flexible definitions of code metrics, e.g. [23, 5]. They can also express complex custom code analyses to enforce project-specific design choice and coding conventions. We believe, however, that we have only scratched the surface of potential applications. For instance, code queries have been proposed to discover and document cross-cutting concerns [22]. It would be interesting to exploit further code queries as lightweight contract definitions to enforce docum</context>
</contexts>
<marker>[8]</marker>
<rawString>M. Eichberg, M. Kahl, D. Saha, M. Mezini, and K. Ostermann. Automatic incrementalization of prolog based static analyses. In Proceedings of the 9th International Symposium on Practical Aspects of Declarative Languages (PADL), pages 109–123, 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S G Eick</author>
<author>J L Steffen</author>
<author>E E Sumner</author>
</authors>
<title>SeeSoft—a tool for visualizing line oriented software statistics.</title>
<date>1992</date>
<journal>IEEE Transactions on Software Engineering,</journal>
<volume>18</volume>
<issue>11</issue>
<contexts>
<context position="6319" citStr="[9]" startWordPosition="999" endWordPosition="999">rced by developers [11]. A main concern in reengineering is to bridge the gap between models and source code. Reflexion models address exactly that issue by defining a mapping between the two [18, 27]. There again, mappings can be declared and checked with code queries. 4 Queries and visualization Typically, we need to relate the results of a query to the context in which they live. Thus, visualization can complement queries in at least two ways: • By locating the results in the overall system. For example, Seesoft is a tool for visualizing line oriented software information for several files [9]. Such a visualization offers a map of the whole system on which we can highlight the results of queries. • By providing details about the results so that further analyses can be more efficient. For example, CodeCrawler [19] implements the concept of polymetric views to map metrics and design flaws on source code visualizations [20]. Other tools have been proposed to deal with the above issues. Rigi uses a graph metaphor for displaying software systems [26]. SHriMP provides an interactive environment in which the engineer can navigate the system [32]. NDepend highlights the results of queries </context>
</contexts>
<marker>[9]</marker>
<rawString>S. G. Eick, J. L. Steffen, and E. E. Sumner. SeeSoft—a tool for visualizing line oriented software statistics. IEEE Transactions on Software Engineering, 18(11):957–968, Nov. 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J-M Favre</author>
</authors>
<title>Gsee: a generic software exploration environment.</title>
<date>2001</date>
<booktitle>In Proceedings of the 9th International Workshop on Program Comprehension,</booktitle>
<pages>233--244</pages>
<publisher>IEEE,</publisher>
<contexts>
<context position="7112" citStr="[10]" startWordPosition="1127" endWordPosition="1127">ient. For example, CodeCrawler [19] implements the concept of polymetric views to map metrics and design flaws on source code visualizations [20]. Other tools have been proposed to deal with the above issues. Rigi uses a graph metaphor for displaying software systems [26]. SHriMP provides an interactive environment in which the engineer can navigate the system [32]. NDepend highlights the results of queries on treemaps [28]. Visualization transforms the system models into graphical models, which are typically graphs. Gsee provides a simple interface for specifying the mapping to visualization [10]. Mondrian also offers an engine for scripting such transformations [25]. These approaches aim at reducing the cost of building custom visualization, and as such they can be used for showing the results of custom queries. 5 Query technologies There are many different approaches to querying source code. Perhaps the most natural solution is to store the program in a database. One of the earliest proposals of this kind was Linton’s Omega system [21]; queries were formulated in the Ingres query language QUEL. In the same vein, the C Information Abstraction system [3] showed how to store the code s</context>
</contexts>
<marker>[10]</marker>
<rawString>J.-M. Favre. Gsee: a generic software exploration environment. In Proceedings of the 9th International Workshop on Program Comprehension, pages 233–244. IEEE, May 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Finnigan</author>
<author>R Holt</author>
<author>I Kalas</author>
<author>S Kerr</author>
<author>K Kontogiannis</author>
<author>H Mller</author>
<author>J Mylopoulos</author>
<author>S Perelgut</author>
<author>M Stanley</author>
<author>K Wong</author>
</authors>
<title>The software bookshelf.</title>
<date>1997</date>
<journal>IBM Systems Journal,</journal>
<volume>36</volume>
<issue>4</issue>
<contexts>
<context position="5739" citStr="[11]" startWordPosition="899" endWordPosition="899">whose properties are based on those of their contained elements. For example, one might wish to know if there are any calls from subsystem A to B that do not go through module M (the intended interface for the subsystem). Or one might assign classes to subsystems and then verify that the subsystems form a layered architecture with no calls between modules that violate the layering. The Grok query language has been used together with other tools such as fact extractors, for both reverse engineering of designs from code as well as for ensuring that architectural rules are enforced by developers [11]. A main concern in reengineering is to bridge the gap between models and source code. Reflexion models address exactly that issue by defining a mapping between the two [18, 27]. There again, mappings can be declared and checked with code queries. 4 Queries and visualization Typically, we need to relate the results of a query to the context in which they live. Thus, visualization can complement queries in at least two ways: • By locating the results in the overall system. For example, Seesoft is a tool for visualizing line oriented software information for several files [9]. Such a visualizati</context>
<context position="9532" citStr="[11]" startWordPosition="1527" endWordPosition="1527">et, the learning curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat route of relational algebra, e.g. Grok [11], CrocoPat [1] and RScript [16]. Perhaps the principal benefit of those systems is in efficient algorithms for implementing and optimizing relational operations — for instance, CrocoPat uses BDDs to compactly represent huge relations. Those systems, however, are usually not restricted to declarative queries; most of them embed imperative constructs to allow the extraction and manipulation of facts. Interestingly, there is a language that is purely declarative, rule-based like Prolog, and that can be executed using relational algebra. That is Datalog, a query language originally put forward in </context>
</contexts>
<marker>[11]</marker>
<rawString>P. Finnigan, R. Holt, I. Kalas, S. Kerr, K. Kontogiannis, H. Mller, J. Mylopoulos, S. Perelgut, M. Stanley, and K. Wong. The software bookshelf. IBM Systems Journal, 36(4):564–593, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A E Hassan</author>
<author>A Mockus</author>
<author>R C Holt</author>
<author>P M Johnson</author>
</authors>
<title>Guest editor’s introduction: Special issue on mining software repositories.</title>
<date>2005</date>
<journal>IEEE Transactions on Software Engineering,</journal>
<volume>31</volume>
<issue>6</issue>
<marker>[12]</marker>
<rawString>A. E. Hassan, A. Mockus, R. C. Holt, and P. M. Johnson. Guest editor’s introduction: Special issue on mining software repositories. IEEE Transactions on Software Engineering, 31(6):426–428, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Janzen</author>
<author>K de Volder</author>
</authors>
<title>Navigating and querying code without getting lost.</title>
<date>2003</date>
<booktitle>In 2nd International Conference on Aspect-Oriented Software Development (AOSD),</booktitle>
<pages>178--187</pages>
<contexts>
<context position="8903" citStr="[13]" startWordPosition="1421" endWordPosition="1421">uages, however, are quite verbose and less declarative for expressing recursive queries on the complex graph representation of a program. A typical example of such recursive queries is to search, while cleaning up a piece of legacy software, for methods that are never called directly or indirectly from main methods. Logic programming languages are much better suited for those tasks. The XL C++ Browser [15] was one of the first to promote Prolog for expressing typical queries over source code. More recently, logic programming in the tradition of Prolog has inspired tools like Soul [24], JQuery [13] and JTransformer [17]. Yet, the learning curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat route of relat</context>
<context position="13164" citStr="[13, 7, 17, 31]" startWordPosition="2106" endWordPosition="2109"> performance can be achieved on medium-sized projects by fitting the whole codebase in memory. Another example is when querying for the transitive closure of a large call graph. The resulting relation is often too huge to be materialized on disk in reasonable time, whereas it could be compressed in a BDD as in [1]. Although query languages like PQL [14] and .QL [5] were designed so as to separate the language from its implementation details, there has been little work so far on mixing different evaluation strategies. IDE integration The trend is now to integrate querying tools into IDEs, e.g. [13, 7, 17, 31]. Queries are run in an interactive setting where the codebase changes frequently. To illustrate, one may run a query to spot a refactoring opportunity, apply the refactoring, run another query, and so on. Also, lightweight static checks should be performed after each change, however minor it is. These querying scenarios present two challenges. First, the model representing the codebase has to be synchronized with the source code. Second, queries need to be rerun quickly and seamlessly, i.e. incrementally as in [8]. Code queries for other tasks Code queries have been proposed to navigate and v</context>
</contexts>
<marker>[13]</marker>
<rawString>D. Janzen and K. de Volder. Navigating and querying code without getting lost. In 2nd International Conference on Aspect-Oriented Software Development (AOSD), pages 178–187, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Jarzabek</author>
</authors>
<title>Design of flexible static program analyzers with PQL.</title>
<date>1998</date>
<journal>IEEE Transactions on Software Engineering,</journal>
<volume>24</volume>
<issue>3</issue>
<contexts>
<context position="9399" citStr="[14]" startWordPosition="1504" endWordPosition="1504">. More recently, logic programming in the tradition of Prolog has inspired tools like Soul [24], JQuery [13] and JTransformer [17]. Yet, the learning curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat route of relational algebra, e.g. Grok [11], CrocoPat [1] and RScript [16]. Perhaps the principal benefit of those systems is in efficient algorithms for implementing and optimizing relational operations — for instance, CrocoPat uses BDDs to compactly represent huge relations. Those systems, however, are usually not restricted to declarative queries; most of them embed imperative constructs to allow the extraction and manipulation of facts. Interestingly, there is a language that is purely declarative, ru</context>
<context position="12904" citStr="[14]" startWordPosition="2065" endWordPosition="2065">l-purpose query language? Mixing implementation strategies Here again, certain implementation strategies are better suited to certain contexts and tasks. For instance, using a database is crucial when querying very large systems, but slightly better performance can be achieved on medium-sized projects by fitting the whole codebase in memory. Another example is when querying for the transitive closure of a large call graph. The resulting relation is often too huge to be materialized on disk in reasonable time, whereas it could be compressed in a BDD as in [1]. Although query languages like PQL [14] and .QL [5] were designed so as to separate the language from its implementation details, there has been little work so far on mixing different evaluation strategies. IDE integration The trend is now to integrate querying tools into IDEs, e.g. [13, 7, 17, 31]. Queries are run in an interactive setting where the codebase changes frequently. To illustrate, one may run a query to spot a refactoring opportunity, apply the refactoring, run another query, and so on. Also, lightweight static checks should be performed after each change, however minor it is. These querying scenarios present two chall</context>
</contexts>
<marker>[14]</marker>
<rawString>S. Jarzabek. Design of flexible static program analyzers with PQL. IEEE Transactions on Software Engineering, 24(3):197–215, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Javey</author>
<author>K Mitsui</author>
<author>H Nakamura</author>
<author>T Ohira</author>
<author>K Yasuda</author>
<author>K Kuse</author>
<author>T Kamimura</author>
<author>R Helm</author>
</authors>
<title>Architecture of the XL C++ browser.</title>
<date>1992</date>
<booktitle>In Proceedings of the 1992 conference of the Centre for Advanced Studies on Collaborative research (CASCON),</booktitle>
<pages>369--379</pages>
<contexts>
<context position="8708" citStr="[15]" startWordPosition="1389" endWordPosition="1389">n Sextant [7] for instance, software engineering tasks are expressed with XQuery. Of course, the clear advantage of XQuery and SQL is that they are already familiar to most programmers. Both languages, however, are quite verbose and less declarative for expressing recursive queries on the complex graph representation of a program. A typical example of such recursive queries is to search, while cleaning up a piece of legacy software, for methods that are never called directly or indirectly from main methods. Logic programming languages are much better suited for those tasks. The XL C++ Browser [15] was one of the first to promote Prolog for expressing typical queries over source code. More recently, logic programming in the tradition of Prolog has inspired tools like Soul [24], JQuery [13] and JTransformer [17]. Yet, the learning curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further exam</context>
</contexts>
<marker>[15]</marker>
<rawString>S. Javey, K. Mitsui, H. Nakamura, T. Ohira, K. Yasuda, K. Kuse, T. Kamimura, and R. Helm. Architecture of the XL C++ browser. In Proceedings of the 1992 conference of the Centre for Advanced Studies on Collaborative research (CASCON), pages 369–379, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Klint</author>
</authors>
<title>A tutorial introduction to RScript. Centrum voor Wiskunde en Informatica,</title>
<date>2005</date>
<location>draft,</location>
<contexts>
<context position="9563" citStr="[16]" startWordPosition="1532" endWordPosition="1532">g is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat route of relational algebra, e.g. Grok [11], CrocoPat [1] and RScript [16]. Perhaps the principal benefit of those systems is in efficient algorithms for implementing and optimizing relational operations — for instance, CrocoPat uses BDDs to compactly represent huge relations. Those systems, however, are usually not restricted to declarative queries; most of them embed imperative constructs to allow the extraction and manipulation of facts. Interestingly, there is a language that is purely declarative, rule-based like Prolog, and that can be executed using relational algebra. That is Datalog, a query language originally put forward in the context of deductive databa</context>
</contexts>
<marker>[16]</marker>
<rawString>P. Klint. A tutorial introduction to RScript. Centrum voor Wiskunde en Informatica, draft, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Kniesel</author>
<author>J Hannemann</author>
<author>T Rho</author>
</authors>
<title>A comparison of logic-based infrastructures for concern detection and extraction.</title>
<date>2007</date>
<booktitle>In Proceedings of the 3rd workshop on Linking aspect technology and evolution (LATE),</booktitle>
<pages>6</pages>
<publisher>ACM,</publisher>
<contexts>
<context position="8925" citStr="[17]" startWordPosition="1424" endWordPosition="1424">ite verbose and less declarative for expressing recursive queries on the complex graph representation of a program. A typical example of such recursive queries is to search, while cleaning up a piece of legacy software, for methods that are never called directly or indirectly from main methods. Logic programming languages are much better suited for those tasks. The XL C++ Browser [15] was one of the first to promote Prolog for expressing typical queries over source code. More recently, logic programming in the tradition of Prolog has inspired tools like Soul [24], JQuery [13] and JTransformer [17]. Yet, the learning curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat route of relational algebra, e.g. Gr</context>
<context position="13164" citStr="[13, 7, 17, 31]" startWordPosition="2106" endWordPosition="2109"> performance can be achieved on medium-sized projects by fitting the whole codebase in memory. Another example is when querying for the transitive closure of a large call graph. The resulting relation is often too huge to be materialized on disk in reasonable time, whereas it could be compressed in a BDD as in [1]. Although query languages like PQL [14] and .QL [5] were designed so as to separate the language from its implementation details, there has been little work so far on mixing different evaluation strategies. IDE integration The trend is now to integrate querying tools into IDEs, e.g. [13, 7, 17, 31]. Queries are run in an interactive setting where the codebase changes frequently. To illustrate, one may run a query to spot a refactoring opportunity, apply the refactoring, run another query, and so on. Also, lightweight static checks should be performed after each change, however minor it is. These querying scenarios present two challenges. First, the model representing the codebase has to be synchronized with the source code. Second, queries need to be rerun quickly and seamlessly, i.e. incrementally as in [8]. Code queries for other tasks Code queries have been proposed to navigate and v</context>
</contexts>
<marker>[17]</marker>
<rawString>G. Kniesel, J. Hannemann, and T. Rho. A comparison of logic-based infrastructures for concern detection and extraction. In Proceedings of the 3rd workshop on Linking aspect technology and evolution (LATE), page 6. ACM, 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Koschke</author>
<author>D Simon</author>
</authors>
<title>Hierarchical reflexion models.</title>
<date>2003</date>
<booktitle>In Proceedings of the 10th Working Conference on Reverse Engineering (WCRE),</booktitle>
<pages>36</pages>
<publisher>IEEE Computer Society,</publisher>
<contexts>
<context position="5916" citStr="[18, 27]" startWordPosition="929" endWordPosition="930">le M (the intended interface for the subsystem). Or one might assign classes to subsystems and then verify that the subsystems form a layered architecture with no calls between modules that violate the layering. The Grok query language has been used together with other tools such as fact extractors, for both reverse engineering of designs from code as well as for ensuring that architectural rules are enforced by developers [11]. A main concern in reengineering is to bridge the gap between models and source code. Reflexion models address exactly that issue by defining a mapping between the two [18, 27]. There again, mappings can be declared and checked with code queries. 4 Queries and visualization Typically, we need to relate the results of a query to the context in which they live. Thus, visualization can complement queries in at least two ways: • By locating the results in the overall system. For example, Seesoft is a tool for visualizing line oriented software information for several files [9]. Such a visualization offers a map of the whole system on which we can highlight the results of queries. • By providing details about the results so that further analyses can be more efficient. Fo</context>
</contexts>
<marker>[18]</marker>
<rawString>R. Koschke and D. Simon. Hierarchical reflexion models. In Proceedings of the 10th Working Conference on Reverse Engineering (WCRE), page 36. IEEE Computer Society, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Lanza</author>
<author>S Ducasse</author>
</authors>
<title>CodeCrawler–an extensible and language independent 2d and 3d software visualization tool.</title>
<date>2005</date>
<booktitle>In Tools for Software Maintenance and Reengineering, RCOST / Software Technology Series,</booktitle>
<pages>74--94</pages>
<location>Franco Angeli, Milano,</location>
<contexts>
<context position="6543" citStr="[19]" startWordPosition="1039" endWordPosition="1039"> can be declared and checked with code queries. 4 Queries and visualization Typically, we need to relate the results of a query to the context in which they live. Thus, visualization can complement queries in at least two ways: • By locating the results in the overall system. For example, Seesoft is a tool for visualizing line oriented software information for several files [9]. Such a visualization offers a map of the whole system on which we can highlight the results of queries. • By providing details about the results so that further analyses can be more efficient. For example, CodeCrawler [19] implements the concept of polymetric views to map metrics and design flaws on source code visualizations [20]. Other tools have been proposed to deal with the above issues. Rigi uses a graph metaphor for displaying software systems [26]. SHriMP provides an interactive environment in which the engineer can navigate the system [32]. NDepend highlights the results of queries on treemaps [28]. Visualization transforms the system models into graphical models, which are typically graphs. Gsee provides a simple interface for specifying the mapping to visualization [10]. Mondrian also offers an engin</context>
</contexts>
<marker>[19]</marker>
<rawString>M. Lanza and S. Ducasse. CodeCrawler–an extensible and language independent 2d and 3d software visualization tool. In Tools for Software Maintenance and Reengineering, RCOST / Software Technology Series, pages 74–94. Franco Angeli, Milano, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Lanza</author>
<author>R Marinescu</author>
</authors>
<title>Object-Oriented Metrics in Practice.</title>
<date>2006</date>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="3218" citStr="[20]" startWordPosition="490" endWordPosition="490">use of queries in two major areas of software engineering: quality assurance and reengineering. Then, we highlight the important role of queries in software visualization, and present different code query technologies. Finally, we discuss some challenges around code queries to foster the initial discussion of the session. 2 Queries for quality assurance Software quality can be assessed and improved by computing metrics, finding common bugs, checking style rules and enforcing coding conventions that are specific to an API. A wealth of different metrics have been proposed to detect design flaws [20]. Metrics values are usually presented in isolation or grouped to measure a particular design aspect, but design problems are difficult to spot from a large set of abnormal values. By allowing metrics results to be filtered and tuned to the specificities of a system, queries can help developers and architects pin down the real cause of design flaws [23]. More and more development teams now run static program analyzers on a daily basis to check for common bugs. When expressed as queries, these checks can easily be tuned per project to reduce the number of false positives. Perhaps where the grea</context>
<context position="6653" citStr="[20]" startWordPosition="1056" endWordPosition="1056">esults of a query to the context in which they live. Thus, visualization can complement queries in at least two ways: • By locating the results in the overall system. For example, Seesoft is a tool for visualizing line oriented software information for several files [9]. Such a visualization offers a map of the whole system on which we can highlight the results of queries. • By providing details about the results so that further analyses can be more efficient. For example, CodeCrawler [19] implements the concept of polymetric views to map metrics and design flaws on source code visualizations [20]. Other tools have been proposed to deal with the above issues. Rigi uses a graph metaphor for displaying software systems [26]. SHriMP provides an interactive environment in which the engineer can navigate the system [32]. NDepend highlights the results of queries on treemaps [28]. Visualization transforms the system models into graphical models, which are typically graphs. Gsee provides a simple interface for specifying the mapping to visualization [10]. Mondrian also offers an engine for scripting such transformations [25]. These approaches aim at reducing the cost of building custom visual</context>
</contexts>
<marker>[20]</marker>
<rawString>M. Lanza and R. Marinescu. Object-Oriented Metrics in Practice. Springer-Verlag, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M A Linton</author>
</authors>
<title>Implementing relational views of programs.</title>
<date>1984</date>
<booktitle>Software Development Environments (SDE),</booktitle>
<pages>132--140</pages>
<editor>In P. B. Henderson, editor,</editor>
<contexts>
<context position="7562" citStr="[21]" startWordPosition="1201" endWordPosition="1201">rms the system models into graphical models, which are typically graphs. Gsee provides a simple interface for specifying the mapping to visualization [10]. Mondrian also offers an engine for scripting such transformations [25]. These approaches aim at reducing the cost of building custom visualization, and as such they can be used for showing the results of custom queries. 5 Query technologies There are many different approaches to querying source code. Perhaps the most natural solution is to store the program in a database. One of the earliest proposals of this kind was Linton’s Omega system [21]; queries were formulated in the Ingres query language QUEL. In the same vein, the C Information Abstraction system [3] showed how to store the code structure of a system into a database for generating graphical views, extracting subsystems, and eliminating dead code. These systems have had quite an impact on industrial practice, as numerous companies now use a database system as a code repository, e.g. [2, 31]. Another natural possibility, given the tree structure of source code, is to employ an XML representation of the source code. In Sextant [7] for instance, software engineering tasks are</context>
</contexts>
<marker>[21]</marker>
<rawString>M. A. Linton. Implementing relational views of programs. In P. B. Henderson, editor, Software Development Environments (SDE), pages 132–140, 1984.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Moonen M Marin</author>
<author>A van Deursen</author>
</authors>
<title>SoQueT: Querybased documentation of crosscutting concerns.</title>
<date>2007</date>
<booktitle>In Proceedings of the 29th international conference on Software engineering (ICSE),</booktitle>
<pages>758--761</pages>
<publisher>IEEE Computer Society,</publisher>
<contexts>
<context position="14174" citStr="[22]" startWordPosition="2266" endWordPosition="2266">onized with the source code. Second, queries need to be rerun quickly and seamlessly, i.e. incrementally as in [8]. Code queries for other tasks Code queries have been proposed to navigate and visualize software systems. They have been used for the flexible definitions of code metrics, e.g. [23, 5]. They can also express complex custom code analyses to enforce project-specific design choice and coding conventions. We believe, however, that we have only scratched the surface of potential applications. For instance, code queries have been proposed to discover and document cross-cutting concerns [22]. It would be interesting to exploit further code queries as lightweight contract definitions to enforce documentation. Querying all development artifacts Queries should not be limited to source code, but run on all other development artifacts: bug reports, version histories, documentation. Exciting work on mining software archives has shown how queries in such a broader context often reveal hidden but crucial information about the past, present and future of a project and its development team [12]. Surely, this work 3 shall benefit from more accurate, more semantic queries that code querying </context>
</contexts>
<marker>[22]</marker>
<rawString>M.Marin, L. Moonen, and A. van Deursen. SoQueT: Querybased documentation of crosscutting concerns. In Proceedings of the 29th international conference on Software engineering (ICSE), pages 758–761. IEEE Computer Society, 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Marinescu</author>
</authors>
<title>Detection strategies: Metrics-based rules for detecting design flaws.</title>
<date>2004</date>
<booktitle>In 20th IEEE International Conference on Software Maintenance (ICSM),</booktitle>
<pages>350--359</pages>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="3573" citStr="[23]" startWordPosition="550" endWordPosition="550"> Software quality can be assessed and improved by computing metrics, finding common bugs, checking style rules and enforcing coding conventions that are specific to an API. A wealth of different metrics have been proposed to detect design flaws [20]. Metrics values are usually presented in isolation or grouped to measure a particular design aspect, but design problems are difficult to spot from a large set of abnormal values. By allowing metrics results to be filtered and tuned to the specificities of a system, queries can help developers and architects pin down the real cause of design flaws [23]. More and more development teams now run static program analyzers on a daily basis to check for common bugs. When expressed as queries, these checks can easily be tuned per project to reduce the number of false positives. Perhaps where the greatest benefit lies, however, is in frameworkspecific checks. Indeed, modern systems rely on an ever growing number of frameworks. Queries allow the expression of concise, executable rules that client code of an API must follow [5]. 1 Naturally, quality checks can be performed on different versions of the same system, to monitor its development. Queries a</context>
<context position="13869" citStr="[23, 5]" startWordPosition="2221" endWordPosition="2222">one may run a query to spot a refactoring opportunity, apply the refactoring, run another query, and so on. Also, lightweight static checks should be performed after each change, however minor it is. These querying scenarios present two challenges. First, the model representing the codebase has to be synchronized with the source code. Second, queries need to be rerun quickly and seamlessly, i.e. incrementally as in [8]. Code queries for other tasks Code queries have been proposed to navigate and visualize software systems. They have been used for the flexible definitions of code metrics, e.g. [23, 5]. They can also express complex custom code analyses to enforce project-specific design choice and coding conventions. We believe, however, that we have only scratched the surface of potential applications. For instance, code queries have been proposed to discover and document cross-cutting concerns [22]. It would be interesting to exploit further code queries as lightweight contract definitions to enforce documentation. Querying all development artifacts Queries should not be limited to source code, but run on all other development artifacts: bug reports, version histories, documentation. Exc</context>
</contexts>
<marker>[23]</marker>
<rawString>R. Marinescu. Detection strategies: Metrics-based rules for detecting design flaws. In 20th IEEE International Conference on Software Maintenance (ICSM), pages 350–359. IEEE Computer Society Press, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Mens</author>
<author>A Kellens</author>
<author>F Pluquet</author>
<author>R Wuyts</author>
</authors>
<title>Co-evolving code and design with intensional views — a case study.</title>
<date>2006</date>
<journal>Journal of Computer Languages, Systems and Structures,</journal>
<volume>32</volume>
<issue>2</issue>
<contexts>
<context position="4330" citStr="[24]" startWordPosition="677" endWordPosition="677"> easily be tuned per project to reduce the number of false positives. Perhaps where the greatest benefit lies, however, is in frameworkspecific checks. Indeed, modern systems rely on an ever growing number of frameworks. Queries allow the expression of concise, executable rules that client code of an API must follow [5]. 1 Naturally, quality checks can be performed on different versions of the same system, to monitor its development. Queries are helpful for that purpose too. In particular, they can be used to check that no design inconsistencies are introduced during the evolution of a system [24]. 3 Queries for reengineering Not only can queries detect violations of certain design principles, but they also play an important role in driving development and performing design recovery. The canonical use of querying for such tasks involves several steps. First, the source code is run through a fact extractor, which creates a somewhat higher level model of the source code entities and their interdependencies than the code itself. Entities are commonly at the level of files, classes, functions/methods, global and instance variables, while relationships include file inclusion, calls, variabl</context>
<context position="8890" citStr="[24]" startWordPosition="1419" endWordPosition="1419">rs. Both languages, however, are quite verbose and less declarative for expressing recursive queries on the complex graph representation of a program. A typical example of such recursive queries is to search, while cleaning up a piece of legacy software, for methods that are never called directly or indirectly from main methods. Logic programming languages are much better suited for those tasks. The XL C++ Browser [15] was one of the first to promote Prolog for expressing typical queries over source code. More recently, logic programming in the tradition of Prolog has inspired tools like Soul [24], JQuery [13] and JTransformer [17]. Yet, the learning curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat r</context>
</contexts>
<marker>[24]</marker>
<rawString>K. Mens, A. Kellens, F. Pluquet, and R. Wuyts. Co-evolving code and design with intensional views — a case study. Journal of Computer Languages, Systems and Structures, 32(2):140–156, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Meyer</author>
<author>T Gırba</author>
<author>M Lungu</author>
</authors>
<title>Mondrian: An agile visualization framework.</title>
<date>2006</date>
<booktitle>In ACM Symposium on Software Visualization (SoftVis),</booktitle>
<pages>135--144</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="7184" citStr="[25]" startWordPosition="1137" endWordPosition="1137"> views to map metrics and design flaws on source code visualizations [20]. Other tools have been proposed to deal with the above issues. Rigi uses a graph metaphor for displaying software systems [26]. SHriMP provides an interactive environment in which the engineer can navigate the system [32]. NDepend highlights the results of queries on treemaps [28]. Visualization transforms the system models into graphical models, which are typically graphs. Gsee provides a simple interface for specifying the mapping to visualization [10]. Mondrian also offers an engine for scripting such transformations [25]. These approaches aim at reducing the cost of building custom visualization, and as such they can be used for showing the results of custom queries. 5 Query technologies There are many different approaches to querying source code. Perhaps the most natural solution is to store the program in a database. One of the earliest proposals of this kind was Linton’s Omega system [21]; queries were formulated in the Ingres query language QUEL. In the same vein, the C Information Abstraction system [3] showed how to store the code structure of a system into a database for generating graphical views, ext</context>
</contexts>
<marker>[25]</marker>
<rawString>M. Meyer, T. Gı̂rba, and M. Lungu. Mondrian: An agile visualization framework. In ACM Symposium on Software Visualization (SoftVis), pages 135–144. ACM Press, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H A Muller</author>
<author>K Klashinsky</author>
</authors>
<title>Rigi — a system for programming-in-the-large.</title>
<date>1988</date>
<booktitle>In Proceedings of the 10th international conference on Software engineering (ICSE),</booktitle>
<pages>80--86</pages>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="6780" citStr="[26]" startWordPosition="1077" endWordPosition="1077">ting the results in the overall system. For example, Seesoft is a tool for visualizing line oriented software information for several files [9]. Such a visualization offers a map of the whole system on which we can highlight the results of queries. • By providing details about the results so that further analyses can be more efficient. For example, CodeCrawler [19] implements the concept of polymetric views to map metrics and design flaws on source code visualizations [20]. Other tools have been proposed to deal with the above issues. Rigi uses a graph metaphor for displaying software systems [26]. SHriMP provides an interactive environment in which the engineer can navigate the system [32]. NDepend highlights the results of queries on treemaps [28]. Visualization transforms the system models into graphical models, which are typically graphs. Gsee provides a simple interface for specifying the mapping to visualization [10]. Mondrian also offers an engine for scripting such transformations [25]. These approaches aim at reducing the cost of building custom visualization, and as such they can be used for showing the results of custom queries. 5 Query technologies There are many different </context>
</contexts>
<marker>[26]</marker>
<rawString>H. A. Müller and K. Klashinsky. Rigi — a system for programming-in-the-large. In Proceedings of the 10th international conference on Software engineering (ICSE), pages 80–86. IEEE Computer Society Press, 1988.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Murphy</author>
<author>D Notkin</author>
<author>K Sullivan</author>
</authors>
<title>Software reflexion models: Bridging the gap between source and high-level models.</title>
<date>1995</date>
<booktitle>In Proceedings of the 3rd ACM SIGSOFT Symposium on the Foundations of Software Engineering,</booktitle>
<pages>18--28</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="5916" citStr="[18, 27]" startWordPosition="929" endWordPosition="930">le M (the intended interface for the subsystem). Or one might assign classes to subsystems and then verify that the subsystems form a layered architecture with no calls between modules that violate the layering. The Grok query language has been used together with other tools such as fact extractors, for both reverse engineering of designs from code as well as for ensuring that architectural rules are enforced by developers [11]. A main concern in reengineering is to bridge the gap between models and source code. Reflexion models address exactly that issue by defining a mapping between the two [18, 27]. There again, mappings can be declared and checked with code queries. 4 Queries and visualization Typically, we need to relate the results of a query to the context in which they live. Thus, visualization can complement queries in at least two ways: • By locating the results in the overall system. For example, Seesoft is a tool for visualizing line oriented software information for several files [9]. Such a visualization offers a map of the whole system on which we can highlight the results of queries. • By providing details about the results so that further analyses can be more efficient. Fo</context>
</contexts>
<marker>[27]</marker>
<rawString>G. Murphy, D. Notkin, and K. Sullivan. Software reflexion models: Bridging the gap between source and high-level models. In Proceedings of the 3rd ACM SIGSOFT Symposium on the Foundations of Software Engineering, pages 18– 28. ACM Press, 1995.</rawString>
</citation>
<citation valid="false">
<authors>
<author>NDepend</author>
</authors>
<note>Company website at: http://www.ndepend. com.</note>
<contexts>
<context position="6935" citStr="[28]" startWordPosition="1101" endWordPosition="1101">ualization offers a map of the whole system on which we can highlight the results of queries. • By providing details about the results so that further analyses can be more efficient. For example, CodeCrawler [19] implements the concept of polymetric views to map metrics and design flaws on source code visualizations [20]. Other tools have been proposed to deal with the above issues. Rigi uses a graph metaphor for displaying software systems [26]. SHriMP provides an interactive environment in which the engineer can navigate the system [32]. NDepend highlights the results of queries on treemaps [28]. Visualization transforms the system models into graphical models, which are typically graphs. Gsee provides a simple interface for specifying the mapping to visualization [10]. Mondrian also offers an engine for scripting such transformations [25]. These approaches aim at reducing the cost of building custom visualization, and as such they can be used for showing the results of custom queries. 5 Query technologies There are many different approaches to querying source code. Perhaps the most natural solution is to store the program in a database. One of the earliest proposals of this kind was</context>
</contexts>
<marker>[28]</marker>
<rawString>NDepend. Company website at: http://www.ndepend. com.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Paul</author>
<author>A Prakash</author>
</authors>
<title>A framework for source code search using program patterns.</title>
<date>1994</date>
<journal>IEEE Trans. Softw. Eng.,</journal>
<volume>20</volume>
<issue>6</issue>
<contexts>
<context position="9453" citStr="[29]" startWordPosition="1512" endWordPosition="1512"> Prolog has inspired tools like Soul [24], JQuery [13] and JTransformer [17]. Yet, the learning curve of Prolog is quite long and complex queries are also often verbose. In many systems therefore, a deliberate choice was made to simplify the set of expressible recursive queries. GraphLog [4] is a query language with just enough power to express paths queries on graphs. GReQL [6] is another graph query language, but with a syntax close to SQL. Further examples of domain-specific languages for code search 2 are the program query language PQL [14] or pattern-based languages as enabled by SCRUPLE [29]. A few other systems went the neat route of relational algebra, e.g. Grok [11], CrocoPat [1] and RScript [16]. Perhaps the principal benefit of those systems is in efficient algorithms for implementing and optimizing relational operations — for instance, CrocoPat uses BDDs to compactly represent huge relations. Those systems, however, are usually not restricted to declarative queries; most of them embed imperative constructs to allow the extraction and manipulation of facts. Interestingly, there is a language that is purely declarative, rule-based like Prolog, and that can be executed using r</context>
</contexts>
<marker>[29]</marker>
<rawString>S. Paul and A. Prakash. A framework for source code search using program patterns. IEEE Trans. Softw. Eng., 20(6):463–475, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T W Reps</author>
</authors>
<title>Demand interprocedural program analysis using logic databases.</title>
<date>1993</date>
<booktitle>In Workshop on Programming with Logic Databases (ILPS),</booktitle>
<pages>163--196</pages>
<contexts>
<context position="10254" citStr="[4, 30]" startWordPosition="1637" endWordPosition="1638">ementing and optimizing relational operations — for instance, CrocoPat uses BDDs to compactly represent huge relations. Those systems, however, are usually not restricted to declarative queries; most of them embed imperative constructs to allow the extraction and manipulation of facts. Interestingly, there is a language that is purely declarative, rule-based like Prolog, and that can be executed using relational algebra. That is Datalog, a query language originally put forward in the context of deductive databases. Datalog has been proposed at various occasions for analyzing source code, e.g. [4, 30]. It has a simple semantics and can be executed efficiently on top of a traditional relational database. This is the technique used in SemmleCode [31] where queries are written in .QL [5], an object-oriented query language with a syntax familiar to SQL and OO developers. For their execution, .QL queries are translated to a variant of Datalog, optimized and further compiled to SQL. 6 Open questions and challenges Although code queries have been long and well studied (our brief survey above is far from being exhaustive), there still remain open questions and ongoing research challenges. We state</context>
</contexts>
<marker>[30]</marker>
<rawString>T. W. Reps. Demand interprocedural program analysis using logic databases. In Workshop on Programming with Logic Databases (ILPS), pages 163–196, 1993.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Semmle Limited</author>
</authors>
<title>Company website at:</title>
<note>http://semmle. com.</note>
<contexts>
<context position="7976" citStr="[2, 31]" startWordPosition="1270" endWordPosition="1271"> different approaches to querying source code. Perhaps the most natural solution is to store the program in a database. One of the earliest proposals of this kind was Linton’s Omega system [21]; queries were formulated in the Ingres query language QUEL. In the same vein, the C Information Abstraction system [3] showed how to store the code structure of a system into a database for generating graphical views, extracting subsystems, and eliminating dead code. These systems have had quite an impact on industrial practice, as numerous companies now use a database system as a code repository, e.g. [2, 31]. Another natural possibility, given the tree structure of source code, is to employ an XML representation of the source code. In Sextant [7] for instance, software engineering tasks are expressed with XQuery. Of course, the clear advantage of XQuery and SQL is that they are already familiar to most programmers. Both languages, however, are quite verbose and less declarative for expressing recursive queries on the complex graph representation of a program. A typical example of such recursive queries is to search, while cleaning up a piece of legacy software, for methods that are never called d</context>
<context position="10404" citStr="[31]" startWordPosition="1664" endWordPosition="1664">ly not restricted to declarative queries; most of them embed imperative constructs to allow the extraction and manipulation of facts. Interestingly, there is a language that is purely declarative, rule-based like Prolog, and that can be executed using relational algebra. That is Datalog, a query language originally put forward in the context of deductive databases. Datalog has been proposed at various occasions for analyzing source code, e.g. [4, 30]. It has a simple semantics and can be executed efficiently on top of a traditional relational database. This is the technique used in SemmleCode [31] where queries are written in .QL [5], an object-oriented query language with a syntax familiar to SQL and OO developers. For their execution, .QL queries are translated to a variant of Datalog, optimized and further compiled to SQL. 6 Open questions and challenges Although code queries have been long and well studied (our brief survey above is far from being exhaustive), there still remain open questions and ongoing research challenges. We state here a few problems which we believe deserve clearer answers. Heterogeneous models It appears now that there is no silver-bullet model for all applic</context>
<context position="13164" citStr="[13, 7, 17, 31]" startWordPosition="2106" endWordPosition="2109"> performance can be achieved on medium-sized projects by fitting the whole codebase in memory. Another example is when querying for the transitive closure of a large call graph. The resulting relation is often too huge to be materialized on disk in reasonable time, whereas it could be compressed in a BDD as in [1]. Although query languages like PQL [14] and .QL [5] were designed so as to separate the language from its implementation details, there has been little work so far on mixing different evaluation strategies. IDE integration The trend is now to integrate querying tools into IDEs, e.g. [13, 7, 17, 31]. Queries are run in an interactive setting where the codebase changes frequently. To illustrate, one may run a query to spot a refactoring opportunity, apply the refactoring, run another query, and so on. Also, lightweight static checks should be performed after each change, however minor it is. These querying scenarios present two challenges. First, the model representing the codebase has to be synchronized with the source code. Second, queries need to be rerun quickly and seamlessly, i.e. incrementally as in [8]. Code queries for other tasks Code queries have been proposed to navigate and v</context>
</contexts>
<marker>[31]</marker>
<rawString>Semmle Limited. Company website at: http://semmle. com.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M-A D Storey</author>
<author>H A Muller</author>
</authors>
<title>Manipulating and documenting software structures using SHriMP Views.</title>
<date>1995</date>
<booktitle>In Proceedings of the International Conference on Software Maintenance (ICSM),</booktitle>
<pages>275--284</pages>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="6875" citStr="[32]" startWordPosition="1091" endWordPosition="1091">ented software information for several files [9]. Such a visualization offers a map of the whole system on which we can highlight the results of queries. • By providing details about the results so that further analyses can be more efficient. For example, CodeCrawler [19] implements the concept of polymetric views to map metrics and design flaws on source code visualizations [20]. Other tools have been proposed to deal with the above issues. Rigi uses a graph metaphor for displaying software systems [26]. SHriMP provides an interactive environment in which the engineer can navigate the system [32]. NDepend highlights the results of queries on treemaps [28]. Visualization transforms the system models into graphical models, which are typically graphs. Gsee provides a simple interface for specifying the mapping to visualization [10]. Mondrian also offers an engine for scripting such transformations [25]. These approaches aim at reducing the cost of building custom visualization, and as such they can be used for showing the results of custom queries. 5 Query technologies There are many different approaches to querying source code. Perhaps the most natural solution is to store the program i</context>
</contexts>
<marker>[32]</marker>
<rawString>M.-A. D. Storey and H. A. Müller. Manipulating and documenting software structures using SHriMP Views. In Proceedings of the International Conference on Software Maintenance (ICSM), pages 275–284. IEEE Computer Society Press, 1995.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>