<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.001205">
<table confidence="0.440205545454545">
International Workshop on Meta-Models and Schemas for Reverse Engineering, (ATEM 2004)
Using Meta-Model Transformation to Model
Software Evolution
Tudor Gı̂rba 2,4
Software Composition Group
University of Bern, Switzerland
Jean-Marie Favre 3
LSR-IMAG Laboratory
University of Grenoble, France
Stéphane Ducasse 1,4
Software Composition Group
</table>
<affiliation confidence="0.975151">
University of Bern, Switzerland
</affiliation>
<sectionHeader confidence="0.972216" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.997876">
Understanding how software systems evolve is useful from different perspectives:
reverse engineering, empirical studies etc.. For an effective understanding we need
an explicit meta-model. We introduce Hismo, a meta-model which is centered
around the notion of history and we show how we can obtain it from a snapshot
meta-model. Based on our experience in developing the Hismo reverse engineering
system, we show how we can transform a snapshot meta-model in a history meta-
model.
Key words: reverse engineering, software evolution, software
history, model driven engineering, MDA, metamodel
</bodyText>
<sectionHeader confidence="0.98393975" genericHeader="method">
1 Email: ducasse@iam.unibe.ch
2 Email: girba@iam.unibe.ch
3 Email: jean-marie.favre@imag.fr
4 Ducasse and Gı̂rba gratefully acknowledge the financial support of the Swiss National
</sectionHeader>
<bodyText confidence="0.923885">
Science Foundation for the projects “Tools and Techniques for Decomposing and Composing
Software” (SNF Project No. 2000-067855.02, Oct. 2002 - Sept. 2004) and “RECAST:
Evolution of Object-Oriented Applications” (SNF Project No. 620-066077, Sept. 2002 -
Aug. 2006).
Preprint submitted to Elsevier Preprint 17 April 2005
</bodyText>
<sectionHeader confidence="0.997811" genericHeader="method">
1 Introduction
</sectionHeader>
<bodyText confidence="0.99967765">
During the 1970’s it became more and more clear that keeping track of soft-
ware evolution was important, at least for very pragmatic purposes such as
undoing last changes. Early versioning systems such as SCCS made it possible
to record the successive versions of software products. This led to text-based
delta algorithms. Some basic services were also added in order to model infor-
mation such as who changed files and why. However only very rudimentary
models were used to represent this information – typically a few unstructured
lines of text to be inserted in a log file.
While versioning systems enabled recording the history of each source file
independently, configuration management systems (CMS) attempted to record
the history of software products as a collection of versioned source files. Re-
search on configuration management was very active in the 80’s and 90’s, but
the emphasis was still on controlling and recording software evolution.
The importance of modeling and analyzing software evolution started to
be recognized in the early 1970’s with the work of Lehman[15]. Yet, it was
only until recent years that extensive research has been spent on exploiting the
wealth of information residing in versioning repositories. While it was possible
to find which specific lines of code were changed between two versions of a
particular file, this led to too much and two detailed information to be really
useful. However, most of the approaches developed so far, do not rely on an
explicit meta model for evolution analysis and do not facilitate the comparison
of different evolutions.
Various approaches have been proposed to analyze different aspects of soft-
ware evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches
typically focuses on only some traits of software evolution (e.g., which parts
are changed the most, what kind of changes happened in a particular part
etc.), and do not rely on explicit meta models. In such conditions, is it is
difficult to understand what the models exactly refer to. The lack of explicit
meta-model makes it difficult to compare and integrate tools even when they
provide similar yet different or complementary results.
The authors have already built the case for an explicit meta-model centered
around the notion of history [6]. The name of the proposed meta-model is
Hismo. We implemented Hismo in a tool called Van which is built on top of
the Moose reengineering environment [7]. We use Hismo for characterizing the
evolution of software and we validated it in a number of occasions for reverse
engineering purposes [9,10,11,16].
In our implementation, Hismo is based on the FAMIX meta-model [5].
However, the concept of history is by no means dependent on FAMIX and
the approach can be applied to other meta-models as well. In other words
from a conceptual view Hismo could be seen as a meta-model transformation
</bodyText>
<page confidence="0.980969">
2
</page>
<bodyText confidence="0.995836333333333">
transforming a snapshot meta-model into an history meta-model. This paper
investigates this idea by considering the problem of evolution analysis from a
Model Driven (Reverse) Engineering perspective.
In the next section we briefly present the concepts in Hismo, in Section 3 we
describe the transformation needed for obtaining Hismo and before concluding,
we discuss our approach.
</bodyText>
<figure confidence="0.976706294117647">
2 Hismo in a Nutshell
ClassVersion
/versionId
name
1package
0..1class
PackageHistory
name
versionId
0..1
version
1
history
PackageVersion
name
ClassHistory versionId
0..1
version
1
history
1 /packageHistory
0..1 /classHistory
ver.
1
ver.
2
ver.
3
ver.
1
ver.
2
ver.
3
</figure>
<figureCaption confidence="0.974476">
Fig. 1. The relationship between the history and the versions.
</figureCaption>
<bodyText confidence="0.998866230769231">
The Hismo meta-model is based on the explicit notions of history and
versions. As these concepts are generic, they have to be applied to specific
entities such as packages, classes, methods or any entity related to software
that we want to study and for which having a version makes sense. Figure 1
shows Hismo applied to packages and classes. In the figure we also show
the relation between our meta-model and the Evolution Matrix [14]. In the
lower part of the figure we represent two Evolution Matrixes in which each
cell represents a ClassVersion and each column represents PackageVersions.
We define a history to be a sequence of versions. Thus, each line in the
Evolution Matrix represents a ClassHistory (left matrix). Moreover, the whole
matrix is actually a line formed by PackageVersions (right matrix), which
means that the whole matrix can be seen as a PackageHistory (left matrix).
In the right side of the figure we see the relationship between the version
</bodyText>
<page confidence="0.706506">
3
</page>
<figure confidence="0.979613523809524">
ClassVersion
/versionId
/evolutionOfLOC:
integer
0..1
version
1
history
Class
LOC: integer
model
transformation
ClassHistory
/maxLOC: integer
/minLOC: integer
/evolutionOfLOC: integer
...
versionId
evolutionOfLOC = Sequence {minId+1..maxId}-&amp;gt;collect(i  |self.versions[i]. evolutionOfLOC)-&amp;gt;sum()
evolutionOfLOC =
(prev.value(LOC)-self.value(LOC)).abs()
</figure>
<figureCaption confidence="0.988317">
Fig. 2. Transforming the snapshot entities to obtain history as a collection of
</figureCaption>
<bodyText confidence="0.9582497">
versions and deriving history properties.
entities while in the left side of the figure we show the relationships between
the history counterparts.
From the figure we see there is a parallelism between the version entities
and the history entities. Each version entity has a correspondent history entity.
Also, the relationship at version level (e.g., a Package has many Classes)
has a correspondent at the history level (e.g., a PackageHistory has more
ClassHistories).
Further, we describe how we can generate Hismo based on the snapshot
meta-model.
</bodyText>
<sectionHeader confidence="0.831906" genericHeader="method">
3 Transforming Snapshot Meta-Models into History Meta-
</sectionHeader>
<subsectionHeader confidence="0.588195">
Models
</subsectionHeader>
<bodyText confidence="0.998852470588235">
In this section we discuss the transformation needed for obtaining Hismo start-
ing from a snapshot model like FAMIX or UML.
In Figure 2 we show in details the transformation which generates from
a Class entity in the snapshot meta-model the corresponding ClassHistory-
ClassVersion meta-model. Thus, a ClassHistory is a sequence of ClassVersions.
Also the model allows us to define history properties based on structural prop-
erties.
For example, having the number of lines of code (LOC) as an attribute
in a Class, we can derive the minimum or the maximum lines of code in the
history. In the figure we show how we derive the Evolution of Lines of Code, as
the sum of the absolute differences of the lines of code in subsequent versions.
The history properties obtained in this manner, characterize and summarize
the evolution. Using such measurements can pinpoint the places which were
changed a lot, or places which were hardly changed at all.
Figure 3 shows how we can obtain the relationships between the meta-
model entities starting from the structural relationships. On the left side of
the figure we have a Package containing multiple Classes. After the transfor-
</bodyText>
<figure confidence="0.980990909090909">
4
ClassVersion
/versionId
name
1package
0..1class
PackageHistory
name
versionId
0..1
version
1
history
PackageVersion
name
ClassHistory versionId
0..1
version
1
history
1 /packageHistory
0..1 /classHistory
Class
name
1package
0..1class
Package
name
model
transformation
code
generation
PackageHistory&amp;gt;&amp;gt;classHistories
histories := Dictionary new.
self versions do: [:eachPackageVersion |
eachPackageVersion classes do:[ :eachClass |
history := histories
at: eachClass uniqueName
ifAbsentPut: [ClassHistory new].
history addLast: eachClass
]
]
^histories values.
...
</figure>
<figureCaption confidence="0.949589">
Fig. 3. Obtaining the relationships between history entities by transforming the
snapshot meta-model. The bold portions of the generated code show how the algo-
</figureCaption>
<bodyText confidence="0.97290175">
rithm only depends on the snapshot entities and their relationships.
mation we have the PackageHistory as containing multiple ClassHistories. In
the down-right side of the figure we see the generated code in Smalltalk for
obtaining the ClassHistories starting from a PackageHistory.
</bodyText>
<sectionHeader confidence="0.996917" genericHeader="method">
4 Discussion
</sectionHeader>
<bodyText confidence="0.99733">
Having history as a first class entity encapsulates the evolution of structural
entities. In this paper we showed an example of deriving history properties
(e.g., Evolution of Lines of Code) based on structural properties (e.g., Lines
of Code). History properties characterize the evolution of entities from a
particular point of view. This approach allows one to manipulate time infor-
mation just like structural information. In our example, we have a number
characterizing the number of lines of code in a Class and we have a number
characterizing the evolution of lines of code in a ClassHistory.
The drawback of such properties resides in compressing large quantity
of data into a limited set of properties. Yet, we used history properties
and showed their usefulness in different evolution analyses: characterize how
changes appear in the system[9]; use time to improve the detection of design
</bodyText>
<page confidence="0.965961">
5
</page>
<bodyText confidence="0.999424266666667">
flaws [16]; visualize the evolution of class hierarchies [11]; detect patterns of
change [10].
In Figure 3 we showed an example of how to reach our Smalltalk imple-
mentation for the navigation from PackageHistory to ClassHistory. In the
same way we can generate the code for another language (e.g., Java). Also, in
the example we just talked about Package and Class, but in a similar manner
we could extend the diagram for other entities as well.
For example, in Figure 4 we show an excerpt of Hismo, as implemented
in our tool. The structural meta-model consists of different entities (e.g.,
Method). These entities are wrapped by a Version correspondent (e.g.,Method-
Version) and the Versions are contained in a History (e.g., MethodHistory).
We create Versions as wrappers for StructuralEntities because in a Version
we store the relationship with the History. Thus, we are able to compute
properties for a particular Version in the context of the History. For example,
having a version we can navigate to the previous or the next version.
</bodyText>
<figure confidence="0.988162896551724">
Abstract
Entity
Class Method
Attribute Access
Snaphot
Entity
Inheritance ...
0..11 Version * 1
Class
History
Method
History
Attribute
History
Access
History
Inheritance
History ...
Class
Version
Method
Version
Attribute
Version
Access
Version
Inheritance
Version ...
History versionId
</figure>
<figureCaption confidence="0.831485666666667">
Fig. 4. An excerpt of Hismo and its relation with a source code meta-model. We
did not represent all the inheritance relationships to not affect the readability of
the picture.
</figureCaption>
<sectionHeader confidence="0.998601" genericHeader="conclusions">
5 Conclusions
</sectionHeader>
<bodyText confidence="0.996934">
We defined history as being a sequence of versions and we briefly presented
Hismo as a history meta-model centered around the notion of history. We
then argued that we can obtain Hismo starting from a structural meta-model,
we specified the transformations needed, and we showed how we can reach our
Smalltalk (Figure 3) implementation based on the transformations.
</bodyText>
<page confidence="0.969806">
6
</page>
<bodyText confidence="0.999639333333333">
In the future we want to implement the automated transformations in our
environment and validate the approach by using our evolution analysis tools
on models generated with an industrial case tool.
</bodyText>
<sectionHeader confidence="0.987312" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9995525">
[1] T. Ball and S. Eick. Software visualization in the large. IEEE Computer, pages
33–43, 1996.
[2] A. Capiluppi. Models for the evolution of os projects. In Proceedings of the
International Conference on Software Maintenance (ICSM 2003), pages 65–74,
2003.
[3] A. Capiluppi, P. Lago, and M. Morisio. Evolution of understandability in
oss projects. In Proceedings of the 8th European Conference on Software
Maintenance and Reengineering (CSMR 2004), pages 58–66, 2004.
[4] C. Collberg, S. Kobourov, J. Nagra, J. Pitts, and K. Wampler. A system for
graph-based visualization of the evolution of software. In Proceedings of the
2003 ACM Symposium on Software Visualization, pages 77–86. ACM Press,
2003.
[5] S. Demeyer, S. Tichelaar, and S. Ducasse. FAMIX 2.1 — The FAMOOS
Information Exchange Model. Technical report, University of Bern, 2001.
[6] S. Ducasse, T. Gı̂rba, and J.-M. Favre. Modeling software evolution by treating
history as a first class entity. In Workshop on Software Evolution Through
Transformation (SETra 2004), pages 71–82, 2004.
[7] S. Ducasse, T. Gı̂rba, M. Lanza, and S. Demeyer. Moose: a collaborative and
extensible reengineering environment. In Reengineering Environments. tba,
2004. to appear.
[8] M. Fischer, M. Pinzger, and H. Gall. Populating a release history database from
version control and bug tracking systems. In Proceedings of the International
Conference on Software Maintenance (ICSM 2003), pages 23–32, Sept. 2003.
[9] T. Gı̂rba, S. Ducasse, and M. Lanza. Yesterday’s Weather: Guiding Early
Reverse Engineering Efforts by Summarizing the Evolution of Changes. In
Proceedings of ICSM ’04 (International Conference on Software Maintenance),
pages 40–49. IEEE Computer Society Press, 2004.
[10] T. Gı̂rba, S. Ducasse, R. Marinescu, and D. Raţiu. Identifying entities that
change together. In Ninth IEEE Workshop on Empirical Studies of Software
Maintenance, 2004.
[11] T. Gı̂rba and M. Lanza. Visualizing and characterizing the evolution of class
hierarchies. In Fifth International Workshop on Object-Oriented Reengineering
(WOOR 2004), 2004.
[12] A. Hassan and R. Holt. Predicting change propagation in software systems. In
Proceedings of 20th IEEE International Conference on Software Maintenance
(ICSM’04), pages 284–293. IEEE Computer Society Press, Sept. 2004.
[13] M. Jazayeri. On architectural stability and evolution. In Reliable Software
Technlogies-Ada-Europe 2002, pages 13–23. Springer Verlag, 2002.
</reference>
<page confidence="0.949648">
7
</page>
<reference confidence="0.999008615384615">
[14] M. Lanza and S. Ducasse. Understanding software evolution using a
combination of software visualization and software metrics. In Proceedings of
LMO 2002 (Langages et Modèles à Objets, pages 135–149, 2002.
[15] M. M. Lehman and L. Belady. Program Evolution – Processes of Software
Change. London Academic Press, 1985.
[16] D. Raţiu, S. Ducasse, T. Gı̂rba, and R. Marinescu. Using history information
to improve design flaws detection. In Proceedings of CSMR 2004 (European
Conference on Software Maintenance and Reengineering), pages 223–232, 2004.
[17] C. M. B. Taylor and M. Munro. Revision towers. In Proceedings of the
1st International Workshop on Visualizing Software for Understanding and
Analysis, pages 43–50. IEEE Computer Society, 2002.
[18] F. Van Rysselberghe and S. Demeyer. Studying software evolution information
by visualizing the change history. In Proceedings of The 20th IEEE
International Conference on Software Maintenance (ICSM 2004), 2004. to
appear.
[19] J. Wu, R. Holt, and A. Hassan. Exploring software evolution using
spectrographs. In Proceedings of 11th Working Conference on Reverse
Engineering (WCRE 2004), pages 80–89. IEEE Computer Society Press, Nov.
2004.
[20] X. Wu, A. Murray, M.-A. Storey, and R. Lintern. A reverse engineering
approach to support software maintenance: Version control knowledge
extraction. In Proceedings of 11th Working Conference on Reverse Engineering
(WCRE 2004), pages 90–99. IEEE Computer Society Press, Nov. 2004.
[21] T. Zimmermann, P. Weißgerber, S. Diehl, and A. Zeller. Mining version
histories to guide software changes. In 26th International Conference on
Software Engineering (ICSE 2004), pages 563–572, 2004.
</reference>
<page confidence="0.993446">
8
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.023712">
<note confidence="0.561724">International Workshop on Meta-Models and Schemas for Reverse Engineering, (ATEM 2004)</note>
<title confidence="0.9987415">Using Meta-Model Transformation to Model Software Evolution</title>
<author confidence="0.993291">Tudor Gı̂rba</author>
<affiliation confidence="0.9439875">Software Composition Group University of Bern, Switzerland</affiliation>
<author confidence="0.522835">Jean-Marie Favre</author>
<affiliation confidence="0.994574">LSR-IMAG Laboratory University of Grenoble, France</affiliation>
<address confidence="0.395282">Stéphane Ducasse 1,4</address>
<affiliation confidence="0.890225">Software Composition Group University of Bern, Switzerland</affiliation>
<abstract confidence="0.99957675">Understanding how software systems evolve is useful from different perspectives: reverse engineering, empirical studies etc.. For an effective understanding we need an explicit meta-model. We introduce Hismo, a meta-model which is centered around the notion of history and we show how we can obtain it from a snapshot meta-model. Based on our experience in developing the Hismo reverse engineering system, we show how we can transform a snapshot meta-model in a history metamodel.</abstract>
<keyword confidence="0.8332535">Key words: reverse engineering, software evolution, software history, model driven engineering, MDA, metamodel</keyword>
<note confidence="0.844173111111111">1 Email: ducasse@iam.unibe.ch 2 Email: girba@iam.unibe.ch 3 Email: jean-marie.favre@imag.fr 4 Ducasse and Gı̂rba gratefully acknowledge the financial support of the Swiss National Science Foundation for the projects “Tools and Techniques for Decomposing and Composing Software” (SNF Project No. 2000-067855.02, Oct. 2002 - Sept. 2004) and “RECAST: Evolution of Object-Oriented Applications” (SNF Project No. 620-066077, Sept. 2002 - Aug. 2006). Preprint submitted to Elsevier Preprint 17 April 2005</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>T Ball</author>
<author>S Eick</author>
</authors>
<title>Software visualization in the large.</title>
<date>1996</date>
<journal>IEEE Computer,</journal>
<pages>33--43</pages>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[1]</marker>
<rawString>T. Ball and S. Eick. Software visualization in the large. IEEE Computer, pages 33–43, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Capiluppi</author>
</authors>
<title>Models for the evolution of os projects.</title>
<date>2003</date>
<booktitle>In Proceedings of the International Conference on Software Maintenance (ICSM</booktitle>
<pages>65--74</pages>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[2]</marker>
<rawString>A. Capiluppi. Models for the evolution of os projects. In Proceedings of the International Conference on Software Maintenance (ICSM 2003), pages 65–74, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Capiluppi</author>
<author>P Lago</author>
<author>M Morisio</author>
</authors>
<title>Evolution of understandability in oss projects.</title>
<date>2004</date>
<booktitle>In Proceedings of the 8th European Conference on Software Maintenance and Reengineering (CSMR 2004),</booktitle>
<pages>58--66</pages>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[3]</marker>
<rawString>A. Capiluppi, P. Lago, and M. Morisio. Evolution of understandability in oss projects. In Proceedings of the 8th European Conference on Software Maintenance and Reengineering (CSMR 2004), pages 58–66, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Collberg</author>
<author>S Kobourov</author>
<author>J Nagra</author>
<author>J Pitts</author>
<author>K Wampler</author>
</authors>
<title>A system for graph-based visualization of the evolution of software.</title>
<date>2003</date>
<booktitle>In Proceedings of the 2003 ACM Symposium on Software Visualization,</booktitle>
<pages>77--86</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[4]</marker>
<rawString>C. Collberg, S. Kobourov, J. Nagra, J. Pitts, and K. Wampler. A system for graph-based visualization of the evolution of software. In Proceedings of the 2003 ACM Symposium on Software Visualization, pages 77–86. ACM Press, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Demeyer</author>
<author>S Tichelaar</author>
<author>S Ducasse</author>
</authors>
<date>2001</date>
<journal>FAMIX 2.1 — The FAMOOS Information Exchange Model.</journal>
<tech>Technical report,</tech>
<institution>University of Bern,</institution>
<contexts>
<context position="4156" citStr="[5]" startWordPosition="629" endWordPosition="629">el makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the proposed meta-model is Hismo. We implemented Hismo in a tool called Van which is built on top of the Moose reengineering environment [7]. We use Hismo for characterizing the evolution of software and we validated it in a number of occasions for reverse engineering purposes [9,10,11,16]. In our implementation, Hismo is based on the FAMIX meta-model [5]. However, the concept of history is by no means dependent on FAMIX and the approach can be applied to other meta-models as well. In other words from a conceptual view Hismo could be seen as a meta-model transformation 2 transforming a snapshot meta-model into an history meta-model. This paper investigates this idea by considering the problem of evolution analysis from a Model Driven (Reverse) Engineering perspective. In the next section we briefly present the concepts in Hismo, in Section 3 we describe the transformation needed for obtaining Hismo and before concluding, we discuss our approac</context>
</contexts>
<marker>[5]</marker>
<rawString>S. Demeyer, S. Tichelaar, and S. Ducasse. FAMIX 2.1 — The FAMOOS Information Exchange Model. Technical report, University of Bern, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Ducasse</author>
<author>T Gırba</author>
<author>J-M Favre</author>
</authors>
<title>Modeling software evolution by treating history as a first class entity.</title>
<date>2004</date>
<booktitle>In Workshop on Software Evolution Through Transformation (SETra 2004),</booktitle>
<pages>71--82</pages>
<contexts>
<context position="3785" citStr="[6]" startWordPosition="568" endWordPosition="568">4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the proposed meta-model is Hismo. We implemented Hismo in a tool called Van which is built on top of the Moose reengineering environment [7]. We use Hismo for characterizing the evolution of software and we validated it in a number of occasions for reverse engineering purposes [9,10,11,16]. In our implementation, Hismo is based on the FAMIX meta-model [5]. However, the concept of history is by no means dependent on FAMIX and the approach can be applied to other meta-models as well. In other words from a conceptual view Hismo could be seen as a meta-model transformation 2 transfor</context>
</contexts>
<marker>[6]</marker>
<rawString>S. Ducasse, T. Gı̂rba, and J.-M. Favre. Modeling software evolution by treating history as a first class entity. In Workshop on Software Evolution Through Transformation (SETra 2004), pages 71–82, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Ducasse</author>
<author>T Gırba</author>
<author>M Lanza</author>
<author>S Demeyer</author>
</authors>
<title>Moose: a collaborative and extensible reengineering environment. In Reengineering Environments. tba,</title>
<date>2004</date>
<note>to appear.</note>
<contexts>
<context position="3939" citStr="[7]" startWordPosition="595" endWordPosition="595">, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the proposed meta-model is Hismo. We implemented Hismo in a tool called Van which is built on top of the Moose reengineering environment [7]. We use Hismo for characterizing the evolution of software and we validated it in a number of occasions for reverse engineering purposes [9,10,11,16]. In our implementation, Hismo is based on the FAMIX meta-model [5]. However, the concept of history is by no means dependent on FAMIX and the approach can be applied to other meta-models as well. In other words from a conceptual view Hismo could be seen as a meta-model transformation 2 transforming a snapshot meta-model into an history meta-model. This paper investigates this idea by considering the problem of evolution analysis from a Model Dri</context>
</contexts>
<marker>[7]</marker>
<rawString>S. Ducasse, T. Gı̂rba, M. Lanza, and S. Demeyer. Moose: a collaborative and extensible reengineering environment. In Reengineering Environments. tba, 2004. to appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Fischer</author>
<author>M Pinzger</author>
<author>H Gall</author>
</authors>
<title>Populating a release history database from version control and bug tracking systems.</title>
<date>2003</date>
<booktitle>In Proceedings of the International Conference on Software Maintenance (ICSM</booktitle>
<pages>23--32</pages>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[8]</marker>
<rawString>M. Fischer, M. Pinzger, and H. Gall. Populating a release history database from version control and bug tracking systems. In Proceedings of the International Conference on Software Maintenance (ICSM 2003), pages 23–32, Sept. 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Gırba</author>
<author>S Ducasse</author>
<author>M Lanza</author>
</authors>
<title>Yesterday’s Weather: Guiding Early Reverse Engineering Efforts by Summarizing the Evolution of Changes.</title>
<date>2004</date>
<booktitle>In Proceedings of ICSM ’04 (International Conference on Software Maintenance),</booktitle>
<pages>40--49</pages>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="4089" citStr="[9,10,11,16]" startWordPosition="618" endWordPosition="618">o understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the proposed meta-model is Hismo. We implemented Hismo in a tool called Van which is built on top of the Moose reengineering environment [7]. We use Hismo for characterizing the evolution of software and we validated it in a number of occasions for reverse engineering purposes [9,10,11,16]. In our implementation, Hismo is based on the FAMIX meta-model [5]. However, the concept of history is by no means dependent on FAMIX and the approach can be applied to other meta-models as well. In other words from a conceptual view Hismo could be seen as a meta-model transformation 2 transforming a snapshot meta-model into an history meta-model. This paper investigates this idea by considering the problem of evolution analysis from a Model Driven (Reverse) Engineering perspective. In the next section we briefly present the concepts in Hismo, in Section 3 we describe the transformation neede</context>
<context position="10143" citStr="[9]" startWordPosition="1537" endWordPosition="1537">ory properties characterize the evolution of entities from a particular point of view. This approach allows one to manipulate time information just like structural information. In our example, we have a number characterizing the number of lines of code in a Class and we have a number characterizing the evolution of lines of code in a ClassHistory. The drawback of such properties resides in compressing large quantity of data into a limited set of properties. Yet, we used history properties and showed their usefulness in different evolution analyses: characterize how changes appear in the system[9]; use time to improve the detection of design 5 flaws [16]; visualize the evolution of class hierarchies [11]; detect patterns of change [10]. In Figure 3 we showed an example of how to reach our Smalltalk implementation for the navigation from PackageHistory to ClassHistory. In the same way we can generate the code for another language (e.g., Java). Also, in the example we just talked about Package and Class, but in a similar manner we could extend the diagram for other entities as well. For example, in Figure 4 we show an excerpt of Hismo, as implemented in our tool. The structural meta-mode</context>
</contexts>
<marker>[9]</marker>
<rawString>T. Gı̂rba, S. Ducasse, and M. Lanza. Yesterday’s Weather: Guiding Early Reverse Engineering Efforts by Summarizing the Evolution of Changes. In Proceedings of ICSM ’04 (International Conference on Software Maintenance), pages 40–49. IEEE Computer Society Press, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Gırba</author>
<author>S Ducasse</author>
<author>R Marinescu</author>
<author>D Ratiu</author>
</authors>
<title>Identifying entities that change together.</title>
<date>2004</date>
<booktitle>In Ninth IEEE Workshop on Empirical Studies of Software Maintenance,</booktitle>
<contexts>
<context position="4089" citStr="[9,10,11,16]" startWordPosition="618" endWordPosition="618">o understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the proposed meta-model is Hismo. We implemented Hismo in a tool called Van which is built on top of the Moose reengineering environment [7]. We use Hismo for characterizing the evolution of software and we validated it in a number of occasions for reverse engineering purposes [9,10,11,16]. In our implementation, Hismo is based on the FAMIX meta-model [5]. However, the concept of history is by no means dependent on FAMIX and the approach can be applied to other meta-models as well. In other words from a conceptual view Hismo could be seen as a meta-model transformation 2 transforming a snapshot meta-model into an history meta-model. This paper investigates this idea by considering the problem of evolution analysis from a Model Driven (Reverse) Engineering perspective. In the next section we briefly present the concepts in Hismo, in Section 3 we describe the transformation neede</context>
<context position="10284" citStr="[10]" startWordPosition="1560" endWordPosition="1560">on just like structural information. In our example, we have a number characterizing the number of lines of code in a Class and we have a number characterizing the evolution of lines of code in a ClassHistory. The drawback of such properties resides in compressing large quantity of data into a limited set of properties. Yet, we used history properties and showed their usefulness in different evolution analyses: characterize how changes appear in the system[9]; use time to improve the detection of design 5 flaws [16]; visualize the evolution of class hierarchies [11]; detect patterns of change [10]. In Figure 3 we showed an example of how to reach our Smalltalk implementation for the navigation from PackageHistory to ClassHistory. In the same way we can generate the code for another language (e.g., Java). Also, in the example we just talked about Package and Class, but in a similar manner we could extend the diagram for other entities as well. For example, in Figure 4 we show an excerpt of Hismo, as implemented in our tool. The structural meta-model consists of different entities (e.g., Method). These entities are wrapped by a Version correspondent (e.g.,MethodVersion) and the Versions </context>
</contexts>
<marker>[10]</marker>
<rawString>T. Gı̂rba, S. Ducasse, R. Marinescu, and D. Raţiu. Identifying entities that change together. In Ninth IEEE Workshop on Empirical Studies of Software Maintenance, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Gırba</author>
<author>M Lanza</author>
</authors>
<title>Visualizing and characterizing the evolution of class hierarchies.</title>
<date>2004</date>
<booktitle>In Fifth International Workshop on Object-Oriented Reengineering (WOOR</booktitle>
<contexts>
<context position="4089" citStr="[9,10,11,16]" startWordPosition="618" endWordPosition="618">o understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the proposed meta-model is Hismo. We implemented Hismo in a tool called Van which is built on top of the Moose reengineering environment [7]. We use Hismo for characterizing the evolution of software and we validated it in a number of occasions for reverse engineering purposes [9,10,11,16]. In our implementation, Hismo is based on the FAMIX meta-model [5]. However, the concept of history is by no means dependent on FAMIX and the approach can be applied to other meta-models as well. In other words from a conceptual view Hismo could be seen as a meta-model transformation 2 transforming a snapshot meta-model into an history meta-model. This paper investigates this idea by considering the problem of evolution analysis from a Model Driven (Reverse) Engineering perspective. In the next section we briefly present the concepts in Hismo, in Section 3 we describe the transformation neede</context>
<context position="10252" citStr="[11]" startWordPosition="1555" endWordPosition="1555">one to manipulate time information just like structural information. In our example, we have a number characterizing the number of lines of code in a Class and we have a number characterizing the evolution of lines of code in a ClassHistory. The drawback of such properties resides in compressing large quantity of data into a limited set of properties. Yet, we used history properties and showed their usefulness in different evolution analyses: characterize how changes appear in the system[9]; use time to improve the detection of design 5 flaws [16]; visualize the evolution of class hierarchies [11]; detect patterns of change [10]. In Figure 3 we showed an example of how to reach our Smalltalk implementation for the navigation from PackageHistory to ClassHistory. In the same way we can generate the code for another language (e.g., Java). Also, in the example we just talked about Package and Class, but in a similar manner we could extend the diagram for other entities as well. For example, in Figure 4 we show an excerpt of Hismo, as implemented in our tool. The structural meta-model consists of different entities (e.g., Method). These entities are wrapped by a Version correspondent (e.g.,</context>
</contexts>
<marker>[11]</marker>
<rawString>T. Gı̂rba and M. Lanza. Visualizing and characterizing the evolution of class hierarchies. In Fifth International Workshop on Object-Oriented Reengineering (WOOR 2004), 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Hassan</author>
<author>R Holt</author>
</authors>
<title>Predicting change propagation in software systems.</title>
<date>2004</date>
<booktitle>In Proceedings of 20th IEEE International Conference on Software Maintenance (ICSM’04),</booktitle>
<pages>284--293</pages>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[12]</marker>
<rawString>A. Hassan and R. Holt. Predicting change propagation in software systems. In Proceedings of 20th IEEE International Conference on Software Maintenance (ICSM’04), pages 284–293. IEEE Computer Society Press, Sept. 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Jazayeri</author>
</authors>
<title>On architectural stability and evolution.</title>
<date>2002</date>
<booktitle>In Reliable Software Technlogies-Ada-Europe</booktitle>
<pages>13--23</pages>
<publisher>Springer Verlag,</publisher>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[13]</marker>
<rawString>M. Jazayeri. On architectural stability and evolution. In Reliable Software Technlogies-Ada-Europe 2002, pages 13–23. Springer Verlag, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Lanza</author>
<author>S Ducasse</author>
</authors>
<title>Understanding software evolution using a combination of software visualization and software metrics.</title>
<date>2002</date>
<booktitle>In Proceedings of LMO 2002 (Langages et Modeles a Objets,</booktitle>
<pages>135--149</pages>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
<context position="5526" citStr="[14]" startWordPosition="850" endWordPosition="850">Id 0..1 version 1 history 1 /packageHistory 0..1 /classHistory ver. 1 ver. 2 ver. 3 ver. 1 ver. 2 ver. 3 Fig. 1. The relationship between the history and the versions. The Hismo meta-model is based on the explicit notions of history and versions. As these concepts are generic, they have to be applied to specific entities such as packages, classes, methods or any entity related to software that we want to study and for which having a version makes sense. Figure 1 shows Hismo applied to packages and classes. In the figure we also show the relation between our meta-model and the Evolution Matrix [14]. In the lower part of the figure we represent two Evolution Matrixes in which each cell represents a ClassVersion and each column represents PackageVersions. We define a history to be a sequence of versions. Thus, each line in the Evolution Matrix represents a ClassHistory (left matrix). Moreover, the whole matrix is actually a line formed by PackageVersions (right matrix), which means that the whole matrix can be seen as a PackageHistory (left matrix). In the right side of the figure we see the relationship between the version 3 ClassVersion /versionId /evolutionOfLOC: integer 0..1 version 1</context>
</contexts>
<marker>[14]</marker>
<rawString>M. Lanza and S. Ducasse. Understanding software evolution using a combination of software visualization and software metrics. In Proceedings of LMO 2002 (Langages et Modèles à Objets, pages 135–149, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M M Lehman</author>
<author>L Belady</author>
</authors>
<date>1985</date>
<booktitle>Program Evolution – Processes of Software Change.</booktitle>
<publisher>London Academic Press,</publisher>
<contexts>
<context position="2573" citStr="[15]" startWordPosition="376" endWordPosition="376">ent this information – typically a few unstructured lines of text to be inserted in a log file. While versioning systems enabled recording the history of each source file independently, configuration management systems (CMS) attempted to record the history of software products as a collection of versioned source files. Research on configuration management was very active in the 80’s and 90’s, but the emphasis was still on controlling and recording software evolution. The importance of modeling and analyzing software evolution started to be recognized in the early 1970’s with the work of Lehman[15]. Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolutio</context>
</contexts>
<marker>[15]</marker>
<rawString>M. M. Lehman and L. Belady. Program Evolution – Processes of Software Change. London Academic Press, 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Ratiu</author>
<author>S Ducasse</author>
<author>T Gırba</author>
<author>R Marinescu</author>
</authors>
<title>Using history information to improve design flaws detection.</title>
<date>2004</date>
<booktitle>In Proceedings of CSMR 2004 (European Conference on Software Maintenance and Reengineering),</booktitle>
<pages>223--232</pages>
<contexts>
<context position="4089" citStr="[9,10,11,16]" startWordPosition="618" endWordPosition="618">o understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the proposed meta-model is Hismo. We implemented Hismo in a tool called Van which is built on top of the Moose reengineering environment [7]. We use Hismo for characterizing the evolution of software and we validated it in a number of occasions for reverse engineering purposes [9,10,11,16]. In our implementation, Hismo is based on the FAMIX meta-model [5]. However, the concept of history is by no means dependent on FAMIX and the approach can be applied to other meta-models as well. In other words from a conceptual view Hismo could be seen as a meta-model transformation 2 transforming a snapshot meta-model into an history meta-model. This paper investigates this idea by considering the problem of evolution analysis from a Model Driven (Reverse) Engineering perspective. In the next section we briefly present the concepts in Hismo, in Section 3 we describe the transformation neede</context>
<context position="10201" citStr="[16]" startWordPosition="1548" endWordPosition="1548">m a particular point of view. This approach allows one to manipulate time information just like structural information. In our example, we have a number characterizing the number of lines of code in a Class and we have a number characterizing the evolution of lines of code in a ClassHistory. The drawback of such properties resides in compressing large quantity of data into a limited set of properties. Yet, we used history properties and showed their usefulness in different evolution analyses: characterize how changes appear in the system[9]; use time to improve the detection of design 5 flaws [16]; visualize the evolution of class hierarchies [11]; detect patterns of change [10]. In Figure 3 we showed an example of how to reach our Smalltalk implementation for the navigation from PackageHistory to ClassHistory. In the same way we can generate the code for another language (e.g., Java). Also, in the example we just talked about Package and Class, but in a similar manner we could extend the diagram for other entities as well. For example, in Figure 4 we show an excerpt of Hismo, as implemented in our tool. The structural meta-model consists of different entities (e.g., Method). These ent</context>
</contexts>
<marker>[16]</marker>
<rawString>D. Raţiu, S. Ducasse, T. Gı̂rba, and R. Marinescu. Using history information to improve design flaws detection. In Proceedings of CSMR 2004 (European Conference on Software Maintenance and Reengineering), pages 223–232, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C M B Taylor</author>
<author>M Munro</author>
</authors>
<title>Revision towers.</title>
<date>2002</date>
<booktitle>In Proceedings of the 1st International Workshop on Visualizing Software for Understanding and Analysis,</booktitle>
<pages>43--50</pages>
<publisher>IEEE Computer Society,</publisher>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[17]</marker>
<rawString>C. M. B. Taylor and M. Munro. Revision towers. In Proceedings of the 1st International Workshop on Visualizing Software for Understanding and Analysis, pages 43–50. IEEE Computer Society, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Van Rysselberghe</author>
<author>S Demeyer</author>
</authors>
<title>Studying software evolution information by visualizing the change history.</title>
<date>2004</date>
<booktitle>In Proceedings of The 20th IEEE International Conference on Software Maintenance (ICSM</booktitle>
<note>to appear.</note>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[18]</marker>
<rawString>F. Van Rysselberghe and S. Demeyer. Studying software evolution information by visualizing the change history. In Proceedings of The 20th IEEE International Conference on Software Maintenance (ICSM 2004), 2004. to appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Wu</author>
<author>R Holt</author>
<author>A Hassan</author>
</authors>
<title>Exploring software evolution using spectrographs.</title>
<date>2004</date>
<booktitle>In Proceedings of 11th Working Conference on Reverse Engineering (WCRE 2004),</booktitle>
<pages>80--89</pages>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[19]</marker>
<rawString>J. Wu, R. Holt, and A. Hassan. Exploring software evolution using spectrographs. In Proceedings of 11th Working Conference on Reverse Engineering (WCRE 2004), pages 80–89. IEEE Computer Society Press, Nov. 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>X Wu</author>
<author>A Murray</author>
<author>M-A Storey</author>
<author>R Lintern</author>
</authors>
<title>A reverse engineering approach to support software maintenance: Version control knowledge extraction.</title>
<date>2004</date>
<booktitle>In Proceedings of 11th Working Conference on Reverse Engineering (WCRE</booktitle>
<pages>90--99</pages>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[20]</marker>
<rawString>X. Wu, A. Murray, M.-A. Storey, and R. Lintern. A reverse engineering approach to support software maintenance: Version control knowledge extraction. In Proceedings of 11th Working Conference on Reverse Engineering (WCRE 2004), pages 90–99. IEEE Computer Society Press, Nov. 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Zimmermann</author>
<author>P Weißgerber</author>
<author>S Diehl</author>
<author>A Zeller</author>
</authors>
<title>Mining version histories to guide software changes.</title>
<date>2004</date>
<booktitle>In 26th International Conference on Software Engineering (ICSE 2004),</booktitle>
<pages>563--572</pages>
<contexts>
<context position="3210" citStr="[1,2,3,4,8,12,13,14,17,18,19,20,21]" startWordPosition="474" endWordPosition="474">Yet, it was only until recent years that extensive research has been spent on exploiting the wealth of information residing in versioning repositories. While it was possible to find which specific lines of code were changed between two versions of a particular file, this led to too much and two detailed information to be really useful. However, most of the approaches developed so far, do not rely on an explicit meta model for evolution analysis and do not facilitate the comparison of different evolutions. Various approaches have been proposed to analyze different aspects of software evolution [1,2,3,4,8,12,13,14,17,18,19,20,21]. Each of these approaches typically focuses on only some traits of software evolution (e.g., which parts are changed the most, what kind of changes happened in a particular part etc.), and do not rely on explicit meta models. In such conditions, is it is difficult to understand what the models exactly refer to. The lack of explicit meta-model makes it difficult to compare and integrate tools even when they provide similar yet different or complementary results. The authors have already built the case for an explicit meta-model centered around the notion of history [6]. The name of the propose</context>
</contexts>
<marker>[21]</marker>
<rawString>T. Zimmermann, P. Weißgerber, S. Diehl, and A. Zeller. Mining version histories to guide software changes. In 26th International Conference on Software Engineering (ICSE 2004), pages 563–572, 2004.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>