<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.8332175">
Explicit Support for Software Development Styles
throughout the Complete Life Cycle
</title>
<author confidence="0.889107">
Roel Wuyts, Kim Mensy and Theo D&amp;apos;Hondt
</author>
<affiliation confidence="0.699425">
Programming Technology Lab
</affiliation>
<table confidence="0.40955">
Vrije Universiteit Brussel
Pleinlaan 2, 1050 Brussel, Belgium
e-mail: f rwuyts j kimmens j tjdhondt g @vub.ac.be
April 1st, 1999
</table>
<sectionHeader confidence="0.961442" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.998813">
Throughout its entire life cycle software development is subject to
many rules constraining and guiding construction of software systems.
Examples are best-practice patterns, idioms, coding conventions, design
guidelines, architectural patterns, etc. Although such regulations are
widely used, their usage is currently implicit or ad-hoc, and most soft-
ware development environments do not explicitly support them. We
present an approach to declare explicitly software development styles in
an open declarative system that allows querying, conformance check-
ing and enforcement of these declarations on the source code. We
validate the approach by expressing and supporting several software
development styles in a real-world case.
</bodyText>
<sectionHeader confidence="0.998226" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.9996">
The software development process is strongly constrained by all kinds of im-
plementation, design and architectural guidelines. Although the widespread
Research conducted on a doctoral grant from the \Instituut ter bevordering van het
Wetenschappelijk en Technologisch onderzoek in de Industrie&quot; (Flanders, Belgium).
yResearch funded by the Brussels Capital Region (Belgium).
</bodyText>
<page confidence="0.918628">
1
</page>
<bodyText confidence="0.998418181818182">
usage of software development styles throughout the life-cycle, general sup-
port is almost nonexistent in current day development environments. The
few systems that allow the usage of such rules (like [Min96, MP97, Bok99,
MDR93]) target one phase only in the development cycle (implementation,
design or architectural), as we will see in the next section. While these sys-
tems are an important rst step, we claim that general support is needed
for
 declaring software development styles explicitly in all phases of the life-
cycle and on all levels of abstraction in one and the same formalism.
 supporting these software development styles to allow enforcing and
compliance checking to the source code.
We propose a declarative formalism to express all software development
styles, thereby making them explicit in a medium that allows us to extract
source code, to do conformance checking and enforcement. To validate our
formalism we use a real-world case study where we express many di erent
software development styles, on di erent levels of abstraction, and explain
their usage in practical development.
The remainder of this paper is structured as follows: next section dis-
cusses software development styles in more detail, while the following section
will describe examples of expressing and using software development styles
throughout development. Then we discuss the results of these experiments.
Finally we end with related and future work, and a conclusion.
</bodyText>
<sectionHeader confidence="0.993718" genericHeader="method">
2 Software Development Styles
</sectionHeader>
<bodyText confidence="0.83036225">
We de ne a software development style as a set of rules that constrain the
structure a software system according to certain requirements (such as e-
ciency, extensibility, . . . ). Literature provides di erent examples of software
development styles, but mostly in speci c phases of the life-cycle:
</bodyText>
<listItem confidence="0.7549845">
1. implementation styles are widely encountered in di erent program-
ming languages and systems. They include style guides that describe
</listItem>
<page confidence="0.971886">
2
</page>
<bodyText confidence="0.997571967741936">
what a `well-styled&amp;apos; program in a language looks like, for example best-
practice patterns [Bec97], general guidelines for Smalltalk [Lew95], or
idioms [Cop98]. Although a lot of these rules are fairly simple to
enforce or even check, almost no development environments do so.
Exceptions are for example [MDR93] or [Bok99].
2. design styles : the best known example in this phase is probably de-
sign patterns [GHJV94, Pre94]. Support for design patterns, let alone
general design style support is virtually nonexistent. As exceptions
we note [FMvW97, Bos97]. Another example of a design guideline is
contracts [HHG90].
3. architectural styles : work has been done in the architectural com-
munity in constructing architectural description languages, architec-
tural constraint languages and architectural patterns [SG96, SSWA96,
Bal96, BMR+96]. The major di erence with our approach is that they
focus on architecture alone, while we propose a uni ed formalism that
can be used for all kinds of software development styles. Another im-
portant example is law governed architectures (LGA) [Min96]; we will
discuss this in more detail in section 6.
Both this related work and the experiences of our industrial partners
motivate the need and demand for expressing and supporting development
styles at all levels of the software life-cycle. We were also struck by the
commonalities in currently available approaches. Therefore, it would be
bene cial to develop a uni ed approach in which all these styles can be ex-
pressed. With such an approach, developers only need to use one approach,
minimizing the overhead of learning to work with it. Furthermore, all de-
veloped support tools are immediately available at many levels of the life
cycle. Finally, declaring all styles in the same uniform formalism makes it
very easy to de ne them in terms of more low-level ones. This is a powerful
abstraction mechanism typically not provided by most existing approaches.
Our experiments indicate that a declarative approach would be very well
suited to support software development styles. Another advantage of a
</bodyText>
<page confidence="0.990903">
3
</page>
<bodyText confidence="0.973002428571428">
declarative approach is that it expresses formal relationships between argu-
ments. This means for example that one and the same relation between two
classes can be used in 4 ways: to check whether this relation holds between
both, to enumerate all classes if one of the two is given, or to enumerate all
couples of classes satisfying the relation. A non-declarative approach would
require di erent functions.
We also want our approach to be as open as possible. It should be
possible at all times to introduce new kinds of styles, to reason about new
kinds of software artifacts, and so on.
Before the next section introduces the declarative medium we used for
our experiments, we give two informal examples of software development
styles that we will describe explicitly later on in the experiments section.
The rst is application speci c, while the other is an example of a naming
convention:
</bodyText>
<listItem confidence="0.9197276">
1. A bridge pattern will be used as the core design element in the per-
sistency layer. Every class that needs to be persistent should conform
to this pattern.
2. Methods returning booleans should be pre xed with `is&amp;apos;.
3 Smalltalk Open Uni cation Language
</listItem>
<bodyText confidence="0.999584818181818">
In the experiments for this paper we have used SOUL (Smalltalk Open Uni -
cation Language) [Wuy98] to declare software development styles, and tools
based on SOUL for querying source code, for doing conformance checking
and for enforcement of styles. SOUL is PROLOG-like, but has an extension
that allows uni cation on user-de ned elements. This lets logical clauses
directly reference elements from the base language (such as classes, inheri-
tance relations, method bodies, . . . ), avoiding the overhead of constructing
and maintaining a separate repository containing the source code. Another
feature are the second-order predicates that allow easy manipulation of lists.
While SOUL itself is implemented in Smalltalk, it reasons about programs
of general object-oriented programs by representing the programs using a
</bodyText>
<page confidence="0.98801">
4
</page>
<bodyText confidence="0.983909233333333">
general OO parse tree format. Thus logic reasoning is possible using ne-
grained structural information (such as classes, methods, instance variables,
message sends, parameter passing, . . . ).
A declarative framework of rules that allows reasoning at the implemen-
tation, design and architectural level was implemented in SOUL [Wuy98].
It can be seen as a layered structure, starting from a base-language depen-
dent layer that maps to the basics of an object-oriented language. On top
of this layer sits the basic structural layer that adds basic predicates di-
rectly related to the source code. Then higher level layers are available that
describes higher level relationships, such as design patterns. Recently yet
another layer was put on top of this that allows reasoning at an architectu-
ral level [MW99]. Using the declarative framework implemented in SOUL
gives us a powerful medium to reason about structural information in an
object-oriented language, while still providing the capability to check such
structures against the source code.
4 Using explicit Software Development Styles
In this section we give a concrete feeling on how to express concrete software
development styles. We will do this using a real-world case, where we can
express a number of software development styles that arose during develop-
ment, and indicate how to use these styles in the development process. We
will assume an incremental development process where we will focus on two
cycles:
 a rst cycle where the core of the framework is built.
 a second cycle that extends this core towards a full
edged application.
The reason to structure the examples in two cycles is that usage of the
software development styles will normally be di erent. In the rst phase
a number of software development will typically be introduced, but not
directly strongly enforced. Progressively, as the framework matures, confor-
mance to the existing guidelines becomes more and more important. Once
</bodyText>
<page confidence="0.613088">
5
</page>
<figure confidence="0.995008166666667">
RefinedAbstraction ConcreteImplementor
OperationImp
Operation
Abstraction
OperationImp
Implementoraggr
</figure>
<figureCaption confidence="0.999859">
Figure 1: Bridge Pattern Structure
</figureCaption>
<bodyText confidence="0.998513333333333">
in the maintenance phase, violations of the software development styles are
not allowed any longer. We will now start by introducing the case, and
afterwards the examples in the two cycles.
</bodyText>
<subsectionHeader confidence="0.995149">
4.1 Case: The Persistency Layer
</subsectionHeader>
<bodyText confidence="0.998704133333333">
The case we use is the persistency layer1, part of a planning application for
broadcasting companies [CHSV97, VV96]. It allows the storage of objects in
Smalltalk in a relational database, transparently supports di erent relational
databases that can be changed at runtime, and supports di erent mappings
from objects on relational tables. The persistency layer was developed in
house because persistency layers with these features were not available at
the time.
The core of the persistency layer is a bridge architecture (see picture 1)
that permits di erent useful mapping strategies to map objects on rows and
tables in a relational database. The bridge is responsible for mapping the
high-level domain objects to the lower-level entity objects that will be stored
in the database. The bridge \knows&quot; how to map structures of the domain
model to a set of entity classes that respect the constraints of the database
layer. The persistency layer gives a lot of freedom in choosing a mapping
strategy. Strategies can be reused, enhanced or new strategies can be devel-
</bodyText>
<footnote confidence="0.8748645">
oped. The same holds for the storage classes themselves. Performance can
1Provided by one of our industrial partners, MediaGeniX
</footnote>
<page confidence="0.997272">
6
</page>
<bodyText confidence="0.999830615384615">
be gained by ne-tuning a storage class or creating a very speci c one (that
could even include hard coded SQL-statements if needed), but this will never
have an impact on the conceptual object model. Note also that the same
conceptual object class can have multiple storage classes that implement it.
This property of the bridge architecture is used to adapt applications to
di erent relational database systems and to integrate applications that use
the persistency layer with existing, customer speci c tables.
The most important reason for choosing this particular case above others
is that it is suciently elaborate and general to demonstrate a number of
di erent software development styles, yet fairly easy to explain. It is also
part of an application framework that is instantiated and customized for
di erent users, yet it is not too domain speci c (the problem of persistency
plays an important role in many di erent domains).
</bodyText>
<subsectionHeader confidence="0.972838">
4.2 Cycle 1: Core Framework Development
</subsectionHeader>
<bodyText confidence="0.999469375">
In this section we assume that the requirements and analysis phase are over
and that the initial design of the persistency layer is done. Implementation
of the core framework then starts. Some software development styles can be
known up-front (for example by experience from other applications) and can
be expressed and used directly. Other styles will only become clear during
development. We will give two examples: the bridge pattern that forms
the core of the persistency layer, and a naming convention rule. These are
actually the examples that were given informally in section 2.
</bodyText>
<subsubsectionHeader confidence="0.967896">
4.2.1 The Bridge Pattern
</subsubsectionHeader>
<bodyText confidence="0.999798857142857">
From the analysis it was clear that the core of the persistency layer should be
a bridge architecture to decouple the domain and the storage classes. It was
also clear that persistent classes need to adhere to this structure at all times.
In the original development this could not be expressed, let alone enforced.
We will describe and use the software development style expressing this core
architectural knowledge of the persistency layer.
We rst have to express the bridge pattern [GHJV94] that relates the
</bodyText>
<page confidence="0.995653">
7
</page>
<bodyText confidence="0.968649739130435">
domain classes and the storage classes. We will do this with a logical rule
that describes the four participants of the bridge pattern and their relations
(see also gure 1): the abstraction class, the implementor class, the re ned
abstraction (subclass of the abstraction class) and the concrete implemen-
tor (subclass of the implementor class). The most important relation is
the aggregation relation ?aggr between the abstraction class ?abs and the
implementor class ?impl. This aggregation relation is used by the methods
on the abstraction classes ?absMethod to call methods ?impSelector of the
concrete implementation classes. Following rule expresses the bridge pattern
relationship between the four participants2.
Rule bridge(?abs, ?re nedAbs, ?impl, ?concreteImpl) if
hierarchy(?abs, ?re nedAbs),
hierarchy(?impl, ?concreteImpl),
aggregationRelation(?abstraction, ?implementor, ?aggr),
method(?abstraction, ?absMethod),
classImplements(?implementor, ?impSelector),
implementedInTermsOf(?absMethod, ?aggr, ?impSelector)
Now that we have expressed the software development style describing
the bridge pattern relation, we can use SOUL and the SOUL tools for query-
ing or conformance checking. For example, we can check in the source code
whether the persistent classWONPsiUser3, conforms to our style expressing
the bridge pattern using the following query:
Query bridge(?domain, [WONPsiUser], ?storage, ?concrete)
</bodyText>
<listItem confidence="0.8597725">
2Some notes on SOUL syntax:
1. the keywords Rule , Fact and Query denotes logical rules facts and queries
2. variables start with a question mark
3. terms between square brackets contain Smalltalk code, which can be constants,
such as strings or symbols, but also complete Smalltalk expressions that reference
logic variables from the outer scope.
</listItem>
<footnote confidence="0.602466">
4. &amp;lt;&gt; is the list notation
3This is the actual name of a class used in the persistency layer which explains it
somewhat strange name
</footnote>
<page confidence="0.994248">
8
</page>
<bodyText confidence="0.999443307692308">
The result of this query is a number of bindings for the di erent vari-
ables. In this case it will answer that ?domain will be WONDomain, ?stor-
age will be WONStorage and ?concrete will be PSIUser. This means that
WONPsiUser and PsiUser are the domain and storage classes respectively,
which was correct according to the developers. Note the usage of the multi-
way property of declarative languages as introduced in section 2. The query
shows how the rule that describes the bridge relation can be used in di erent
ways, just by lling in what is known. The rest will be computed using the
relations expressed. This makes it easy for example to bind every variable
with concrete classes and check if they conform to the software development
style. It makes it easy also to use SOUL as reasoning engine in specialized
tools, for example in a `Bridge Browser&amp;apos; that browses source code as de ned
by this style.
</bodyText>
<subsubsectionHeader confidence="0.991598">
4.2.2 Pre x Boolean Methods with `is&amp;apos;
</subsubsectionHeader>
<bodyText confidence="0.949321133333333">
As second example we will express a well known implementation guideline
that methods that return booleans should have a name starting with is.
We can easily write a rule to express this naming convention for a method
?method. We see if method returns a boolean4; if so, we check its name
?name to ensure it starts with is :
Rule pre xedWithIs(?method) if
resultType(?method, [Boolean]),
methodName(?method, ?name),
[`is*&amp;apos; match: ?name]
Again, now that we have expressed the style we can use it for querying,
conformance checking or enforcement. Even in this stage of development
this rule will typically be strongly enforced. However, if we want to check
the source code for violations of the style, we could use a query that checks
for each class ?class in the persistency layer whether its methods ?method
conform to the rule describing the style:
</bodyText>
<footnote confidence="0.9151195">
4Note that in Smalltalk this requires a type analysis, while in a statically typed language
this can be checked easily
</footnote>
<page confidence="0.779739">
9
</page>
<table confidence="0.350297">
Query persistencyClass(?class),
method(?class, ?method),
pre xedWithIs(?method)
</table>
<subsectionHeader confidence="0.61366">
4.3 Cycle 2: Extending and Re ning the Core Framework
</subsectionHeader>
<bodyText confidence="0.9987936">
The next phase in the development process is where the core framework
is largely completed and stable, and where it is then incrementally re ned
and extended. In this stage a lot of software development styles are needed
to guide this explosion of code and make sure that there is not too much
architectural drift, compromising the initial clean structure of the frame-
work. As the framework becomes more stable, the rules will typically be
enforced stronger. We will describe some example styles, namely that in-
stance variables can only be accessed using accessor methods, that storage
classes should provide default domain classes and vice versa, and that acces-
sors of persistent classes use a very speci c form to cross the bridge safely.
</bodyText>
<subsubsectionHeader confidence="0.902569">
4.3.1 Always use Accessor Methods
</subsubsectionHeader>
<bodyText confidence="0.843072384615385">
Because of several reasons, such as hiding the interface from the implemen-
tation, there was a decision to use accessor methods consistently to access
instance variables instead of manipulating them directly [Bec97]. While this
is currently implicit, we could again make this software development style
explicit and use it in tools so that violations could be tracked down or logged.
As an example we will describe that a method ?method should never sent
messages directly to instance variables (so the receivers ?receiver cannot be
instance variables). Note that, in order to retrieve the instance variables of
a class, we rst ask the method ?method for its class ?class.
Rule usesNoInstVars(?method) if
methodClass(?method, ?class),
isSendTo(?receiver, ?message, ?method),
not(instVar(?class, ?receiver))
</bodyText>
<page confidence="0.978106">
10
</page>
<bodyText confidence="0.916379307692308">
Once we have expressed this style, we can check if the code conforms
to this software development style by checking whether for every persistent
class ?classToCheck every method ?methodToCheck does not use instance
variables directly:
Query forall( and(
persistentClass(?classToCheck),
method(?classToCheck, ?methodToCheck)),
usesNoInstVars(?methodToCheck))
This query will return true if all methods of persistent classes conform
to the style, or false as soon as there is one that does not. While this is
already interesting to check, we can provide more feedback to detect where
the violations are. Next query for example will actually nd the classes and
methods that violate the style:
</bodyText>
<equation confidence="0.653715">
Query persistentClass(?classToCheck),
method(?classToCheck, ?methodToCheck),
not(usesNoInstVars(?methodToCheck))
</equation>
<subsubsectionHeader confidence="0.959352">
4.3.2 Default Domain and Storage Classes
</subsubsectionHeader>
<bodyText confidence="0.9923136">
Another important decision was to provide default domain and storage
classes using factory methods [GHJV94]. More speci cally, with each do-
main class must have a factory method returning a default storage class and
vice versa. We can write a query to check for each class in the persistency
layer whether it conforms to this structure. This is indeed very important
because the bridge relies on these methods to have a default mapping. For
every class ?storage in the storage hierarchy we check if it has a class factory
method ?storMethod that creates a domain class ?domain. We then check
if this associated domain class has a factory class method ?domMethod that
references back the storage class.
</bodyText>
<page confidence="0.985182">
11
</page>
<equation confidence="0.3301384">
Query forall(
storageClass(?storage),
and(
classFactoryMethod(?storage, ?storMethod, ?domain),
classFactoryMethod(?domain,?domMethod,?storage)))
</equation>
<bodyText confidence="0.907006571428571">
Because the presence of a default mapping is important for the bridge
pattern used in the persistency layer, we chose to re ne the de nition. We
made a re nedBridge rule that not only speci es that the general bridge
architecture should hold, but also that the factory methods for the default
mapping should exist:
Rule re nedBridge(?abs, ?re nedAbs, ?impl, ?concreteImpl) if
classFactoryMethod(?re nedAbs,?m1,?concreteImpl),
classFactoryMethod(?concreteImpl,?m2,?re nedAbs),
bridge(?abs,?re nedAbs,?impl,?concreteImpl)
Note that this rule illustrates that by having one uni ed approach we
can easily describe styles that cross the boundaries of di erent levels of
abstraction. It also shows how the abstraction mechanism of a rule-based
language are used to express speci c, case dependent software development
styles in function of other styles.
</bodyText>
<subsubsectionHeader confidence="0.723275">
4.3.3 Accessors to cross the Bridge
</subsubsectionHeader>
<bodyText confidence="0.986945666666667">
In a domain class that needs to be persistent, instance variables should not
be used. The class should adhere to the bridge pattern instead, and has to
provide accessor methods to store and retrieve its instance variables from the
relational database. This means that the accessor methods have a speci c
form, because they are responsible for crossing the bridge. To be able to
enforce the correct form of an accessor method in the persistency layer, we
will rst describe the form of a statement that uses the bridge to fetch the
value of an instance variable from its storage class, and turn it into a domain
object. This gives following sequence of message sends:
</bodyText>
<page confidence="0.99404">
12
</page>
<listItem confidence="0.976617166666667">
1. send the message asStorage to the receiver self (this) to get the storage
class of the receiver;
2. send the message to retrieve the instance variable to that storage class
(by convention this method&amp;apos;s name is the same as the instance vari-
able&amp;apos;s);
3. send the message asDomain to get the domain class for the instance
</listItem>
<bodyText confidence="0.8389222">
variable.
The following fact expresses this sequence, where the variable ?selector
is the message that will be sent to the storage class to fetch the value for
the instance variable (note that it works directly on the representation of
the parse tree):
</bodyText>
<figure confidence="0.903774272727273">
Fact persistentAccessorStatement(
return(
send(
send(
send(variable([#self]),[#asStorage],&amp;lt;&gt;),
?selector,
&amp;lt;&gt;),
[#asDomain],
&amp;lt;&gt;)),
?selector
)
</figure>
<bodyText confidence="0.987049">
Now that we have a fact that describes the form of a statement to retrieve
the value of an instance variable from the storage class, we can write a rule
that speci es the structure of an accessor method. We express that an
accessor method ?method for an instance variable ?instVar has the same
name as ?instVar (in both storage class and domain class), and that the
body contains one statement ?statement that complies to the form given in
above fact.
</bodyText>
<page confidence="0.992418">
13
</page>
<bodyText confidence="0.750181428571429">
Rule persistentAccessor(?method, ?instVar) if
methodName(?method, ?instVar),
methodStatements(?method, &amp;lt;?statement&gt;),
persistentAccessorStatement(?statement, ?instVar).
Again, once we have expressed a rule describing the software develop-
ment style we can use this rule for querying, conformance checking or en-
forcement.
</bodyText>
<sectionHeader confidence="0.992473" genericHeader="method">
5 Discussion
</sectionHeader>
<bodyText confidence="0.9991556">
In this section we recapitulate some important issues that were already ad-
dressed in the case. We will discuss the generality of the approach, the
integration in a development environment, performance for di erent kinds
of usage and the need of managerial and developer support when fully em-
bracing software development styles.
</bodyText>
<subsectionHeader confidence="0.987342">
5.1 General support throughout development
</subsectionHeader>
<bodyText confidence="0.998718083333333">
As motivated in section 2 there is need for an open, general declarative
approach to support software development styles throughout development.
We have illustrated this in the previous section by expressing expressing and
using several software development styles on di erent levels of abstraction.
For example, on implementation level we expressed the naming convention
that boolean methods have to start with is. At design level we declared
the default mapping between domain and storage classes, and that this
mapping uses the factory method design pattern. At higher level design
we expressed the bridge pattern, the core of the persistency architecture.
They also indicated the need for a powerful, rule-based declarative approach.
While not always visible at rst, most queries actually require uni cation to
be solved.
</bodyText>
<page confidence="0.992283">
14
</page>
<subsectionHeader confidence="0.999024">
5.2 Integration with the Environment
</subsectionHeader>
<bodyText confidence="0.997712074074074">
One of the important aspects to practically use software development styles
is the integration with the development environment. Based on our expe-
rience gained with the experiments we think an environment supporting
software development styles should at least provide the following tools:
 tools to easily express software development styles. More speci cally,
the developer should not have to interact directly with the underly-
ing reasoning language, but should be able to interact with software
development styles using appropriate views.
 tools that take advantage of the knowledge described by the software
development styles to browse the system on a high level of abstraction.
 tools for doing conformance checking of software development styles
against the code. They should provide overviews what does and what
does not conform to the styles.
 tools for enforcement (both strong and weak).
SOUL adheres to some, but not all of these requirements. We have im-
plemented a tool that makes it easy to nd source code that conforms to
certain criteria and styles, and a tool that allows weak enforcement of styles
by doing a conformance check every time a method is accepted in Smalltalk5.
The violations are logged on a todo-list so development is not hindered while
styles are enforced. While this non intrusive approach is necessary in some
stages of development there should also be a strong enforcement tool that
does not allow the compilation of non-conforming methods. We are exper-
imenting with such tool in order to nd a good balance between the kinds
of styles we want to enforce strongly versus the performance penalty of
performing the checks. Writing software development styles and doing con-
formance checks is currently done by manually writing SOUL code. Figure 2
shows a screenshot of the tools we used for our experiments.
</bodyText>
<footnote confidence="0.868732">
5Smalltalk uses incremental compilation, so this is a natural integration with a
Smalltalk development environment.
</footnote>
<page confidence="0.953718">
15
</page>
<figureCaption confidence="0.998123">
Figure 2: SOUL Tools: the Query Application (for manually invoking
</figureCaption>
<bodyText confidence="0.736633">
queries), the TODO application that allows weak enforcement, the Find
Application and the Repository Inspector
</bodyText>
<page confidence="0.981127">
16
</page>
<subsectionHeader confidence="0.988213">
5.3 Performance
</subsectionHeader>
<bodyText confidence="0.999709428571429">
The need for performance di ers di ers depending on how software devel-
opment styles are used. Conformance checking, for example, is typically a
bulk operation that is run overnight and produces a report with the viola-
tions. Raw performance is then less of an issue. On the other hand, for
querying and enforcement of software development styles the performance
is important. We nd that the performance of SOUL for this kind of us-
age is acceptable, meaning that it typically is an order of magnitude faster
than performing the operation by hand. For example, the slowest query in
this paper (doing a conformance check to make sure that domain and stor-
age classes have default methods) takes only slightly more than a minute6.
Manually checking this relation takes over 20 minutes. This does not mean
however that every query is fast. The combination of the declarative nature
of our approach with high-level predicates implies that solving some queries
might take a very long time.
</bodyText>
<subsectionHeader confidence="0.986709">
5.4 Managerial issues
</subsectionHeader>
<bodyText confidence="0.997327333333333">
A development methodology that fully embraces the usage of software devel-
opment styles, special phases may be needed to declare and maintain such
rules. Dedicated management and developer functions should probably be
created in order to maintain the rules. This extra cost should pay of later,
because development and maintenance are then guided by the software de-
velopment styles. We plan to investigate further this issue.
</bodyText>
<sectionHeader confidence="0.999332" genericHeader="method">
6 Related Work
</sectionHeader>
<bodyText confidence="0.95944675">
The main contribution of this paper is the introduction of a formalism that
allows the expression of software development styles explicitly and supports
querying, conformance checking and enforcement of these styles to the source
code. In this section we will summarize some related approaches, and dis-
</bodyText>
<footnote confidence="0.967587">
6This was measured for the persistency layer containing 143 classes and 431 methods
on a G3-250 Mhz Macintosh and a Pentium-II 300 Mhz PC.
</footnote>
<page confidence="0.999536">
17
</page>
<bodyText confidence="0.994196">
cuss similarities and di erences. We have subdivided the approaches in two
groups depending on whether or not they use a declarative language.
</bodyText>
<subsectionHeader confidence="0.538486">
6.1 Non-declarative Languages
</subsectionHeader>
<bodyText confidence="0.994794571428572">
There are a number of approaches that propose non-declarative constraint
languages. For example, Co eestrainer [Bok99] is a Java preprocessor where
constraints can be added that reason about an annotated parse tree. The
constraints are expressed in Java. While there are arguments in favor of
this approach (such as the developers not needing to learn a new language),
we feel that there are more drawbacks than advantages, as mentioned in
section 2.
Other approaches propose languages that are not as powerful as declar-
ative languages. An example is Smalltalk Lint [RBJO96], a regular expres-
sion like language that allows to check for common programming mistakes in
Smalltalk (such as its famous C predecessor). While it allows a certain level
of reasoning about Smalltalk parse trees, we lack the abstraction facilities of
a logic-like language that allows the expression of higher level abstractions.
Yet another example is CDL [KKS96], the Constraint Description Language,
targeted towards a very speci c domain and only allowing xed parse trees.
Another category of languages are those that propose formalisms to de-
scribe constraints or rules about the structure of programs, but that lack a
computable medium to check them. OCL [OMG97], the Object Constraint
Language used in UML 1.1 is a good example. These languages can be used
as a notation, but because they cannot be executed they merely serve as
structured comment.
</bodyText>
<subsectionHeader confidence="0.940425">
6.2 Declarative Languages
</subsectionHeader>
<bodyText confidence="0.9992858">
CCEL [MDR93] is a constraint language for use with C++ that allows one
to express programmer-de ned constraints on the structure. The constraint
language however is limited and does not allow to make abstractions. This
means we are not able to construct constraints referencing or building on
other constraints. We consider this a serious shortcoming, since this ab-
</bodyText>
<page confidence="0.987591">
18
</page>
<bodyText confidence="0.999627727272727">
straction feature allows us to reason about ever higher abstractions in the
same medium.
Another approach that closely resembles ours but is focussed on C++
only is ASTLOG [Cre97]. Like SOUL, it is a logic programming language
that reasons directly about user-de ned objects and provides second order
abstraction capabilities. ASTLOG introduces a notion of current object.
While this is not by itself an increase in expressivity, the authors claim
that it allows a distinct style of logic programming suited very well to enu-
merating tree-like structures. However, for performance reasons, ASTLOG
removes the ability to add or remove clauses dynamically, which in turn re-
moves many higher-order logical features. In SOUL we have not made this
restriction because we feel that it could limit the expressiveness.
Law Governed Architecture (LGA) [Min96, MP97] expresses and enforces
regularities of software architectures using Prolog as reasoning engine. Not
only an object-oriented language like Ei el is supported, but also Prolog
itself. Because the focus is explicitly on architectures and collaborations,
only exchange of messages is regulated by the laws. This di ers from our
approach that allows styles to be expressed using the complete parse tree and
abstractions thereof. An advantage of LGA however is its support for both
static and dynamic enforcement, while our approach is currently limited to
static reasoning over the source code. Dynamic reasoning is an important
feature that we certainly want to look into.
</bodyText>
<sectionHeader confidence="0.996764" genericHeader="method">
7 Future Work
</sectionHeader>
<bodyText confidence="0.999757125">
One of the interesting topics we are currently working on is the integration
with other data sources, such as other base languages, case tools or archi-
tectural description languages. This would allow rules that can check not
only the source code and abstractions thereof, but also other existing higher
level abstractions.
We are also working to integrate other `rule solvers&amp;apos; in our approach,
such as simple but more ecient pattern matching, regular expressions and
forward chaining algorithms. Such language extensions guarantee the power
</bodyText>
<page confidence="0.992472">
19
</page>
<bodyText confidence="0.999246142857143">
and expressiveness one expects from a logic programming language, com-
bined with faster query solving techniques.
Another interesting topic is generation of source code. Amongst oth-
ers, we would like to investigate how code generation could be used for
transforming code. For example, when detecting that a domain class in the
persistency layer forgot to implement a default mapping, one could be gen-
erated (semi-)automatically based on the software development style used.
</bodyText>
<sectionHeader confidence="0.996588" genericHeader="conclusions">
8 Conclusion
</sectionHeader>
<bodyText confidence="0.9996503">
This paper presents a rst step towards explicit support for software de-
velopment styles throughout the complete life cycle. It proposes not only
a formalism to express software development styles, but also claims that
these styles should be usable to query the source code, to do conformance
checking against the source code and to enforce software development styles
in the source code. These claims were validated on a real-world case us-
ing an experimental environment integrated in VisualWorks Smalltalk. We
hope that this contribution will spark more research in general approaches
integrated with development environments to express and support software
development styles throughout the software life cycle.
</bodyText>
<sectionHeader confidence="0.995711" genericHeader="acknowledgments">
9 Acknowledgments
</sectionHeader>
<bodyText confidence="0.941121">
We like to thank the software engineers at MediaGeniX, especially Koen De
</bodyText>
<reference confidence="0.8543804">
Hondt, Mark Plas and Wilfried Verachtert for the case and their patience
explaining it. We also take this opportunity to thank our colleagues at the
Programming Technology Lab for their support, discussions and proofread-
ing: Wolfgang De Meuter, Kris De Volder, Carine Lucas, Tom Mens, Tom
Tourwe and Bart Wouters.
</reference>
<page confidence="0.981422">
20
</page>
<sectionHeader confidence="0.971132" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999838192307692">
[Bal96] R. Balzer. Enforcing architecture constraints. In Second In-
ternational Software Architecture Workshop (ISAW-2), October
1996.
[Bec97] K. Beck. Smalltalk Best Practice Patterns. Prentice Hall, 1997.
[BMR+96] F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and
M. Stal. Pattern-Oriented Software Architecture  |A System of
Patterns. John Wiley &amp; Sons, 1996.
[Bok99] B. Bokowski. Co eestrainer: Statically-checked constraints on
the de nition and use of types in java. Technical report, Freie
Universitat Berlin, 1999. submitted to ESSEC&amp;apos;99.
[Bos97] Jan Bosch. Specifying frameworks and design patterns as ar-
chitectural fragments. Technical report, University of Karl-
skrona/Ronneby, 1997.
[CHSV97] W. Codenie, K. De Hondt, P. Steyaert, and A. Vercammen.
Evolving custom-made applications into domain-speci c frame-
works. Communications of the ACM, 40:71{77, October 1997.
[Cop98] James O. Coplien. C++ idioms. In P. Dyson J. Coldewey,
editor, Proceedings of the Third European Conference on Pattern
Languages of Programming, 1998. To be published.
[Cre97] Roger F. Crew. Astlog: A language for examining abstract syn-
tax trees. In Proceedings of the USENIX Conference on Domain-
Speci c Languages, 1997.
[FMvW97] Gert Florijn, Marco Meijers, and Pieter van Winsen. Tool
support for object-oriented patterns. In Mehmet Aksit and
Satoshi Matsuoka, editors, ECOOP&amp;apos;97|Object-Oriented Pro-
gramming, 11th European Conference, volume 1241 of Lecture
</reference>
<page confidence="0.957219">
21
</page>
<reference confidence="0.99898837037037">
Notes in Computer Science, pages 472{495, Jyvaskyla, Finland,
9{13 June 1997. Springer.
[GHJV94] E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Pat-
terns. Addisson-Wesley, 1994.
[HHG90] R. Helm, I.M. Holland, and D. Gangopadhyay. Contracts: Spe-
cifying behavioral compositions in object-oriented systems. In
ECOOP/OOPSLA&amp;apos;90 Proceedings. ACM Press, 1990.
[KKS96] N. Klarlund, J. Koistinen, and M. Schwartzbach. Formal de-
sign constraints. In Proceedings OOPSLA &amp;apos;96, ACM SIGPLAN
Notices, pages 370{383, 1996.
[Lew95] S. Lewis. The art and science of Smalltalk. Hewlett-Packard
professional books, 1995.
[MDR93] Scott Meyers, Carolyn K. Duby, and Steven P. Reiss. Constrain-
ing the structure and style of object-oriented programs. Techni-
cal Report CS-93-12, Department of Computer Science, Brown
University, Box 1910, Providence, RI 02912, April 1993.
[Min96] Naftaly H. Minsky. Law-governed regularities in object systems,
part 1: An abstract model. Theory and Practice of Object Sys-
tems, 2(4):283{301, 1996.
[MP97] Naftaly H. Minsky and Partha Pratim Pal. Law-governed reg-
ularities in object systems, part 2: A concrete implementation.
Theory and Practice of Object Systems, 3(2):87{101, 1997.
[MW99] K. Mens and R. Wuyts. Declaratively codifying software archi-
tectures using virtual software classi cations. In Proceedings of
TOOLS-Europe 99, June 1999.
[OMG97] OMG document ad/97-08-08. Object Constraint Language Spec-
i cations, version 1.1, September 1997.
</reference>
<page confidence="0.940157">
22
</page>
<reference confidence="0.999724875">
[Pre94] W. Pree. Design Patterns for Object-Oriented Software Devel-
opment. Addisson-Wesley, 1994.
[RBJO96] D. Roberts, J. Brant, R. Johnson, and B. Opdyke. An automated
refactoring tool. In Proceedings of ICAST &amp;apos;96, Chicago, IL, April
1996.
[SG96] M. Shaw and D. Garlan. Software Architecture  |Perspectives
on an Emerging Discipline. Prentice Hall, 1996.
[SSWA96] R. W. Schwanke, V. A. Strack, and T. Werthmann-Auzinger.
Industrial software architecture with gestalt. In Proceedings of
IWSSD-8. IEEE, 1996.
[VV96] A. Vercammen and W. Verachtert. Psi: From custom developed
application to domain speci c framework. In Addendum to the
proceedings of OOPSLA &amp;apos;96, 1996.
[Wuy98] R. Wuyts. Declarative reasoning about the structure of object-
oriented systems. In Proceedings TOOLS USA&amp;apos;98, IEEE Com-
puter Society Press, pages 112{124, 1998.
</reference>
<page confidence="0.999245">
23
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.943543">
<title confidence="0.9879625">Explicit Support for Software Development Styles throughout the Complete Life Cycle</title>
<author confidence="0.996323">Roel Wuyts</author>
<author confidence="0.996323">Kim Mensy</author>
<author confidence="0.996323">Theo D&amp;apos;Hondt</author>
<affiliation confidence="0.995382">Programming Technology Lab Vrije Universiteit Brussel</affiliation>
<address confidence="0.99852">Pleinlaan 2, 1050 Brussel, Belgium</address>
<email confidence="0.991187">e-mail:frwuytsjkimmensjtjdhondtg@vub.ac.be</email>
<date confidence="0.993744">April 1st, 1999</date>
<abstract confidence="0.999385083333333">Throughout its entire life cycle software development is subject to many rules constraining and guiding construction of software systems. Examples are best-practice patterns, idioms, coding conventions, design guidelines, architectural patterns, etc. Although such regulations are widely used, their usage is currently implicit or ad-hoc, and most software development environments do not explicitly support them. We present an approach to declare explicitly software development styles in an open declarative system that allows querying, conformance checking and enforcement of these declarations on the source code. We validate the approach by expressing and supporting several software development styles in a real-world case.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>Mark Hondt</author>
</authors>
<title>Plas and Wilfried Verachtert for the case and their patience explaining it. We also take this opportunity to thank our colleagues at the Programming Technology Lab for their support, discussions and proofreading: Wolfgang De Meuter, Kris De Volder, Carine Lucas, Tom Mens, Tom Tourwe and Bart Wouters.</title>
<marker>Hondt, </marker>
<rawString> Hondt, Mark Plas and Wilfried Verachtert for the case and their patience explaining it. We also take this opportunity to thank our colleagues at the Programming Technology Lab for their support, discussions and proofreading: Wolfgang De Meuter, Kris De Volder, Carine Lucas, Tom Mens, Tom Tourwe and Bart Wouters.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Balzer</author>
</authors>
<title>Enforcing architecture constraints.</title>
<date>1996</date>
<booktitle>In Second International Software Architecture Workshop (ISAW-2),</booktitle>
<marker>[Bal96]</marker>
<rawString>R. Balzer. Enforcing architecture constraints. In Second International Software Architecture Workshop (ISAW-2), October 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Beck</author>
</authors>
<title>Smalltalk Best Practice Patterns.</title>
<date>1997</date>
<publisher>Prentice Hall,</publisher>
<contexts>
<context position="3442" citStr="[Bec97]" startWordPosition="514" endWordPosition="514"> related and future work, and a conclusion. 2 Software Development Styles We de ne a software development style as a set of rules that constrain the structure a software system according to certain requirements (such as e- ciency, extensibility, . . . ). Literature provides di erent examples of software development styles, but mostly in speci c phases of the life-cycle: 1. implementation styles are widely encountered in di erent programming languages and systems. They include style guides that describe 2 what a `well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in c</context>
<context position="17969" citStr="[Bec97]" startWordPosition="2829" endWordPosition="2829">ramework becomes more stable, the rules will typically be enforced stronger. We will describe some example styles, namely that instance variables can only be accessed using accessor methods, that storage classes should provide default domain classes and vice versa, and that accessors of persistent classes use a very speci c form to cross the bridge safely. 4.3.1 Always use Accessor Methods Because of several reasons, such as hiding the interface from the implementation, there was a decision to use accessor methods consistently to access instance variables instead of manipulating them directly [Bec97]. While this is currently implicit, we could again make this software development style explicit and use it in tools so that violations could be tracked down or logged. As an example we will describe that a method ?method should never sent messages directly to instance variables (so the receivers ?receiver cannot be instance variables). Note that, in order to retrieve the instance variables of a class, we rst ask the method ?method for its class ?class. Rule usesNoInstVars(?method) if methodClass(?method, ?class), isSendTo(?receiver, ?message, ?method), not(instVar(?class, ?receiver)) 10 Once </context>
</contexts>
<marker>[Bec97]</marker>
<rawString>K. Beck. Smalltalk Best Practice Patterns. Prentice Hall, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Buschmann</author>
<author>R Meunier</author>
<author>H Rohnert</author>
<author>P Sommerlad</author>
<author>M Stal</author>
</authors>
<title>Pattern-Oriented Software Architecture |A System of Patterns.</title>
<date>1996</date>
<publisher>John Wiley &amp; Sons,</publisher>
<marker>[BMR+96]</marker>
<rawString>F. Buschmann, R. Meunier, H. Rohnert, P. Sommerlad, and M. Stal. Pattern-Oriented Software Architecture  |A System of Patterns. John Wiley &amp; Sons, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>B Bokowski</author>
</authors>
<title>Co eestrainer: Statically-checked constraints on the de nition and use of types in java.</title>
<date>1999</date>
<tech>Technical report,</tech>
<institution>Freie Universitat Berlin,</institution>
<note>submitted to ESSEC&amp;apos;99.</note>
<contexts>
<context position="1638" citStr="[Min96, MP97, Bok99, MDR93]" startWordPosition="226" endWordPosition="229">d case. 1 Introduction The software development process is strongly constrained by all kinds of implementation, design and architectural guidelines. Although the widespread Research conducted on a doctoral grant from the \Instituut ter bevordering van het Wetenschappelijk en Technologisch onderzoek in de Industrie&quot; (Flanders, Belgium). yResearch funded by the Brussels Capital Region (Belgium). 1 usage of software development styles throughout the life-cycle, general support is almost nonexistent in current day development environments. The few systems that allow the usage of such rules (like [Min96, MP97, Bok99, MDR93]) target one phase only in the development cycle (implementation, design or architectural), as we will see in the next section. While these systems are an important rst step, we claim that general support is needed for  declaring software development styles explicitly in all phases of the lifecycle and on all levels of abstraction in one and the same formalism.  supporting these software development styles to allow enforcing and compliance checking to the source code. We propose a declarative formalism to express all software development styles, thereby making them explicit in a medium that </context>
<context position="3666" citStr="[Bok99]" startWordPosition="549" endWordPosition="549">ciency, extensibility, . . . ). Literature provides di erent examples of software development styles, but mostly in speci c phases of the life-cycle: 1. implementation styles are widely encountered in di erent programming languages and systems. They include style guides that describe 2 what a `well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description languages, architectural constraint languages and architectural patterns [SG96, SSWA96, Bal96, BMR+96]. The major di erence with our approach is that they focus on architecture alone, wh</context>
<context position="28889" citStr="[Bok99]" startWordPosition="4512" endWordPosition="4512"> explicitly and supports querying, conformance checking and enforcement of these styles to the source code. In this section we will summarize some related approaches, and dis6This was measured for the persistency layer containing 143 classes and 431 methods on a G3-250 Mhz Macintosh and a Pentium-II 300 Mhz PC. 17 cuss similarities and di erences. We have subdivided the approaches in two groups depending on whether or not they use a declarative language. 6.1 Non-declarative Languages There are a number of approaches that propose non-declarative constraint languages. For example, Co eestrainer [Bok99] is a Java preprocessor where constraints can be added that reason about an annotated parse tree. The constraints are expressed in Java. While there are arguments in favor of this approach (such as the developers not needing to learn a new language), we feel that there are more drawbacks than advantages, as mentioned in section 2. Other approaches propose languages that are not as powerful as declarative languages. An example is Smalltalk Lint [RBJO96], a regular expression like language that allows to check for common programming mistakes in Smalltalk (such as its famous C predecessor). While</context>
</contexts>
<marker>[Bok99]</marker>
<rawString>B. Bokowski. Co eestrainer: Statically-checked constraints on the de nition and use of types in java. Technical report, Freie Universitat Berlin, 1999. submitted to ESSEC&amp;apos;99.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jan Bosch</author>
</authors>
<title>Specifying frameworks and design patterns as architectural fragments.</title>
<date>1997</date>
<tech>Technical report,</tech>
<institution>University of Karlskrona/Ronneby,</institution>
<contexts>
<context position="3900" citStr="[FMvW97, Bos97]" startWordPosition="585" endWordPosition="586">uages and systems. They include style guides that describe 2 what a `well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description languages, architectural constraint languages and architectural patterns [SG96, SSWA96, Bal96, BMR+96]. The major di erence with our approach is that they focus on architecture alone, while we propose a uni ed formalism that can be used for all kinds of software development styles. Another important example is law governed architectures (LGA) [Min96]; we will discuss this in more detail in section 6. Both this relate</context>
</contexts>
<marker>[Bos97]</marker>
<rawString>Jan Bosch. Specifying frameworks and design patterns as architectural fragments. Technical report, University of Karlskrona/Ronneby, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Codenie</author>
<author>K De Hondt</author>
<author>P Steyaert</author>
<author>A Vercammen</author>
</authors>
<title>Evolving custom-made applications into domain-speci c frameworks.</title>
<date>1997</date>
<journal>Communications of the ACM,</journal>
<pages>40--71</pages>
<contexts>
<context position="9845" citStr="[CHSV97, VV96]" startWordPosition="1534" endWordPosition="1535">strongly enforced. Progressively, as the framework matures, conformance to the existing guidelines becomes more and more important. Once 5 RefinedAbstraction ConcreteImplementor OperationImp Operation Abstraction OperationImp Implementoraggr Figure 1: Bridge Pattern Structure in the maintenance phase, violations of the software development styles are not allowed any longer. We will now start by introducing the case, and afterwards the examples in the two cycles. 4.1 Case: The Persistency Layer The case we use is the persistency layer1, part of a planning application for broadcasting companies [CHSV97, VV96]. It allows the storage of objects in Smalltalk in a relational database, transparently supports di erent relational databases that can be changed at runtime, and supports di erent mappings from objects on relational tables. The persistency layer was developed in house because persistency layers with these features were not available at the time. The core of the persistency layer is a bridge architecture (see picture 1) that permits di erent useful mapping strategies to map objects on rows and tables in a relational database. The bridge is responsible for mapping the high-level domain objects </context>
</contexts>
<marker>[CHSV97]</marker>
<rawString>W. Codenie, K. De Hondt, P. Steyaert, and A. Vercammen. Evolving custom-made applications into domain-speci c frameworks. Communications of the ACM, 40:71{77, October 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>James O Coplien</author>
</authors>
<title>C++ idioms. In</title>
<date>1998</date>
<booktitle>Proceedings of the Third European Conference on Pattern Languages of Programming,</booktitle>
<editor>P. Dyson J. Coldewey, editor,</editor>
<note>To be published.</note>
<contexts>
<context position="3503" citStr="[Cop98]" startWordPosition="522" endWordPosition="522">pment Styles We de ne a software development style as a set of rules that constrain the structure a software system according to certain requirements (such as e- ciency, extensibility, . . . ). Literature provides di erent examples of software development styles, but mostly in speci c phases of the life-cycle: 1. implementation styles are widely encountered in di erent programming languages and systems. They include style guides that describe 2 what a `well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description languages, architectura</context>
</contexts>
<marker>[Cop98]</marker>
<rawString>James O. Coplien. C++ idioms. In P. Dyson J. Coldewey, editor, Proceedings of the Third European Conference on Pattern Languages of Programming, 1998. To be published.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Roger F Crew</author>
</authors>
<title>Astlog: A language for examining abstract syntax trees.</title>
<date>1997</date>
<booktitle>In Proceedings of the USENIX Conference on DomainSpeci c Languages,</booktitle>
<contexts>
<context position="30773" citStr="[Cre97]" startWordPosition="4815" endWordPosition="4815">rely serve as structured comment. 6.2 Declarative Languages CCEL [MDR93] is a constraint language for use with C++ that allows one to express programmer-de ned constraints on the structure. The constraint language however is limited and does not allow to make abstractions. This means we are not able to construct constraints referencing or building on other constraints. We consider this a serious shortcoming, since this ab18 straction feature allows us to reason about ever higher abstractions in the same medium. Another approach that closely resembles ours but is focussed on C++ only is ASTLOG [Cre97]. Like SOUL, it is a logic programming language that reasons directly about user-de ned objects and provides second order abstraction capabilities. ASTLOG introduces a notion of current object. While this is not by itself an increase in expressivity, the authors claim that it allows a distinct style of logic programming suited very well to enumerating tree-like structures. However, for performance reasons, ASTLOG removes the ability to add or remove clauses dynamically, which in turn removes many higher-order logical features. In SOUL we have not made this restriction because we feel that it c</context>
</contexts>
<marker>[Cre97]</marker>
<rawString>Roger F. Crew. Astlog: A language for examining abstract syntax trees. In Proceedings of the USENIX Conference on DomainSpeci c Languages, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gert Florijn</author>
<author>Marco Meijers</author>
<author>Pieter van Winsen</author>
</authors>
<title>Tool support for object-oriented patterns.</title>
<date>1997</date>
<booktitle>In Mehmet Aksit and Satoshi Matsuoka, editors, ECOOP&amp;apos;97|Object-Oriented Programming, 11th European Conference,</booktitle>
<volume>1241</volume>
<pages>472--495</pages>
<publisher>Springer.</publisher>
<location>Jyvaskyla, Finland, 9{13</location>
<contexts>
<context position="3900" citStr="[FMvW97, Bos97]" startWordPosition="585" endWordPosition="586">uages and systems. They include style guides that describe 2 what a `well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description languages, architectural constraint languages and architectural patterns [SG96, SSWA96, Bal96, BMR+96]. The major di erence with our approach is that they focus on architecture alone, while we propose a uni ed formalism that can be used for all kinds of software development styles. Another important example is law governed architectures (LGA) [Min96]; we will discuss this in more detail in section 6. Both this relate</context>
</contexts>
<marker>[FMvW97]</marker>
<rawString>Gert Florijn, Marco Meijers, and Pieter van Winsen. Tool support for object-oriented patterns. In Mehmet Aksit and Satoshi Matsuoka, editors, ECOOP&amp;apos;97|Object-Oriented Programming, 11th European Conference, volume 1241 of Lecture Notes in Computer Science, pages 472{495, Jyvaskyla, Finland, 9{13 June 1997. Springer.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Gamma</author>
<author>R Helm</author>
<author>R Johnson</author>
<author>J Vlissides</author>
</authors>
<title>Design Patterns.</title>
<date>1994</date>
<publisher>Addisson-Wesley,</publisher>
<contexts>
<context position="3767" citStr="[GHJV94, Pre94]" startWordPosition="566" endWordPosition="567"> styles, but mostly in speci c phases of the life-cycle: 1. implementation styles are widely encountered in di erent programming languages and systems. They include style guides that describe 2 what a `well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description languages, architectural constraint languages and architectural patterns [SG96, SSWA96, Bal96, BMR+96]. The major di erence with our approach is that they focus on architecture alone, while we propose a uni ed formalism that can be used for all kinds of software development styles. Anot</context>
<context position="13011" citStr="[GHJV94]" startWordPosition="2050" endWordPosition="2050">convention rule. These are actually the examples that were given informally in section 2. 4.2.1 The Bridge Pattern From the analysis it was clear that the core of the persistency layer should be a bridge architecture to decouple the domain and the storage classes. It was also clear that persistent classes need to adhere to this structure at all times. In the original development this could not be expressed, let alone enforced. We will describe and use the software development style expressing this core architectural knowledge of the persistency layer. We rst have to express the bridge pattern [GHJV94] that relates the 7 domain classes and the storage classes. We will do this with a logical rule that describes the four participants of the bridge pattern and their relations (see also gure 1): the abstraction class, the implementor class, the re ned abstraction (subclass of the abstraction class) and the concrete implementor (subclass of the implementor class). The most important relation is the aggregation relation ?aggr between the abstraction class ?abs and the implementor class ?impl. This aggregation relation is used by the methods on the abstraction classes ?absMethod to call methods ?i</context>
<context position="19515" citStr="[GHJV94]" startWordPosition="3043" endWordPosition="3043">ethodToCheck)) This query will return true if all methods of persistent classes conform to the style, or false as soon as there is one that does not. While this is already interesting to check, we can provide more feedback to detect where the violations are. Next query for example will actually nd the classes and methods that violate the style: Query persistentClass(?classToCheck), method(?classToCheck, ?methodToCheck), not(usesNoInstVars(?methodToCheck)) 4.3.2 Default Domain and Storage Classes Another important decision was to provide default domain and storage classes using factory methods [GHJV94]. More speci cally, with each domain class must have a factory method returning a default storage class and vice versa. We can write a query to check for each class in the persistency layer whether it conforms to this structure. This is indeed very important because the bridge relies on these methods to have a default mapping. For every class ?storage in the storage hierarchy we check if it has a class factory method ?storMethod that creates a domain class ?domain. We then check if this associated domain class has a factory class method ?domMethod that references back the storage class. 11 Que</context>
</contexts>
<marker>[GHJV94]</marker>
<rawString>E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns. Addisson-Wesley, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Helm</author>
<author>I M Holland</author>
<author>D Gangopadhyay</author>
</authors>
<title>Contracts: Specifying behavioral compositions in object-oriented systems.</title>
<date>1990</date>
<booktitle>In ECOOP/OOPSLA&amp;apos;90 Proceedings.</booktitle>
<publisher>ACM Press,</publisher>
<contexts>
<context position="3960" citStr="[HHG90]" startWordPosition="595" endWordPosition="595">`well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description languages, architectural constraint languages and architectural patterns [SG96, SSWA96, Bal96, BMR+96]. The major di erence with our approach is that they focus on architecture alone, while we propose a uni ed formalism that can be used for all kinds of software development styles. Another important example is law governed architectures (LGA) [Min96]; we will discuss this in more detail in section 6. Both this related work and the experiences of our industrial partners motiva</context>
</contexts>
<marker>[HHG90]</marker>
<rawString>R. Helm, I.M. Holland, and D. Gangopadhyay. Contracts: Specifying behavioral compositions in object-oriented systems. In ECOOP/OOPSLA&amp;apos;90 Proceedings. ACM Press, 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Klarlund</author>
<author>J Koistinen</author>
<author>M Schwartzbach</author>
</authors>
<title>Formal design constraints.</title>
<date>1996</date>
<journal>ACM SIGPLAN Notices,</journal>
<booktitle>In Proceedings OOPSLA &amp;apos;96,</booktitle>
<pages>370--383</pages>
<contexts>
<context position="29709" citStr="[KKS96]" startWordPosition="4644" endWordPosition="4644">not needing to learn a new language), we feel that there are more drawbacks than advantages, as mentioned in section 2. Other approaches propose languages that are not as powerful as declarative languages. An example is Smalltalk Lint [RBJO96], a regular expression like language that allows to check for common programming mistakes in Smalltalk (such as its famous C predecessor). While it allows a certain level of reasoning about Smalltalk parse trees, we lack the abstraction facilities of a logic-like language that allows the expression of higher level abstractions. Yet another example is CDL [KKS96], the Constraint Description Language, targeted towards a very speci c domain and only allowing xed parse trees. Another category of languages are those that propose formalisms to describe constraints or rules about the structure of programs, but that lack a computable medium to check them. OCL [OMG97], the Object Constraint Language used in UML 1.1 is a good example. These languages can be used as a notation, but because they cannot be executed they merely serve as structured comment. 6.2 Declarative Languages CCEL [MDR93] is a constraint language for use with C++ that allows one to express p</context>
</contexts>
<marker>[KKS96]</marker>
<rawString>N. Klarlund, J. Koistinen, and M. Schwartzbach. Formal design constraints. In Proceedings OOPSLA &amp;apos;96, ACM SIGPLAN Notices, pages 370{383, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Lewis</author>
</authors>
<title>The art and science of Smalltalk. Hewlett-Packard professional books,</title>
<date>1995</date>
<contexts>
<context position="3484" citStr="[Lew95]" startWordPosition="519" endWordPosition="519">. 2 Software Development Styles We de ne a software development style as a set of rules that constrain the structure a software system according to certain requirements (such as e- ciency, extensibility, . . . ). Literature provides di erent examples of software development styles, but mostly in speci c phases of the life-cycle: 1. implementation styles are widely encountered in di erent programming languages and systems. They include style guides that describe 2 what a `well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description lang</context>
</contexts>
<marker>[Lew95]</marker>
<rawString>S. Lewis. The art and science of Smalltalk. Hewlett-Packard professional books, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Scott Meyers</author>
<author>Carolyn K Duby</author>
<author>Steven P Reiss</author>
</authors>
<title>Constraining the structure and style of object-oriented programs.</title>
<date>1910</date>
<tech>Technical Report CS-93-12,</tech>
<institution>Department of Computer Science, Brown University,</institution>
<location>Box</location>
<contexts>
<context position="1638" citStr="[Min96, MP97, Bok99, MDR93]" startWordPosition="226" endWordPosition="229">d case. 1 Introduction The software development process is strongly constrained by all kinds of implementation, design and architectural guidelines. Although the widespread Research conducted on a doctoral grant from the \Instituut ter bevordering van het Wetenschappelijk en Technologisch onderzoek in de Industrie&quot; (Flanders, Belgium). yResearch funded by the Brussels Capital Region (Belgium). 1 usage of software development styles throughout the life-cycle, general support is almost nonexistent in current day development environments. The few systems that allow the usage of such rules (like [Min96, MP97, Bok99, MDR93]) target one phase only in the development cycle (implementation, design or architectural), as we will see in the next section. While these systems are an important rst step, we claim that general support is needed for  declaring software development styles explicitly in all phases of the lifecycle and on all levels of abstraction in one and the same formalism.  supporting these software development styles to allow enforcing and compliance checking to the source code. We propose a declarative formalism to express all software development styles, thereby making them explicit in a medium that </context>
<context position="3655" citStr="[MDR93]" startWordPosition="547" endWordPosition="547">uch as e- ciency, extensibility, . . . ). Literature provides di erent examples of software development styles, but mostly in speci c phases of the life-cycle: 1. implementation styles are widely encountered in di erent programming languages and systems. They include style guides that describe 2 what a `well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description languages, architectural constraint languages and architectural patterns [SG96, SSWA96, Bal96, BMR+96]. The major di erence with our approach is that they focus on architectur</context>
<context position="30238" citStr="[MDR93]" startWordPosition="4729" endWordPosition="4729">he expression of higher level abstractions. Yet another example is CDL [KKS96], the Constraint Description Language, targeted towards a very speci c domain and only allowing xed parse trees. Another category of languages are those that propose formalisms to describe constraints or rules about the structure of programs, but that lack a computable medium to check them. OCL [OMG97], the Object Constraint Language used in UML 1.1 is a good example. These languages can be used as a notation, but because they cannot be executed they merely serve as structured comment. 6.2 Declarative Languages CCEL [MDR93] is a constraint language for use with C++ that allows one to express programmer-de ned constraints on the structure. The constraint language however is limited and does not allow to make abstractions. This means we are not able to construct constraints referencing or building on other constraints. We consider this a serious shortcoming, since this ab18 straction feature allows us to reason about ever higher abstractions in the same medium. Another approach that closely resembles ours but is focussed on C++ only is ASTLOG [Cre97]. Like SOUL, it is a logic programming language that reasons dire</context>
</contexts>
<marker>[MDR93]</marker>
<rawString>Scott Meyers, Carolyn K. Duby, and Steven P. Reiss. Constraining the structure and style of object-oriented programs. Technical Report CS-93-12, Department of Computer Science, Brown University, Box 1910, Providence, RI 02912, April 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Naftaly H Minsky</author>
</authors>
<title>Law-governed regularities in object systems, part 1: An abstract model.</title>
<date>1996</date>
<journal>Theory and Practice of Object Systems,</journal>
<volume>2</volume>
<issue>4</issue>
<contexts>
<context position="1638" citStr="[Min96, MP97, Bok99, MDR93]" startWordPosition="226" endWordPosition="229">d case. 1 Introduction The software development process is strongly constrained by all kinds of implementation, design and architectural guidelines. Although the widespread Research conducted on a doctoral grant from the \Instituut ter bevordering van het Wetenschappelijk en Technologisch onderzoek in de Industrie&quot; (Flanders, Belgium). yResearch funded by the Brussels Capital Region (Belgium). 1 usage of software development styles throughout the life-cycle, general support is almost nonexistent in current day development environments. The few systems that allow the usage of such rules (like [Min96, MP97, Bok99, MDR93]) target one phase only in the development cycle (implementation, design or architectural), as we will see in the next section. While these systems are an important rst step, we claim that general support is needed for  declaring software development styles explicitly in all phases of the lifecycle and on all levels of abstraction in one and the same formalism.  supporting these software development styles to allow enforcing and compliance checking to the source code. We propose a declarative formalism to express all software development styles, thereby making them explicit in a medium that </context>
<context position="4432" citStr="[Min96]" startWordPosition="666" endWordPosition="666">yle support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description languages, architectural constraint languages and architectural patterns [SG96, SSWA96, Bal96, BMR+96]. The major di erence with our approach is that they focus on architecture alone, while we propose a uni ed formalism that can be used for all kinds of software development styles. Another important example is law governed architectures (LGA) [Min96]; we will discuss this in more detail in section 6. Both this related work and the experiences of our industrial partners motivate the need and demand for expressing and supporting development styles at all levels of the software life-cycle. We were also struck by the commonalities in currently available approaches. Therefore, it would be bene cial to develop a uni ed approach in which all these styles can be expressed. With such an approach, developers only need to use one approach, minimizing the overhead of learning to work with it. Furthermore, all developed support tools are immediately a</context>
<context position="31449" citStr="[Min96, MP97]" startWordPosition="4918" endWordPosition="4919">rectly about user-de ned objects and provides second order abstraction capabilities. ASTLOG introduces a notion of current object. While this is not by itself an increase in expressivity, the authors claim that it allows a distinct style of logic programming suited very well to enumerating tree-like structures. However, for performance reasons, ASTLOG removes the ability to add or remove clauses dynamically, which in turn removes many higher-order logical features. In SOUL we have not made this restriction because we feel that it could limit the expressiveness. Law Governed Architecture (LGA) [Min96, MP97] expresses and enforces regularities of software architectures using Prolog as reasoning engine. Not only an object-oriented language like Ei el is supported, but also Prolog itself. Because the focus is explicitly on architectures and collaborations, only exchange of messages is regulated by the laws. This di ers from our approach that allows styles to be expressed using the complete parse tree and abstractions thereof. An advantage of LGA however is its support for both static and dynamic enforcement, while our approach is currently limited to static reasoning over the source code. Dynamic r</context>
</contexts>
<marker>[Min96]</marker>
<rawString>Naftaly H. Minsky. Law-governed regularities in object systems, part 1: An abstract model. Theory and Practice of Object Systems, 2(4):283{301, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Naftaly</author>
</authors>
<title>Minsky and Partha Pratim Pal. Law-governed regularities in object systems, part 2: A concrete implementation.</title>
<date>1997</date>
<journal>Theory and Practice of Object Systems,</journal>
<volume>3</volume>
<issue>2</issue>
<contexts>
<context position="1638" citStr="[Min96, MP97, Bok99, MDR93]" startWordPosition="226" endWordPosition="229">d case. 1 Introduction The software development process is strongly constrained by all kinds of implementation, design and architectural guidelines. Although the widespread Research conducted on a doctoral grant from the \Instituut ter bevordering van het Wetenschappelijk en Technologisch onderzoek in de Industrie&quot; (Flanders, Belgium). yResearch funded by the Brussels Capital Region (Belgium). 1 usage of software development styles throughout the life-cycle, general support is almost nonexistent in current day development environments. The few systems that allow the usage of such rules (like [Min96, MP97, Bok99, MDR93]) target one phase only in the development cycle (implementation, design or architectural), as we will see in the next section. While these systems are an important rst step, we claim that general support is needed for  declaring software development styles explicitly in all phases of the lifecycle and on all levels of abstraction in one and the same formalism.  supporting these software development styles to allow enforcing and compliance checking to the source code. We propose a declarative formalism to express all software development styles, thereby making them explicit in a medium that </context>
<context position="31449" citStr="[Min96, MP97]" startWordPosition="4918" endWordPosition="4919">rectly about user-de ned objects and provides second order abstraction capabilities. ASTLOG introduces a notion of current object. While this is not by itself an increase in expressivity, the authors claim that it allows a distinct style of logic programming suited very well to enumerating tree-like structures. However, for performance reasons, ASTLOG removes the ability to add or remove clauses dynamically, which in turn removes many higher-order logical features. In SOUL we have not made this restriction because we feel that it could limit the expressiveness. Law Governed Architecture (LGA) [Min96, MP97] expresses and enforces regularities of software architectures using Prolog as reasoning engine. Not only an object-oriented language like Ei el is supported, but also Prolog itself. Because the focus is explicitly on architectures and collaborations, only exchange of messages is regulated by the laws. This di ers from our approach that allows styles to be expressed using the complete parse tree and abstractions thereof. An advantage of LGA however is its support for both static and dynamic enforcement, while our approach is currently limited to static reasoning over the source code. Dynamic r</context>
</contexts>
<marker>[MP97]</marker>
<rawString>Naftaly H. Minsky and Partha Pratim Pal. Law-governed regularities in object systems, part 2: A concrete implementation. Theory and Practice of Object Systems, 3(2):87{101, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K Mens</author>
<author>R Wuyts</author>
</authors>
<title>Declaratively codifying software architectures using virtual software classi cations.</title>
<date>1999</date>
<booktitle>In Proceedings of TOOLS-Europe 99,</booktitle>
<contexts>
<context position="8211" citStr="[MW99]" startWordPosition="1282" endWordPosition="1282">larative framework of rules that allows reasoning at the implementation, design and architectural level was implemented in SOUL [Wuy98]. It can be seen as a layered structure, starting from a base-language dependent layer that maps to the basics of an object-oriented language. On top of this layer sits the basic structural layer that adds basic predicates directly related to the source code. Then higher level layers are available that describes higher level relationships, such as design patterns. Recently yet another layer was put on top of this that allows reasoning at an architectural level [MW99]. Using the declarative framework implemented in SOUL gives us a powerful medium to reason about structural information in an object-oriented language, while still providing the capability to check such structures against the source code. 4 Using explicit Software Development Styles In this section we give a concrete feeling on how to express concrete software development styles. We will do this using a real-world case, where we can express a number of software development styles that arose during development, and indicate how to use these styles in the development process. We will assume an i</context>
</contexts>
<marker>[MW99]</marker>
<rawString>K. Mens and R. Wuyts. Declaratively codifying software architectures using virtual software classi cations. In Proceedings of TOOLS-Europe 99, June 1999.</rawString>
</citation>
<citation valid="true">
<title>OMG document ad/97-08-08. Object Constraint Language Speci cations, version 1.1,</title>
<date>1997</date>
<contexts>
<context position="30012" citStr="[OMG97]" startWordPosition="4692" endWordPosition="4692">r common programming mistakes in Smalltalk (such as its famous C predecessor). While it allows a certain level of reasoning about Smalltalk parse trees, we lack the abstraction facilities of a logic-like language that allows the expression of higher level abstractions. Yet another example is CDL [KKS96], the Constraint Description Language, targeted towards a very speci c domain and only allowing xed parse trees. Another category of languages are those that propose formalisms to describe constraints or rules about the structure of programs, but that lack a computable medium to check them. OCL [OMG97], the Object Constraint Language used in UML 1.1 is a good example. These languages can be used as a notation, but because they cannot be executed they merely serve as structured comment. 6.2 Declarative Languages CCEL [MDR93] is a constraint language for use with C++ that allows one to express programmer-de ned constraints on the structure. The constraint language however is limited and does not allow to make abstractions. This means we are not able to construct constraints referencing or building on other constraints. We consider this a serious shortcoming, since this ab18 straction feature </context>
</contexts>
<marker>[OMG97]</marker>
<rawString>OMG document ad/97-08-08. Object Constraint Language Speci cations, version 1.1, September 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Pree</author>
</authors>
<title>Design Patterns for Object-Oriented Software Development.</title>
<date>1994</date>
<publisher>Addisson-Wesley,</publisher>
<contexts>
<context position="3767" citStr="[GHJV94, Pre94]" startWordPosition="566" endWordPosition="567"> styles, but mostly in speci c phases of the life-cycle: 1. implementation styles are widely encountered in di erent programming languages and systems. They include style guides that describe 2 what a `well-styled&amp;apos; program in a language looks like, for example bestpractice patterns [Bec97], general guidelines for Smalltalk [Lew95], or idioms [Cop98]. Although a lot of these rules are fairly simple to enforce or even check, almost no development environments do so. Exceptions are for example [MDR93] or [Bok99]. 2. design styles : the best known example in this phase is probably design patterns [GHJV94, Pre94]. Support for design patterns, let alone general design style support is virtually nonexistent. As exceptions we note [FMvW97, Bos97]. Another example of a design guideline is contracts [HHG90]. 3. architectural styles : work has been done in the architectural community in constructing architectural description languages, architectural constraint languages and architectural patterns [SG96, SSWA96, Bal96, BMR+96]. The major di erence with our approach is that they focus on architecture alone, while we propose a uni ed formalism that can be used for all kinds of software development styles. Anot</context>
</contexts>
<marker>[Pre94]</marker>
<rawString>W. Pree. Design Patterns for Object-Oriented Software Development. Addisson-Wesley, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Roberts</author>
<author>J Brant</author>
<author>R Johnson</author>
<author>B Opdyke</author>
</authors>
<title>An automated refactoring tool.</title>
<date>1996</date>
<booktitle>In Proceedings of ICAST &amp;apos;96,</booktitle>
<location>Chicago, IL,</location>
<contexts>
<context position="29345" citStr="[RBJO96]" startWordPosition="4587" endWordPosition="4587">ge. 6.1 Non-declarative Languages There are a number of approaches that propose non-declarative constraint languages. For example, Co eestrainer [Bok99] is a Java preprocessor where constraints can be added that reason about an annotated parse tree. The constraints are expressed in Java. While there are arguments in favor of this approach (such as the developers not needing to learn a new language), we feel that there are more drawbacks than advantages, as mentioned in section 2. Other approaches propose languages that are not as powerful as declarative languages. An example is Smalltalk Lint [RBJO96], a regular expression like language that allows to check for common programming mistakes in Smalltalk (such as its famous C predecessor). While it allows a certain level of reasoning about Smalltalk parse trees, we lack the abstraction facilities of a logic-like language that allows the expression of higher level abstractions. Yet another example is CDL [KKS96], the Constraint Description Language, targeted towards a very speci c domain and only allowing xed parse trees. Another category of languages are those that propose formalisms to describe constraints or rules about the structure of pro</context>
</contexts>
<marker>[RBJO96]</marker>
<rawString>D. Roberts, J. Brant, R. Johnson, and B. Opdyke. An automated refactoring tool. In Proceedings of ICAST &amp;apos;96, Chicago, IL, April 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Shaw</author>
<author>D Garlan</author>
</authors>
<title>Software Architecture |Perspectives on an Emerging Discipline.</title>
<date>1996</date>
<publisher>Prentice Hall,</publisher>
<marker>[SG96]</marker>
<rawString>M. Shaw and D. Garlan. Software Architecture  |Perspectives on an Emerging Discipline. Prentice Hall, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R W Schwanke</author>
<author>V A Strack</author>
<author>T Werthmann-Auzinger</author>
</authors>
<title>Industrial software architecture with gestalt.</title>
<date>1996</date>
<booktitle>In Proceedings of IWSSD-8.</booktitle>
<publisher>IEEE,</publisher>
<marker>[SSWA96]</marker>
<rawString>R. W. Schwanke, V. A. Strack, and T. Werthmann-Auzinger. Industrial software architecture with gestalt. In Proceedings of IWSSD-8. IEEE, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Vercammen</author>
<author>W Verachtert</author>
</authors>
<title>Psi: From custom developed application to domain speci c framework.</title>
<date>1996</date>
<booktitle>In Addendum to the proceedings of OOPSLA &amp;apos;96,</booktitle>
<contexts>
<context position="9845" citStr="[CHSV97, VV96]" startWordPosition="1534" endWordPosition="1535">strongly enforced. Progressively, as the framework matures, conformance to the existing guidelines becomes more and more important. Once 5 RefinedAbstraction ConcreteImplementor OperationImp Operation Abstraction OperationImp Implementoraggr Figure 1: Bridge Pattern Structure in the maintenance phase, violations of the software development styles are not allowed any longer. We will now start by introducing the case, and afterwards the examples in the two cycles. 4.1 Case: The Persistency Layer The case we use is the persistency layer1, part of a planning application for broadcasting companies [CHSV97, VV96]. It allows the storage of objects in Smalltalk in a relational database, transparently supports di erent relational databases that can be changed at runtime, and supports di erent mappings from objects on relational tables. The persistency layer was developed in house because persistency layers with these features were not available at the time. The core of the persistency layer is a bridge architecture (see picture 1) that permits di erent useful mapping strategies to map objects on rows and tables in a relational database. The bridge is responsible for mapping the high-level domain objects </context>
</contexts>
<marker>[VV96]</marker>
<rawString>A. Vercammen and W. Verachtert. Psi: From custom developed application to domain speci c framework. In Addendum to the proceedings of OOPSLA &amp;apos;96, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Wuyts</author>
</authors>
<title>Declarative reasoning about the structure of objectoriented systems.</title>
<date>1998</date>
<booktitle>In Proceedings TOOLS USA&amp;apos;98, IEEE</booktitle>
<pages>112--124</pages>
<publisher>Computer Society Press,</publisher>
<contexts>
<context position="6684" citStr="[Wuy98]" startWordPosition="1044" endWordPosition="1044">e medium we used for our experiments, we give two informal examples of software development styles that we will describe explicitly later on in the experiments section. The rst is application speci c, while the other is an example of a naming convention: 1. A bridge pattern will be used as the core design element in the persistency layer. Every class that needs to be persistent should conform to this pattern. 2. Methods returning booleans should be pre xed with `is&amp;apos;. 3 Smalltalk Open Uni cation Language In the experiments for this paper we have used SOUL (Smalltalk Open Uni - cation Language) [Wuy98] to declare software development styles, and tools based on SOUL for querying source code, for doing conformance checking and for enforcement of styles. SOUL is PROLOG-like, but has an extension that allows uni cation on user-de ned elements. This lets logical clauses directly reference elements from the base language (such as classes, inheritance relations, method bodies, . . . ), avoiding the overhead of constructing and maintaining a separate repository containing the source code. Another feature are the second-order predicates that allow easy manipulation of lists. While SOUL itself is imp</context>
</contexts>
<marker>[Wuy98]</marker>
<rawString>R. Wuyts. Declarative reasoning about the structure of objectoriented systems. In Proceedings TOOLS USA&amp;apos;98, IEEE Computer Society Press, pages 112{124, 1998.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>