<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.7438195">
Design Guidelines for
Tailorable Frameworks 1
</title>
<author confidence="0.983653">
Serge Demeyer,* Theo Dirk Meijler,† Oscar Nierstrasz,* Patrick Steyaert‡
</author>
<affiliation confidence="0.845172">
*Software Composition Group, University of Berne, Switzerland.
</affiliation>
<author confidence="0.475687">
†Baan Development, Ede, The Netherlands.
</author>
<affiliation confidence="0.587546">
‡Programmin Technology Lab, &quot;Vrije Universiteit Brussel&quot;, Brussels, Belgium.
</affiliation>
<bodyText confidence="0.988468125">
Since the early 1980s, object-oriented frameworks have demonstrated that programmers can
encapsulate a reusable, tailorable software architecture as a collection of collaborating, exten-
sible object classes. Such frameworks are particularly important for developing open systems
in which not only functionality but architecture is reused across a family of related applications.
Unfortunately, the design of frameworks remains an art rather than a science, because of the in-
herent conflict between reuse — packaging software components that can be reused in as many
contexts as possible — and tailorability — designing software architectures easily adapted to
target requirements.
To cope with this conflict, well-designed OO frameworks must provide a clean conceptual
framework that clearly identifies hot spots[6]; where tailorability is necessary and desirable
and specifies framework contracts[1] that formalize exactly which parts of the framework are
to be reused. This article presents three design guidelines that help identify hot spots and con-
tracts, thereby balancing flexibility and tailorability.
Tailorable frameworks are particularly useful for the construction of so-called open systems.
There exist various viewpoints on what precisely makes a system “open”, a discussion beyond
the scope of this article. For our purposes, the following open system requirements are suffi-
</bodyText>
<listItem confidence="0.953922625">
cient.
• Interoperability: Open systems typically run on heterogeneous hardware and software
platforms. Platform differences should be encapsulated in the system architecture to ease
integration.
• Distribution: Open systems are physically distributed. Coordinating distributed services
is nontrivial and requires reliable services. An open system guarantees the correct exe-
cution of system critical functions.
• Extensibility: Most open systems provide some form of extensibility, allowing end us-
</listItem>
<bodyText confidence="0.8199164">
ers to customize the system to address special needs. End-user customization requires the
system’s configuration to be adaptable without changing the internal implementation of
existing system modules.
To cope with these requirements, we ask system designers to identify the axes of variability
for their open system. Based on these axes, we specify the following three guidelines for de-
</bodyText>
<listItem confidence="0.938262">
1. Communications of the ACM, vol. 40, no. 10, ACM Press, October 1997, pp. 60-64.
</listItem>
<author confidence="0.452085">
Serge Demeyer, Theo Dirk Meijler, Oscar Nierstrasz, Patrick Steyaert 2.signing an open system architecture (each design guideline introduces an extra level of tailora-
</author>
<bodyText confidence="0.976505620689655">
bility for addressing an open system requirement).
Guideline 1 [Interoperability] Include in the design separate “axis-objects” so each such ob-
ject represents a point on one of the axes of variability, thus encapsulating a degree of plat-
form independence. Objects in the initial system model must delegate responsibilities to the
axis objects.
Guideline 2 [Distribution] Specify a framework contract for each of the variability axes. Ex-
tend the framework design with a “contract object” guaranteeing the correct execution of the
corresponding contract.
Guideline 3 [Extensibility] Introduce a global “configuration object” representing the system
configuration. By replacing that configuration object, an OO programmer can adapt the sys-
tem’s configuration without changing the implementation of the other objects.
To illustrate the practical value of the guidelines, the rest of this article explores their applica-
tion to the concrete architecture of an open hypermedia system (see http://www.csdl.tamu.edu/
ohs/). We stress that this is only an example and we refer readers to [2] for a discussion on the
guidelines’ general applicability. We also point out that such system is necessarily complicated,
as it deals with difficult issues that cannot be illustrated with toy examples; we provide clarify-
ing diagrams wherever possible.1
To apply the guidelines, we assume the existence of an initial model for the intended open
system. Identification of the entities in such an initial model is another issue beyond the scope
of this article but methodologies like Objectory’s Use Cases[4] provide excellent support in
this area.
Figure 1 shows the class structure of an initial
open hypermedia system model, including a
Document class, holding some contents in a
certain multi-media format (e.g., HTML, GIF).
A document also contains a number of An-
chors representing the parts of a document that
may be used as the source or target of a naviga-
tion operation. An anchor has a value that
</bodyText>
<listItem confidence="0.669958333333333">
uniquely identifies it within the associated docu-
ment contents (e.g., the position in a text, rectangle in a bitmap).
1. All the diagrams employ the notation of the Unified Modelling Language (UML).
</listItem>
<figureCaption confidence="0.626966">
Figure 1 Initial Model for an Open
</figureCaption>
<figure confidence="0.735303833333333">
Hypermedia System
Document Anchor
edit() activate()
highlight()
select()
contents value
</figure>
<listItem confidence="0.757881666666667">
3. Design Guidelines for Tailorable FrameworksThe Document and Anchor classes are two of the
hot spots; tailoring the framework to the needs of the
open hypermedia system, system designers must pro-
</listItem>
<bodyText confidence="0.946259454545455">
vide the appropriate subclasses. However, these sub-
classes must respect the fundamental rules of the
framework, specified in the framework contract (see fig-
ure 2). Assuming the precondition of a displayed docu-
ment whereby every contained anchor is highlighted, an
activation of one of these anchors (activate) com-
putes the target document and anchor of the correspond-
ing navigation relationship, opens the document
(edit), highlights the contained anchors (high-
light) and finally selects (select) the target anchor
within that a document.
</bodyText>
<subsectionHeader confidence="0.543122">
Axes of Variability
</subsectionHeader>
<bodyText confidence="0.993516588235294">
To turn an initial system model into an architecture for
an open system, designers should first identify the axes of variability. How to do this is also be-
yond the scope of this article, so we again refer to well-known OO methods like Objectory[4]
and OORAM[5].
For our open hypermedia system, we propose three impor-
tant varying characteristics: storage (how hypermedia docu-
ments are stored — in, say, http, ftp or a file), presentation
(how they are viewed — through, say a browser or JPEG
viewer); and navigation (how they may be linked — by, say,
embedded references, CGI-scripts). Based on this analysis,
figure 3 shows the three variability axes: the storage axis,
enumerating all possible document repositories; the presen-
tation axis, enumerating all possible viewer applications; and
the navigation axis enumerating all possible kinds of linking
relationships.
We now turn to the question how to incorporate these axes of variability into a tailorable
framework architecture.
</bodyText>
<figure confidence="0.8880164">
highlight()
Figure 2 The initial framework
contract
containedAnchors
sourceAnchor
targetDocument
activate()
edit()
targetAnchor
select()
</figure>
<figureCaption confidence="0.736193">
Figure 3 The hypermedia
</figureCaption>
<figure confidence="0.579197">
axes of variability
Presentation
Storage
Navigation
</figure>
<author confidence="0.462976">
Serge Demeyer, Theo Dirk Meijler, Oscar Nierstrasz, Patrick Steyaert 4.The Interoperability
</author>
<subsectionHeader confidence="0.590534">
Requirement
</subsectionHeader>
<bodyText confidence="0.9982439375">
The application of the first guideline introduces three new classes (see figure 4): one for the
storage axis (Loader), one for the presentation axis (Editor), and one for the navigation axis
(Resolver). These extra classes yield three hot spots for the hypermedia framework. By in-
troducing these hot spots, we must split the initial framework contract into three finer-grained
contracts. The navigation contract (see figure 5) states that an anchor receiving the acti-
vate message, must send a resolveToDocument message to the associated resolver to cre-
ate the target document and display it to the user (edit); afterward, the activated anchor must
create (resolveToAnchor) and select (select) the target location. The storage contract
states that a document receiving the edit message, must send a load message to the associ-
ated loader to ensure that the document contents are properly loaded from the storage device
and that all associated anchors are created. The presentation contract states that a document re-
ceiving the edit message must — after being loaded — send an edit message to the associ-
ated editor to display the contents to the end user and highlight all the anchors.
Having applied the first design guideline, the document and anchor objects in the initial hy-
permedia model delegate the variant behaviour to the corresponding axis objects—resolv-
er, loader, editor. This way, all platform-dependent aspects are encapsulated into the axis
</bodyText>
<figureCaption confidence="0.659323">
objects, thus addressing the interoperability requirement.
Figure 5 The Navigation contract
</figureCaption>
<figure confidence="0.947871818181818">
sourceAnchor
targetDocument
activate()
edit()
resolver
resolveToDocument(
sourceAnchor)
targetAnchor
select()
resolveToAnchor(
sourceAnchor)
</figure>
<figureCaption confidence="0.977564">
Figure 4 Resolver, Editor and Loader
classes, representing the variability axes
</figureCaption>
<figure confidence="0.933780684210526">
Anchor
activate()
highlight()
select()
Document
edit()
Resolver
resolveToDocument (anchor)
✽
Loader
load(document)
Editor
edit(document)
✽ ✽
contents value
resolveToAnchor (anchor)
5. Design Guidelines for Tailorable FrameworksThe Distribution Requirement
Reliability is crucial in a distributed system.
Crucial system services —log maintenance,
</figure>
<bodyText confidence="0.996763115384616">
locking, authority control— require the system
to monitor all activities of a certain kind and
perform additional checks and bookkeeping.
This requirement conflicts with the interopera-
bility and extensibility requirements, according
to which the system has to cooperate with ex-
ternal software and may be adapted at run time.
Guaranteeing reliable services in such a dy-
namic environment is difficult, but our second
guideline results in an architecture that moni-
tors crucial system services, independent of the
participating objects. We illustrate this need
through the problem of maintaining a log of all
navigation operations.
Figure 6 shows the result of applying the
second guideline for the navigation contract in
figure 5. Here, the path object takes complete
control of the execution of the navigation con-
tract, including an extra notification (activated) of the source anchor. This path object is a
hot spot of the framework, providing an ideal location for wrapping additional logging behav-
iour around the execution of the navigation operation, independent of the participating re-
solver, anchor and document objects. We similarly reify the storage contract and
guarantee that all read/write operations are monitored; such hot spot can be used to guarantee a
systemwide locking strategy. Also, the reified presentation contract can monitor all editing op-
erations and implement authority control. We conclude that applying the second guideline al-
lows us to monitor execution of system-critical services, addressing the need for reliability in
</bodyText>
<figureCaption confidence="0.5895655">
distributed systems.
Figure 6 The path object, representing the
</figureCaption>
<figure confidence="0.974924642857143">
navigation contract
path
targetDocument
activate(sourceAnchor)
edit()
resolver
resolveToDocument(
sourceAnchor)
targetAnchor
select()
resolveToAnchor(
sourceAnchor)
sourceAnchor
activated()
</figure>
<author confidence="0.683058">
Serge Demeyer, Theo Dirk Meijler, Oscar Nierstrasz, Patrick Steyaert 6.The Extensibility Requirement
</author>
<bodyText confidence="0.976356">
Rephrasing the third guideline, we must refactor all operations that determine the system con-
figuration into a single configuration object. In a system designed according to our guidelines,
these are all methods that create objects1 from the initial model (see figure 1) plus all the meth-
ods that make a connection between an object of the initial model and a contract object (the first
guideline). Figure 7 shows the result of applying the third guideline for the navigation contract.
When the path object receives the request for a navigation operation (activate), it asks the
hypermediacontext object to identify which resolver is supposed to handle the navi-
gation operation (determineResolver). This resolver is then asked to compute the tar-
gets of the navigation operation (resolveToDocSpec/resolveToAnchorSpec),
returning a document and anchor specifier. Each of these specifiers is passed to the hyperme-
diacontext object, which instantiates one of the existing Document (createDocu-
ment) or Anchor (createAnchor) classes. Similarly, there are two methods that decide on
the loader (determineLoader) or editor (determineEditor) that is supposed to
handle a document.
</bodyText>
<listItem confidence="0.77083">
1. To that extent, the configuration object behaves like an Abstract Factory [3]
</listItem>
<figureCaption confidence="0.994859">
Figure 7 hypermediacontext object, representing the system configuration
</figureCaption>
<figure confidence="0.99207175">
resolver
path hypermedia
contextactivate(anchor)
determineResolver(anchor)
resolveToDocument(anchor)
createDocument(docSpec)
resolveToDocSpec(anchor)
targetDocument
activated()
anchor
edit()
resolveToAnchor(anchor)
createAnchor(anchSpec)
resolveToAnchorSpec(anchor)
targetAnchor
select()
</figure>
<bodyText confidence="0.937640285714285">
7. Design Guidelines for Tailorable FrameworksThis single hypermedia context object provides the framework hot spot in which an OO pro-
grammer can tailor the system configuration without altering the rest of the system. Thus, the
third guideline addresses the extensibility requirement.
Conclusion
The proposed design guidelines cover only some of the state of the art in framework design. But
because of the way they are formulated, they fit nicely with the other techniques available today
—i.e., design patterns, open implementations, class refactoring—making them especially at-
tractive.
The fact that the guidelines provide concrete design solutions for such issues as interopera-
bility, extensibility and distribution makes them useful for coping with the growing demand for
openness. The search for more openness is inevitable in an environment in which software is
evolving dramatically and the World-Wide Web’s growing popularity means new technical re-
quirements every day. Since they build on our hypermedia experience, we are confident that
these guidelines, will address the needs of current and future generations of open systems.
</bodyText>
<sectionHeader confidence="0.992229" genericHeader="abstract">
References
</sectionHeader>
<reference confidence="0.994983285714286">
[1] Codenie, W., De Hondt, K., Steyaert, P., and Vercammen, A., Evolving Custom-Made Appli-
cations into Domain-Specific Frameworks. Communications of the ACM 40, 10 (October
1997).
[2] Demeyer, S. Zypher: Tailorability as a Link from Object-Oriented Software Engineering to
Open Hypermedia. Ph. D. dissertation, Vrije Universiteit Brussel, Department of Computer
Science, 1996 — Belgium.
See http://dinfwww.vub.ac.be/ and http://iamwww.unibe.ch/~demeyer/.
[3] Gamma, E., Helm, R., Johnson, R. and Vlissides, J. Design Patterns. Addison-Wesley, 1995.
[4] Jacobson, I. Object-Oriented Software Engineering, a Use Case Driven Approach. Addison-
Wesley, 1992.
[5] Reenskaug, T. and Wold, P. and Lehne, O. A. Working with Objects: The OOram Software
Engineering Method. Manning Publications, Greenwich CT, 1996.
[6] Schmid, H. A., Systematic Framework Design by Generalisation. Communications of the
ACM 40, 10 (October 1997).
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.026671">
<title confidence="0.967494">Design Guidelines for Tailorable Frameworks 1</title>
<author confidence="0.994181">Serge Demeyer</author>
<author confidence="0.994181">Theo Dirk Meijler</author>
<affiliation confidence="0.652575333333333">Software Composition Group, University of Berne, Switzerland. †Baan Development, Ede, The Netherlands. ‡Programmin Technology Lab, &quot;Vrije Universiteit Brussel&quot;, Brussels, Belgium.</affiliation>
<abstract confidence="0.978325201754386">Since the early 1980s, object-oriented frameworks have demonstrated that programmers can encapsulate a reusable, tailorable software architecture as a collection of collaborating, extensible object classes. Such frameworks are particularly important for developing open systems in which not only functionality but architecture is reused across a family of related applications. Unfortunately, the design of frameworks remains an art rather than a science, because of the inherent conflict between reuse — packaging software components that can be reused in as many contexts as possible — and tailorability — designing software architectures easily adapted to target requirements. To cope with this conflict, well-designed OO frameworks must provide a clean conceptual framework that clearly identifies hot spots[6]; where tailorability is necessary and desirable and specifies framework contracts[1] that formalize exactly which parts of the framework are to be reused. This article presents three design guidelines that help identify hot spots and contracts, thereby balancing flexibility and tailorability. Tailorable frameworks are particularly useful for the construction of so-called open systems. There exist various viewpoints on what precisely makes a system “open”, a discussion beyond the scope of this article. For our purposes, the following open system requirements are sufficient. • Interoperability: Open systems typically run on heterogeneous hardware and software platforms. Platform differences should be encapsulated in the system architecture to ease integration. • Distribution: Open systems are physically distributed. Coordinating distributed services is nontrivial and requires reliable services. An open system guarantees the correct execution of system critical functions. • Extensibility: Most open systems provide some form of extensibility, allowing end users to customize the system to address special needs. End-user customization requires the system’s configuration to be adaptable without changing the internal implementation of existing system modules. To cope with these requirements, we ask system designers to identify the axes of variability for their open system. Based on these axes, we specify the following three guidelines for de- 1. Communications of the ACM, vol. 40, no. 10, ACM Press, October 1997, pp. 60-64. Serge Demeyer, Theo Dirk Meijler, Oscar Nierstrasz, Patrick Steyaert 2.signing an open system architecture (each design guideline introduces an extra level of tailorability for addressing an open system requirement). Guideline 1 [Interoperability] Include in the design separate “axis-objects” so each such object represents a point on one of the axes of variability, thus encapsulating a degree of platform independence. Objects in the initial system model must delegate responsibilities to the axis objects. Guideline 2 [Distribution] Specify a framework contract for each of the variability axes. Extend the framework design with a “contract object” guaranteeing the correct execution of the corresponding contract. Guideline 3 [Extensibility] Introduce a global “configuration object” representing the system configuration. By replacing that configuration object, an OO programmer can adapt the system’s configuration without changing the implementation of the other objects. To illustrate the practical value of the guidelines, the rest of this article explores their application to the concrete architecture of an open hypermedia system (see http://www.csdl.tamu.edu/ ohs/). We stress that this is only an example and we refer readers to [2] for a discussion on the guidelines’ general applicability. We also point out that such system is necessarily complicated, as it deals with difficult issues that cannot be illustrated with toy examples; we provide clarifying diagrams wherever possible.1 To apply the guidelines, we assume the existence of an initial model for the intended open system. Identification of the entities in such an initial model is another issue beyond the scope of this article but methodologies like Objectory’s Use Cases[4] provide excellent support in this area. Figure 1 shows the class structure of an initial open hypermedia system model, including a Document class, holding some contents in a certain multi-media format (e.g., HTML, GIF). A document also contains a number of Anchors representing the parts of a document that may be used as the source or target of a navigation operation. An anchor has a value that uniquely identifies it within the associated document contents (e.g., the position in a text, rectangle in a bitmap). 1. All the diagrams employ the notation of the Unified Modelling Language (UML). Figure 1 Initial Model for an Open Hypermedia System Document Anchor edit() activate() highlight() select() contents value 3. Design Guidelines for Tailorable FrameworksThe Document and Anchor classes are two of the hot spots; tailoring the framework to the needs of the open hypermedia system, system designers must provide the appropriate subclasses. However, these subclasses must respect the fundamental rules of the framework, specified in the framework contract (see figure 2). Assuming the precondition of a displayed document whereby every contained anchor is highlighted, an activation of one of these anchors (activate) computes the target document and anchor of the corresponding navigation relationship, opens the document (edit), highlights the contained anchors (highlight) and finally selects (select) the target anchor within that a document. Axes of Variability To turn an initial system model into an architecture for an open system, designers should first identify the axes of variability. How to do this is also beyond the scope of this article, so we again refer to well-known OO methods like Objectory[4] and OORAM[5]. For our open hypermedia system, we propose three important varying characteristics: storage (how hypermedia documents are stored — in, say, http, ftp or a file), presentation (how they are viewed — through, say a browser or JPEG viewer); and navigation (how they may be linked — by, say, embedded references, CGI-scripts). Based on this analysis, figure 3 shows the three variability axes: the storage axis, enumerating all possible document repositories; the presentation axis, enumerating all possible viewer applications; and the navigation axis enumerating all possible kinds of linking relationships. We now turn to the question how to incorporate these axes of variability into a tailorable framework architecture. highlight() Figure 2 The initial framework contract containedAnchors sourceAnchor targetDocument activate() edit() targetAnchor select() Figure 3 The hypermedia axes of variability</abstract>
<title confidence="0.936439666666667">Presentation Storage Navigation</title>
<author confidence="0.572542">Serge Demeyer</author>
<author confidence="0.572542">Theo Dirk Meijler</author>
<author confidence="0.572542">Oscar Nierstrasz</author>
<author confidence="0.572542">Patrick Steyaert The Interoperability</author>
<abstract confidence="0.993960085714285">Requirement The application of the first guideline introduces three new classes (see figure 4): one for the storage axis (Loader), one for the presentation axis (Editor), and one for the navigation axis (Resolver). These extra classes yield three hot spots for the hypermedia framework. By introducing these hot spots, we must split the initial framework contract into three finer-grained contracts. The navigation contract (see figure 5) states that an anchor receiving the activate message, must send a resolveToDocument message to the associated resolver to create the target document and display it to the user (edit); afterward, the activated anchor must create (resolveToAnchor) and select (select) the target location. The storage contract states that a document receiving the edit message, must send a load message to the associated loader to ensure that the document contents are properly loaded from the storage device and that all associated anchors are created. The presentation contract states that a document receiving the edit message must — after being loaded — send an edit message to the associated editor to display the contents to the end user and highlight all the anchors. Having applied the first design guideline, the document and anchor objects in the initial hypermedia model delegate the variant behaviour to the corresponding axis objects—resolver, loader, editor. This way, all platform-dependent aspects are encapsulated into the axis objects, thus addressing the interoperability requirement. Figure 5 The Navigation contract sourceAnchor targetDocument activate() edit() resolver resolveToDocument( sourceAnchor) targetAnchor select() resolveToAnchor( sourceAnchor) Figure 4 Resolver, Editor and Loader classes, representing the variability axes Anchor activate() highlight() select() Document edit() Resolver resolveToDocument (anchor) ✽ Loader load(document) Editor edit(document) ✽ ✽ contents value resolveToAnchor (anchor) 5. Design Guidelines for Tailorable FrameworksThe Distribution Requirement Reliability is crucial in a distributed system. Crucial system services —log maintenance, locking, authority control— require the system to monitor all activities of a certain kind and perform additional checks and bookkeeping. This requirement conflicts with the interoperability and extensibility requirements, according to which the system has to cooperate with external software and may be adapted at run time. Guaranteeing reliable services in such a dynamic environment is difficult, but our second guideline results in an architecture that monitors crucial system services, independent of the participating objects. We illustrate this need through the problem of maintaining a log of all navigation operations. Figure 6 shows the result of applying the second guideline for the navigation contract in figure 5. Here, the path object takes complete control of the execution of the navigation contract, including an extra notification (activated) of the source anchor. This path object is a hot spot of the framework, providing an ideal location for wrapping additional logging behaviour around the execution of the navigation operation, independent of the participating resolver, anchor and document objects. We similarly reify the storage contract and guarantee that all read/write operations are monitored; such hot spot can be used to guarantee a systemwide locking strategy. Also, the reified presentation contract can monitor all editing operations and implement authority control. We conclude that applying the second guideline allows us to monitor execution of system-critical services, addressing the need for reliability in distributed systems. Figure 6 The path object, representing the navigation contract path targetDocument activate(sourceAnchor) edit() resolver resolveToDocument( sourceAnchor) targetAnchor select() resolveToAnchor( sourceAnchor) sourceAnchor activated() Serge Demeyer, Theo Dirk Meijler, Oscar Nierstrasz, Patrick Steyaert 6.The Extensibility Requirement Rephrasing the third guideline, we must refactor all operations that determine the system configuration into a single configuration object. In a system designed according to our guidelines, these are all methods that create objects1 from the initial model (see figure 1) plus all the methods that make a connection between an object of the initial model and a contract object (the first guideline). Figure 7 shows the result of applying the third guideline for the navigation contract. When the path object receives the request for a navigation operation (activate), it asks the hypermediacontext object to identify which resolver is supposed to handle the navigation operation (determineResolver). This resolver is then asked to compute the targets of the navigation operation (resolveToDocSpec/resolveToAnchorSpec), returning a document and anchor specifier. Each of these specifiers is passed to the hypermediacontext object, which instantiates one of the existing Document (createDocument) or Anchor (createAnchor) classes. Similarly, there are two methods that decide on the loader (determineLoader) or editor (determineEditor) that is supposed to handle a document. 1. To that extent, the configuration object behaves like an Abstract Factory [3] Figure 7 hypermediacontext object, representing the system configuration resolver path hypermedia contextactivate(anchor) determineResolver(anchor) resolveToDocument(anchor) createDocument(docSpec) resolveToDocSpec(anchor) targetDocument activated() anchor edit() resolveToAnchor(anchor) createAnchor(anchSpec) resolveToAnchorSpec(anchor) targetAnchor select() 7. Design Guidelines for Tailorable FrameworksThis single hypermedia context object provides the framework hot spot in which an OO programmer can tailor the system configuration without altering the rest of the system. Thus, the third guideline addresses the extensibility requirement. Conclusion The proposed design guidelines cover only some of the state of the art in framework design. But because of the way they are formulated, they fit nicely with the other techniques available today —i.e., design patterns, open implementations, class refactoring—making them especially attractive. The fact that the guidelines provide concrete design solutions for such issues as interoperability, extensibility and distribution makes them useful for coping with the growing demand for openness. The search for more openness is inevitable in an environment in which software is evolving dramatically and the World-Wide Web’s growing popularity means new technical requirements every day. Since they build on our hypermedia experience, we are confident that these guidelines, will address the needs of current and future generations of open systems.</abstract>
<note confidence="0.989882">References [1] Codenie, W., De Hondt, K., Steyaert, P., and Vercammen, A., Evolving Custom-Made Applications into Domain-Specific Frameworks. Communications of the ACM 40, 10 (October 1997). [2] Demeyer, S. Zypher: Tailorability as a Link from Object-Oriented Software Engineering to Open Hypermedia. Ph. D. dissertation, Vrije Universiteit Brussel, Department of Computer Science, 1996 — Belgium. See http://dinfwww.vub.ac.be/ and http://iamwww.unibe.ch/~demeyer/. [3] Gamma, E., Helm, R., Johnson, R. and Vlissides, J. Design Patterns. Addison-Wesley, 1995. [4] Jacobson, I. Object-Oriented Software Engineering, a Use Case Driven Approach. Addison- Wesley, 1992. [5] Reenskaug, T. and Wold, P. and Lehne, O. A. Working with Objects: The OOram Software Engineering Method. Manning Publications, Greenwich CT, 1996. [6] Schmid, H. A., Systematic Framework Design by Generalisation. Communications of the ACM 40, 10 (October 1997).</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>W Codenie</author>
<author>K De Hondt</author>
<author>P Steyaert</author>
<author>A Vercammen</author>
</authors>
<title>Evolving Custom-Made Applications into Domain-Specific Frameworks.</title>
<date>1997</date>
<journal>Communications of the ACM</journal>
<volume>40</volume>
<pages>10</pages>
<contexts>
<context position="1199" citStr="[1]" startWordPosition="159" endWordPosition="159">functionality but architecture is reused across a family of related applications. Unfortunately, the design of frameworks remains an art rather than a science, because of the inherent conflict between reuse — packaging software components that can be reused in as many contexts as possible — and tailorability — designing software architectures easily adapted to target requirements. To cope with this conflict, well-designed OO frameworks must provide a clean conceptual framework that clearly identifies hot spots[6]; where tailorability is necessary and desirable and specifies framework contracts[1] that formalize exactly which parts of the framework are to be reused. This article presents three design guidelines that help identify hot spots and contracts, thereby balancing flexibility and tailorability. Tailorable frameworks are particularly useful for the construction of so-called open systems. There exist various viewpoints on what precisely makes a system “open”, a discussion beyond the scope of this article. For our purposes, the following open system requirements are sufficient. • Interoperability: Open systems typically run on heterogeneous hardware and software platforms. Platfor</context>
</contexts>
<marker>[1]</marker>
<rawString>Codenie, W., De Hondt, K., Steyaert, P., and Vercammen, A., Evolving Custom-Made Applications into Domain-Specific Frameworks. Communications of the ACM 40, 10 (October 1997).</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Zypher Demeyer</author>
</authors>
<title>Tailorability as a Link from Object-Oriented Software Engineering to Open Hypermedia.</title>
<date>1996</date>
<tech>Ph. D. dissertation,</tech>
<institution>Vrije Universiteit Brussel, Department of Computer Science,</institution>
<note>See http://dinfwww.vub.ac.be/ and http://iamwww.unibe.ch/~demeyer/.</note>
<contexts>
<context position="3902" citStr="[2]" startWordPosition="552" endWordPosition="552"> object” guaranteeing the correct execution of the corresponding contract. Guideline 3 [Extensibility] Introduce a global “configuration object” representing the system configuration. By replacing that configuration object, an OO programmer can adapt the system’s configuration without changing the implementation of the other objects. To illustrate the practical value of the guidelines, the rest of this article explores their application to the concrete architecture of an open hypermedia system (see http://www.csdl.tamu.edu/ ohs/). We stress that this is only an example and we refer readers to [2] for a discussion on the guidelines’ general applicability. We also point out that such system is necessarily complicated, as it deals with difficult issues that cannot be illustrated with toy examples; we provide clarifying diagrams wherever possible.1 To apply the guidelines, we assume the existence of an initial model for the intended open system. Identification of the entities in such an initial model is another issue beyond the scope of this article but methodologies like Objectory’s Use Cases[4] provide excellent support in this area. Figure 1 shows the class structure of an initial open</context>
</contexts>
<marker>[2]</marker>
<rawString>Demeyer, S. Zypher: Tailorability as a Link from Object-Oriented Software Engineering to Open Hypermedia. Ph. D. dissertation, Vrije Universiteit Brussel, Department of Computer Science, 1996 — Belgium. See http://dinfwww.vub.ac.be/ and http://iamwww.unibe.ch/~demeyer/.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Gamma</author>
<author>R Helm</author>
<author>R Johnson</author>
<author>J Vlissides</author>
</authors>
<title>Design Patterns.</title>
<date>1995</date>
<publisher>Addison-Wesley,</publisher>
<contexts>
<context position="12452" citStr="[3]" startWordPosition="1818" endWordPosition="1818">dle the navigation operation (determineResolver). This resolver is then asked to compute the targets of the navigation operation (resolveToDocSpec/resolveToAnchorSpec), returning a document and anchor specifier. Each of these specifiers is passed to the hypermediacontext object, which instantiates one of the existing Document (createDocument) or Anchor (createAnchor) classes. Similarly, there are two methods that decide on the loader (determineLoader) or editor (determineEditor) that is supposed to handle a document. 1. To that extent, the configuration object behaves like an Abstract Factory [3] Figure 7 hypermediacontext object, representing the system configuration resolver path hypermedia contextactivate(anchor) determineResolver(anchor) resolveToDocument(anchor) createDocument(docSpec) resolveToDocSpec(anchor) targetDocument activated() anchor edit() resolveToAnchor(anchor) createAnchor(anchSpec) resolveToAnchorSpec(anchor) targetAnchor select() 7. Design Guidelines for Tailorable FrameworksThis single hypermedia context object provides the framework hot spot in which an OO programmer can tailor the system configuration without altering the rest of the system. Thus, the third gui</context>
</contexts>
<marker>[3]</marker>
<rawString>Gamma, E., Helm, R., Johnson, R. and Vlissides, J. Design Patterns. Addison-Wesley, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Jacobson</author>
</authors>
<title>Object-Oriented Software Engineering, a Use Case Driven Approach.</title>
<date>1992</date>
<publisher>AddisonWesley,</publisher>
<contexts>
<context position="4408" citStr="[4]" startWordPosition="631" endWordPosition="631">tp://www.csdl.tamu.edu/ ohs/). We stress that this is only an example and we refer readers to [2] for a discussion on the guidelines’ general applicability. We also point out that such system is necessarily complicated, as it deals with difficult issues that cannot be illustrated with toy examples; we provide clarifying diagrams wherever possible.1 To apply the guidelines, we assume the existence of an initial model for the intended open system. Identification of the entities in such an initial model is another issue beyond the scope of this article but methodologies like Objectory’s Use Cases[4] provide excellent support in this area. Figure 1 shows the class structure of an initial open hypermedia system model, including a Document class, holding some contents in a certain multi-media format (e.g., HTML, GIF). A document also contains a number of Anchors representing the parts of a document that may be used as the source or target of a navigation operation. An anchor has a value that uniquely identifies it within the associated document contents (e.g., the position in a text, rectangle in a bitmap). 1. All the diagrams employ the notation of the Unified Modelling Language (UML). Fig</context>
<context position="6131" citStr="[4]" startWordPosition="908" endWordPosition="908">d document whereby every contained anchor is highlighted, an activation of one of these anchors (activate) computes the target document and anchor of the corresponding navigation relationship, opens the document (edit), highlights the contained anchors (highlight) and finally selects (select) the target anchor within that a document. Axes of Variability To turn an initial system model into an architecture for an open system, designers should first identify the axes of variability. How to do this is also beyond the scope of this article, so we again refer to well-known OO methods like Objectory[4] and OORAM[5]. For our open hypermedia system, we propose three important varying characteristics: storage (how hypermedia documents are stored — in, say, http, ftp or a file), presentation (how they are viewed — through, say a browser or JPEG viewer); and navigation (how they may be linked — by, say, embedded references, CGI-scripts). Based on this analysis, figure 3 shows the three variability axes: the storage axis, enumerating all possible document repositories; the presentation axis, enumerating all possible viewer applications; and the navigation axis enumerating all possible kinds of li</context>
</contexts>
<marker>[4]</marker>
<rawString>Jacobson, I. Object-Oriented Software Engineering, a Use Case Driven Approach. AddisonWesley, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Reenskaug</author>
<author>P Wold</author>
<author>O A Lehne</author>
</authors>
<title>Working with Objects: The OOram Software Engineering Method. Manning Publications,</title>
<date>1996</date>
<location>Greenwich CT,</location>
<contexts>
<context position="6144" citStr="[5]" startWordPosition="910" endWordPosition="910">ereby every contained anchor is highlighted, an activation of one of these anchors (activate) computes the target document and anchor of the corresponding navigation relationship, opens the document (edit), highlights the contained anchors (highlight) and finally selects (select) the target anchor within that a document. Axes of Variability To turn an initial system model into an architecture for an open system, designers should first identify the axes of variability. How to do this is also beyond the scope of this article, so we again refer to well-known OO methods like Objectory[4] and OORAM[5]. For our open hypermedia system, we propose three important varying characteristics: storage (how hypermedia documents are stored — in, say, http, ftp or a file), presentation (how they are viewed — through, say a browser or JPEG viewer); and navigation (how they may be linked — by, say, embedded references, CGI-scripts). Based on this analysis, figure 3 shows the three variability axes: the storage axis, enumerating all possible document repositories; the presentation axis, enumerating all possible viewer applications; and the navigation axis enumerating all possible kinds of linking relatio</context>
</contexts>
<marker>[5]</marker>
<rawString>Reenskaug, T. and Wold, P. and Lehne, O. A. Working with Objects: The OOram Software Engineering Method. Manning Publications, Greenwich CT, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H A Schmid</author>
</authors>
<title>Systematic Framework Design by Generalisation.</title>
<date>1997</date>
<journal>Communications of the ACM</journal>
<volume>40</volume>
<pages>10</pages>
<contexts>
<context position="1114" citStr="[6]" startWordPosition="149" endWordPosition="149"> frameworks are particularly important for developing open systems in which not only functionality but architecture is reused across a family of related applications. Unfortunately, the design of frameworks remains an art rather than a science, because of the inherent conflict between reuse — packaging software components that can be reused in as many contexts as possible — and tailorability — designing software architectures easily adapted to target requirements. To cope with this conflict, well-designed OO frameworks must provide a clean conceptual framework that clearly identifies hot spots[6]; where tailorability is necessary and desirable and specifies framework contracts[1] that formalize exactly which parts of the framework are to be reused. This article presents three design guidelines that help identify hot spots and contracts, thereby balancing flexibility and tailorability. Tailorable frameworks are particularly useful for the construction of so-called open systems. There exist various viewpoints on what precisely makes a system “open”, a discussion beyond the scope of this article. For our purposes, the following open system requirements are sufficient. • Interoperability:</context>
</contexts>
<marker>[6]</marker>
<rawString>Schmid, H. A., Systematic Framework Design by Generalisation. Communications of the ACM 40, 10 (October 1997).</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>