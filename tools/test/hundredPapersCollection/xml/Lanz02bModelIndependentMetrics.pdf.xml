<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000701">
<figure confidence="0.871755">
Beyond Language Independent Object-Oriented Metrics:
Model Independent Metrics
Michele Lanza
lanza@iam.unibe.ch
Software Composition Group
Universitá di Berna, Svizzera
Stéphane Ducasse
ducasse@iam.unibe.ch
Software Composition Group
Université de Berne, Suisse
</figure>
<sectionHeader confidence="0.762891" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.997020166666667">
Software Metrics have become essential in software engi-
neering for several reasons, among which quality assessment
and reengineering. In the context of the European Esprit
Project FAMOOS, whose main goal was to provide method-
ologies for the reengineering of large industrial software sys-
tems, we have developed the Moose Reengineering Envi-
ronment, based on the language independent FAMIX meta-
model. Moose includes a metrics engine which supports lan-
guage independent metrics, since coping with software writ-
ten in different implementation languages was one of the
project’s main constraints. Our current research is push-
ing us towards the development and implementation of a
metametamodel, which would include our metamodel and
allow for several extension in different research directions,
among which concept analysis, knowledge management and
software evolution. In this article we want to present our
current and future work for the transition from language in-
dependent to domain independent metrics.
</bodyText>
<sectionHeader confidence="0.945401" genericHeader="keywords">
Keywords: Software Metrics, Object-Oriented Program-
</sectionHeader>
<keyword confidence="0.557305">
ming, Language Independence
</keyword>
<sectionHeader confidence="0.99645" genericHeader="introduction">
1. INTRODUCTION AND MOTIVATION
</sectionHeader>
<bodyText confidence="0.989701052631579">
Metrics have become essential in some disciplines of soft-
ware engineering. In forward engineering they are being
used to measure software quality and to estimate cost and
effort of software projects [15]. In the field of software evo-
lution, metrics can be used for identifying stable or unstable
parts of software systems, as well as for identifying where
refactorings can be applied or have been applied [9], and for
detecting increases or decreases of quality in the structure
of evolving software systems. In the area of software reengi-
neering and reverse engineering [7], metrics are being used
for assessing the quality and complexity of software systems,
as well as getting a basic understanding and providing clues
about sensitive parts of software systems.
If we restrict ourselves to the field of object-oriented reengi-
neering and object-oriented metrics, we see that this field is
fairly new. In the past decade a great body of research has
been conducted [5, 17, 16] and various metric suites have
been proposed [21, 6], which cover most of the relevant as-
pects of object-oriented software.
In the context of the European FAMOOS Esprit Project,
whose main goal was to investigate methodologies and cre-
ate tools to reengineer large software systems, and whose
main results have been summarized in [12, 10], we were con-
fronted with several large scale industrial systems written
in different languages, among which C++, Java, Smalltalk
and Ada.
Therefore we created the Moose Reengineering Environment
[13], a repository and tool environment, based on the lan-
guage independent FAMIX metamodel [11]. Source code
in one of the aforementioned languages is mapped to a lan-
guage independent representation, which we present in more
detail in the next section.
The Moose Reengineering Environment included a metrics
engine, which was first implemented to perform simple queries
and then greatly extended to support the development of
CodeCrawler, a software visualization tool which integrates
metrics in its visualizations [18, 8]. The extended metrics en-
gine included a suite of language independent metrics, whose
computation was based exclusively on the language indepen-
dent metamodel representation of software artifacts.
As we are now starting the implementation of a metameta-
model, where apart from artifacts defined in the FAMIX
metamodel, non-software artifacts can as well be accomo-
dated, the need has arisen to extend the language indepen-
dent metrics suite to become a model independent metrics
suite.
In this article we present and discuss our current state of
research and a first implementation of a metametamodel,
and give an outlook on our future work in this field.
Structure of this Document
This paper is structured as follows: In the next section we
present a short overview on our previous work in the field of
reengineering and reverse engineering with a special focus on
software metrics. We then abstract from this context and
come up with model independent metrics, and show that
these metrics cover all previously presented metrics. We
then present Moose and CodeCrawler, the software applica-
</bodyText>
<figureCaption confidence="0.992752">
Figure 1: A simplified view of the FAMIX meta-
</figureCaption>
<bodyText confidence="0.916615666666667">
model.
tions we are currently developing to support our research.
Next we report on our experiences with a first implementa-
tion of model independent metrics. Finally, we conclude by
analyzing benefits and limits of our approach and present
our future work in this area.
</bodyText>
<sectionHeader confidence="0.997742" genericHeader="method">
2. LANGUAGE INDEPENDENT OBJECT-
ORIENTED SOFTWARE METRICS
</sectionHeader>
<bodyText confidence="0.997657818181818">
In the context of the European FAMOOS project we created
the Moose Reengineering Environment, which implements
the FAMIX metamodel and serves as repository for software
artifacts and common development base for various tools,
among which CodeCrawler.
A simplified view of the FAMIX metamodel comprises the
main object-oriented concepts - namely class, method, at-
tribute and inheritance - plus the necessary associations be-
tween them - namely method invocation and attribute ac-
cess (see Figure 1). Note that the actual FAMIX meta-
model contains nearly all possible software artifacts, includ-
ing method parameters and local variables. The FAMIX
metamodel does not include the actual source code, how-
ever it provides easy access to the actual source code by
means of source anchors that point to the right location, for
example the position within a source file.
In Table 1 and Table 2 we list a selection of metrics which
can be computed by our metrics engine. The metrics are
divided into class, method and attribute metrics, i.e., these
are the entities that the metric measurements are assigned
to. Moose includes a metrics engine with more than 50 dif-
ferent metrics, among which ca. 30 language-independent
metrics.
In bold we have emphasized the few language-dependent
metrics, which depend mainly on language-specific constructs
and properties, like modifiers for C++ and Java or method
protocols for Smalltalk source code. Note that metrics which
are sums of language dependent metrics (for example WLOC
and LOC) can be considered language independent.
The computation of the language independent metrics is
based solely on our repository of software entities and is
therefore by definition language independent.
To give a short example, suppose that Moose contains a
</bodyText>
<figure confidence="0.993125121212121">
Name Description
Class Metrics
HNL Number of classes in superclass chain of
class
NAM Number of abstract methods
NCV Number of class variables
NIA Number of inherited attributes
NIV Number of instance variables
NME Number of methods extended, i.e., rede-
fined in subclass by invoking the same
method on a superclass
NMI Number of methods inherited, i.e., defined
in superclass and inherited unmodified by
subclass
NMO Number of methods overridden, i.e., rede-
fined compared to superclass
NOA Number of attributes (NOA = NIV +
NCV)
NOC Number of immediate subclasses of a class
NOM Number of methods
NOMP Number of method protocols (in
Smalltalk)
PriA Number of private attributes (equivalent
for protected and public attributes)
PriM Number of private methods (equivalent for
protected and public methods)
WLOC Sum of LOC over all methods
WMSG Sum of message sends in a class
WNMAA Number of all accesses on attributes
WNOC Number of all descendant classes
WNOS Sum of statements in all method bodies of
class
WNI Number of invocations of all methods
</figure>
<tableCaption confidence="0.831748">
Table 1: A list of the class metrics contained in the
</tableCaption>
<bodyText confidence="0.9499645">
metrics engine of the Moose Reengineering Environ-
ment.
class foo and two methods bar and tender. As we have
seen in Figure 1 a method entity has a relationship called
belongsToClass, which points to the corresponding class. If
both methods in our example point to the class foo we can
infer that the number of methods (NOM) metric of foo will
have the value 2.
Thus the computation of the metrics based solely on the
metamodel representation of source code can be conceived
as a traversal of the graph depicted in Figure 1. The nodes
in the graph are source code artifacts, while the edges rep-
resent relationships between those artifacts. In the FAMIX
metamodel the main entities are class, method and attribute
and the main relationships inheritance, access (from method
to attribute) and invocation (between methods). Added to
this we have containment relationships, i.e., a class contains
a set of methods and attributes.
Added to this we also have a set of properties on the en-
tities which can also be boolean. For example a class has
the property isAbstract or a method has one of the proper-
ties isAccessor, isOverriding, isExtending, etc.. The entities
</bodyText>
<figure confidence="0.9781221875">
Name Description
Method Metrics
LOC Method lines of code
NMA Number of methods added, i.e., defined in
subclass and not in superclass
MHNL Class HNL in which method is imple-
mented
MSG Number of method message sends
NOP Number of (input) parameters
NI Number of invocations of other methods
within method body
NMAA Number of accesses on attributes
NOS Number of statements in method body
Attribute Metrics
AHNL Class HNL in which attribute is defined
NAA Number of times directly accessed
</figure>
<tableCaption confidence="0.872546">
Table 2: A list of the method and attribute met-
</tableCaption>
<bodyText confidence="0.912514375">
rics contained in the metrics engine of the Moose
Reengineering Environment.
have been implemented in an extensible way, i.e., each entity
has a field of freely definable properties which we compute
by means of operators, i.e., we iterate over the entities of
a metamodel, compute properties and add those properties
to the entities. Note that the metrics themselves have been
modeled as properties.
</bodyText>
<sectionHeader confidence="0.988048" genericHeader="method">
3. MODEL INDEPENDENT METRICS
</sectionHeader>
<bodyText confidence="0.990995142857143">
In this section we first present the construction of model
independent metrics. The construction of these metrics is
based on the traversal of the metamodel graph, for example
like the one depicted in Figure 1. We do this by defining
three generic metrics, namely NodeCount , EdgeCount
, and PathLength also denoted by the acronyms NC, EC,
and PL. Starting from these generic metrics a large number
of object-oriented metrics can be defined in a general, flex-
ible and extensible way, as we show by providing concrete
examples. To increase the readability and to stay within the
limits of this position paper we omit formal definitions of the
metrics and provide smalltalk source code examples instead.
However, we plan to eventually add the formal definitions
in an extended future version of this paper.
</bodyText>
<subsectionHeader confidence="0.983133">
3.1 Generic Metrics
</subsectionHeader>
<subsubsectionHeader confidence="0.628064">
3.1.1 NodeCount
</subsubsectionHeader>
<bodyText confidence="0.997588709677419">
NodeCount can be defined as the number of nodes con-
nected to a node over a certain kind of edge, i.e., the num-
ber of nodes connected to a certain node over containment
relationship edges or invocation edges, etc. Note that each
node and edge in the graph knows about its neighboring
nodes and edges, therefore after constructing the graph it
is easy to get the necessary collections of nodes and edges
necessary for our metrics computations.
Examples. The number of methods (NOM) of a class c
is equal to the number of method nodes contained in class
Node c. The number of accessed attributes by a method
m is equal to the number of attribute nodes connected to
node m by means of access edges. The number of invoked
methods by a method m is equal to the number of method
nodes connected to node m by means of invocation edges.
Furthermore, NodeCount can be extended to satisfy cer-
tain properties, by selecting or rejecting counted nodes de-
pending on whether these nodes fulfill certain properties.
Examples. The number of abstract methods (NAM) of a
class c is equal to the number of method nodes contained in
class node c and which fulfill the property isAbstract. Simi-
larly the number of concrete methods can either be defined
by reject abstract methods or by using the property isCon-
crete.
Note that this definition of NodeCount will ignore dupli-
cates, i.e., if method m accesses attribute a twice, this will
be counted as only one accessed attribute, since the met-
ric measures the number of accessed attributes and not the
number of attribute accesses performed by method m. To
obtain the latter metric, we need the generic metric Edge-
Count , that we discuss below.
</bodyText>
<subsubsectionHeader confidence="0.907305">
3.1.2 EdgeCount
</subsubsectionHeader>
<bodyText confidence="0.978216625">
Similar to NodeCount we can define a generic metric Edge-
Count for counting edges. EdgeCount can be defined as
the number of edges attached to a node. The edges can have
an arbitrary type.
Examples. The number of attribute accesses performed by
method m is equal to number of access edges attached to
method node m. The number of method invocations per-
formed by method m is defined accordingly.
</bodyText>
<subsectionHeader confidence="0.590314">
3.1.3 PathLength
</subsectionHeader>
<bodyText confidence="0.9954905">
The last generic metric PathLength deals with chains of
edges of the same type. PathLength can be defined as the
length of the chain of edges of a certain type starting in a
certain node.
Examples. The depth level (HNL) of a class c within an
inheritance hierarchy is equal to the length of the chain of
inheritance relationships starting from class node c. The
maximum method invocation depth within a class c is equal
to the maximum PathLength of method invocations com-
puted over all method nodes contained in class node c.
</bodyText>
<subsectionHeader confidence="0.999786">
3.2 Derived Generic Metrics
</subsectionHeader>
<bodyText confidence="0.997114333333333">
We can extend the generic metrics in order to allow us to
compute more complicated metrics, among which transitive,
ratio and promoted metrics.
</bodyText>
<subsubsectionHeader confidence="0.982397">
3.2.1 Transitive Metrics
</subsubsectionHeader>
<bodyText confidence="0.9985135">
Transitive metrics can be seen as extensions to the generic
metrics, by traversing the metamodel graph over different
kinds of nodes and edges and by counting the things relevant
to the metric.
Examples. The number of attributes accessed by a class
c, e.g., by the methods contained in class c is a transitive
NodeCount metric which traverses the graph from class
node c over its contained method nodes m1,m2, ... to the
attribute nodes a1, a2, ... attached to the method nodes by
means of access edges.
</bodyText>
<subsubsectionHeader confidence="0.986762">
3.2.2 Promoted Metrics
</subsubsectionHeader>
<bodyText confidence="0.9976434">
The generic metrics are absolute metrics, i.e., their values
will be positive integers including zero. Promoted met-
rics are obtained by taking two or more (not necessarily
generic) metrics and performing arithmetic operations on
them. Prominent examples of promoted metrics are per-
centage, average and summation metrics.
Examples. The average number of accessed attributes by
the methods contained in class c will be defined as the num-
ber of attributes accessed by class c divided by the number
of methods contained in class c.
</bodyText>
<sectionHeader confidence="0.976532" genericHeader="method">
4. CODECRAWLER AND MOOSE
</sectionHeader>
<bodyText confidence="0.967386">
In this section we shortly present the Moose Reengineer-
ing Environment and CodeCrawler, its most prominent tool,
which also was the main cause for our current work in the
field of metrics.
</bodyText>
<subsectionHeader confidence="0.99701">
4.1 The Moose Reengineering Environment
</subsectionHeader>
<bodyText confidence="0.999559214285714">
Moose is a language independent reengineering environment
written in Smalltalk. It is based on the FAMIX metamodel
[11], which provides for a language independent represen-
tation of object-oriented sources and contains the required
information for the reengineering tasks performed by our
tools. It is language independent, because we need to work
with legacy systems written in different implementation lan-
guages. It is extensible, since we cannot know in advance
all information that is needed in future tools, and since for
some reengineering problems tools might need to work with
language-specific information, we allow for language plug-
ins that extend the model with language-specific features.
Next to that, we allow tool plug-ins to extend as well the
model with tool-specific information.
</bodyText>
<subsectionHeader confidence="0.989305">
4.2 CodeCrawler
</subsectionHeader>
<bodyText confidence="0.998814909090909">
CodeCrawler supports reverse engineering through the com-
bination of metrics and visualization [18, 8, 19]. It visualizes
entities as nodes and relatioships as edges, and renders up
to five metrics on the nodes by using their width, height,
color and position on the display. Through these simple vi-
sualization enriched with the large metrics suite provided by
Moose, it enables the user to gain insights in large systems
in a short time. CodeCrawler is a tool which works best
when unknown systems are approached and quick insights
are needed for reverse engineering. CodeCrawler has been
successfully tested on several industrial case studies.
</bodyText>
<subsectionHeader confidence="0.991481">
4.3 A Model Independent Metrics Suite
</subsectionHeader>
<bodyText confidence="0.984041444444444">
The motivation to implement a metametamodel came mainly
from the success of CodeCrawler: as it evolved and got
faster and more scalable, it was able to visualize larger
and larger systems. At one point, a new implementation
of CodeCrawler permitted to easily visualize non-FAMIX
entities. In some experiments we visualized for example
concepts from the field of concept analysis or prolog facts
from a prolog engine. However, as one of CodeCrawler’s
main aspects is the way it combines software visualization
</bodyText>
<figureCaption confidence="0.987873">
Figure 2: A screenshot taken from CodeCrawler. In
</figureCaption>
<bodyText confidence="0.9776108">
this view we see a display of inheritance hierarchies
of classes. The width and height of the class nodes
represent the number of attributes, respectively the
number of methods of the classes, while the color
reflects the number of lines of code of the classes.
with metrics, the need arose for a more general metrics en-
gine. Although the current metrics engine is flexible and
easily extensible, it is not general enough, and would re-
quire extensions each time new kinds of entities have to be
accomodated into CodeCrawler or Moose.
</bodyText>
<sectionHeader confidence="0.997207" genericHeader="discussions">
5. DISCUSSION
</sectionHeader>
<bodyText confidence="0.9995192">
In this section we first draw some conclusions on our current
work and discuss limits and benefits of our approach. We
then discuss related work which has been performed in this
field and end by giving an outlook on the future work we
plan to do in the presented context.
</bodyText>
<subsectionHeader confidence="0.784014">
5.1 Conclusion
In this paper we have presented a simple approach to gener-
</subsectionHeader>
<bodyText confidence="0.999610257142857">
ate model independent metrics. We have started by recapit-
ulating our experiences with language independent object-
oriented software metrics and have then abstracted from
that context to come up with a general way to create met-
rics independently from the underlying metamodel. We
have reported on some first experiences regarding the im-
plementation of a model independent metrics suite within
our metametamodel.
The benefits of our approach are the increased flexibility, i.e.,
we can introduce new metamodels from arbitrary contexts
(for example knowledge management, the financial world,
databases, etc.) which provides us with a standard metrics
suite without having to implement new metrics each time
such a new context is introduced.
The limits of our approach are that currently not all object-
oriented software metrics can be defined in terms of our
model independent metrics definitions. Certain metrics tend
to be very specialized and are thus difficult to define in
a generic way. Another problem is that for some metrics
there is still no consensus about what is the best way to
define them. For these reasons we did not consider coupling
metrics (such as NCR [21], CF [4], CBO and RFC [6]) and
cohesion metrics (such as LCOM [14, 6, 20], CR [1] and
CAMC [2]). Furthermore, as, due to our research in reengi-
neering, we come from a more pragmatic side, it is not solely
the definition of the metrics which interest us. Indeed, it is
the creation of concrete metrics, which we can then use for
instance in CodeCrawler, which interests us. In this con-
text other problems arise, whose solutions lie mainly at the
implementation level: what are the names of those metrics,
how many can we generate and when does it make sense to
stop generating metrics? Are the generated metrics actually
usable and which ones do make sense in the given contexts?
We plan to answer some of these questions in our future
work.
</bodyText>
<subsectionHeader confidence="0.73931">
5.2 Related and Future Work
</subsectionHeader>
<bodyText confidence="0.999841378378378">
A great body of research has been performed on the subject
of metrics. We limit ourselves to list the most important
references.
Metrics have long been studied as a way to assess the quality
and complexity of software [15], and recently this has been
applied to object-oriented software as well [21, 16]. Metrics
profit from their scalability and, in the case of simple ones,
from their reliable definition.
In [3] a mechanism is provided for comparing measures and
their potential use, integrating existing measures which ex-
amine the same concepts in different ways, and facilitating
more rigorous decision making regarding the definition of
new measures. This paper also provides an excellent state-
of-the-art which highlights that many measures have unclear
definitions, as should be the case in measurement theory.
In [22] a generic metamodel is used to define metrics that
abstract away from the particular metamodel elements. Be-
cause of this, the generic metrics are automatically available
for all the metamodels (such as UML or FAMIX [11] that
are mapped to the generic metamodel.
For reasons of simplicity, we did not provide subtype rela-
tionships in our metamodel. However, most metamodeling
approaches (such as UML) make use of subtypes. By ex-
ploiting this subtype information we can make our frame-
work even more generic.
At this time we only use properties for the nodes. In some
cases it could also be useful to use properties on the edges.
For example, we can make a distinction between access edges
which retrieve or change the value of an attribute.
In the future we plan to extend our metametamodel and
its model independent metrics engine. We believe this will
be pushed more as soon as we begin to integrate different
metamodels in our metametamodel. The first experiences
with the domains of concept analysis and logic languages
have been promising.
Acknowledgements. We would like to thank Roel Wuyts
for comments on drafts of this paper.
</bodyText>
<sectionHeader confidence="0.998138" genericHeader="references">
6. REFERENCES
</sectionHeader>
<reference confidence="0.999170547619048">
[1] N.V. Balasubramanian. Object-oriented metrics. In
Proc. 3rd Int’l Asia-Pacific Software Engineering
Conf. (ASPEC ’96), pages 30–34. IEEE Computer
Society Press, 1996.
[2] Jagdish Bansiya, Letha Etzkorn, Carl Davis, and Wei
Li. A class cohesion metric for object-oriented designs.
Journal of Object-Oriented Programming, 11(8):47–52,
January 1999.
[3] Lionel C. Briand, John W. Daly, and Jürgen K. Wüst.
A unified framework for coupling measurement in
object-oriented systems. IEEE Transactions on
Software Engineering, 25(1):91–121, 1999.
[4] F. Brito e Abreu, M. Goulao, and R. Esteves. Toward
the design quality evaluation of object-oriented
software systems. In Proc. 5th Int’l Conf. Software
Quality, pages 44–57, October 1995.
[5] Shyam R. Chidamber and Chris F. Kemerer. Towards
a metrics suite for object oriented design. In
Proceedings OOPSLA ’91, ACM SIGPLAN Notices,
pages 197–211, November 1991. Published as
Proceedings OOPSLA ’91, ACM SIGPLAN Notices,
volume 26, number 11.
[6] Shyam R. Chidamber and Chris F. Kemerer. A
metrics suite for object oriented design. IEEE
Transactions on Software Engineering, 20(6):476–493,
June 1994.
[7] Elliot J. Chikofsky and James H. Cross, II. Reverse
engineering and design recovery: A taxonomy. IEEE
Software, pages 13–17, January 1990.
[8] Serge Demeyer, Stéphane Ducasse, and Michele Lanza.
A hybrid reverse engineering platform combining
metrics and program visualization. In Francoise
Balmas, Mike Blaha, and Spencer Rugaber, editors,
Proceedings WCRE’99 (6th Working Conference on
Reverse Engineering). IEEE, October 1999.
[9] Serge Demeyer, Stéphane Ducasse, and Oscar
Nierstrasz. Finding refactorings via change metrics. In
Proceedings of OOPSLA’2000, ACM SIGPLAN
Notices, pages 166–178, 2000.
[10] Serge Demeyer, Stéphane Ducasse, and Oscar
Nierstrasz. Object-Oriented Reengineering Patterns.
Morgan Kaufmann, 2002. to appear, spring 2002.
[11] Serge Demeyer, Sander Tichelaar, and Stéphane
Ducasse. FAMIX 2.1 - the FAMOOS information
exchange model. Technical report, University of Bern,
2001.
[12] Stéphane Ducasse and Serge Demeyer, editors. The
FAMOOS Object-Oriented Reengineering Handbook.
University of Bern, October 1999. See
http://www.iam.unibe.ch/˜famoos/handbook.
[13] Stéphane Ducasse, Michele Lanza, and Sander
Tichelaar. The moose reengineering environment.
Smalltalk Chronicles, August 2001.
[14] Letha Etzkorn, Carl Davis, and Wei Li. A practical
look at the lack of cohesion in methods metric.
Journal of Object-Oriented Programming, 11(5):27–34,
September 1998.
[15] Norman Fenton and Shari Lawrence Pfleeger. Software
Metrics: A Rigorous and Practical Approach.
International Thomson Computer Press, London, UK,
second edition, 1996.
[16] Brian Henderson-Sellers. Object-Oriented Metrics:
Measures of Complexity. Prentice-Hall, 1996.
[17] M. Hitz and B. Montazeri. Chidamber and kemerer’s
metrics suite; a measurement theory perspective.
IEEE Transactions on Software Engineering,
22(4):267–271, April 1996.
[18] Michele Lanza. Combining metrics and graphs for
object oriented reverse engineering. Diploma thesis,
University of Bern, October 1999.
[19] Michele Lanza and Stéphane Ducasse. A
categorization of classes based on the visualization of
their internal structure: the class blueprint. In
Proceedings of OOPSLA 2001, pages 300–311, 2001.
[20] W. Li and S. Henry. Object oriented metrics that
predict maintainability. Journal of System Software,
23(2):111–122, 1993.
[21] Mark Lorenz and Jeff Kidd. Object-Oriented Software
Metrics: A Practical Guide. Prentice-Hall, 1994.
[22] Vojislav B. Mǐsić and Simon Moser. From formal
metamodels to metrics: An object-oriented approach.
In Proc. Technology of Object-Oriented Languages and
Systems (TOOLS-24). IEEE Computer Society Press,
1998.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.051099">
<title confidence="0.9985715">Beyond Language Independent Object-Oriented Metrics: Model Independent Metrics</title>
<author confidence="0.99993">Michele Lanza</author>
<email confidence="0.868354">lanza@iam.unibe.ch</email>
<affiliation confidence="0.7099146">Software Composition Group Universitá di Berna, Svizzera Stéphane Ducasse ducasse@iam.unibe.ch Software Composition Group</affiliation>
<address confidence="0.717402">Université de Berne, Suisse</address>
<abstract confidence="0.999754368421053">Software Metrics have become essential in software engineering for several reasons, among which quality assessment and reengineering. In the context of the European Esprit Project FAMOOS, whose main goal was to provide methodologies for the reengineering of large industrial software systems, we have developed the Moose Reengineering Environment, based on the language independent FAMIX metamodel. Moose includes a metrics engine which supports language independent metrics, since coping with software written in different implementation languages was one of the project’s main constraints. Our current research is pushing us towards the development and implementation of a metametamodel, which would include our metamodel and allow for several extension in different research directions, among which concept analysis, knowledge management and software evolution. In this article we want to present our current and future work for the transition from language independent to domain independent metrics.</abstract>
<keyword confidence="0.893207">Keywords: Software Metrics, Object-Oriented Program-</keyword>
<intro confidence="0.376349">ming, Language Independence</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>N V Balasubramanian</author>
</authors>
<title>Object-oriented metrics.</title>
<date>1996</date>
<booktitle>In Proc. 3rd Int’l Asia-Pacific Software Engineering Conf. (ASPEC ’96),</booktitle>
<pages>30--34</pages>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="19050" citStr="[1]" startWordPosition="3079" endWordPosition="3079">te without having to implement new metrics each time such a new context is introduced. The limits of our approach are that currently not all objectoriented software metrics can be defined in terms of our model independent metrics definitions. Certain metrics tend to be very specialized and are thus difficult to define in a generic way. Another problem is that for some metrics there is still no consensus about what is the best way to define them. For these reasons we did not consider coupling metrics (such as NCR [21], CF [4], CBO and RFC [6]) and cohesion metrics (such as LCOM [14, 6, 20], CR [1] and CAMC [2]). Furthermore, as, due to our research in reengineering, we come from a more pragmatic side, it is not solely the definition of the metrics which interest us. Indeed, it is the creation of concrete metrics, which we can then use for instance in CodeCrawler, which interests us. In this context other problems arise, whose solutions lie mainly at the implementation level: what are the names of those metrics, how many can we generate and when does it make sense to stop generating metrics? Are the generated metrics actually usable and which ones do make sense in the given contexts? We</context>
</contexts>
<marker>[1]</marker>
<rawString>N.V. Balasubramanian. Object-oriented metrics. In Proc. 3rd Int’l Asia-Pacific Software Engineering Conf. (ASPEC ’96), pages 30–34. IEEE Computer Society Press, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jagdish Bansiya</author>
<author>Letha Etzkorn</author>
<author>Carl Davis</author>
<author>Wei Li</author>
</authors>
<title>A class cohesion metric for object-oriented designs.</title>
<date>1999</date>
<journal>Journal of Object-Oriented Programming,</journal>
<volume>11</volume>
<issue>8</issue>
<contexts>
<context position="19063" citStr="[2]" startWordPosition="3082" endWordPosition="3082">ving to implement new metrics each time such a new context is introduced. The limits of our approach are that currently not all objectoriented software metrics can be defined in terms of our model independent metrics definitions. Certain metrics tend to be very specialized and are thus difficult to define in a generic way. Another problem is that for some metrics there is still no consensus about what is the best way to define them. For these reasons we did not consider coupling metrics (such as NCR [21], CF [4], CBO and RFC [6]) and cohesion metrics (such as LCOM [14, 6, 20], CR [1] and CAMC [2]). Furthermore, as, due to our research in reengineering, we come from a more pragmatic side, it is not solely the definition of the metrics which interest us. Indeed, it is the creation of concrete metrics, which we can then use for instance in CodeCrawler, which interests us. In this context other problems arise, whose solutions lie mainly at the implementation level: what are the names of those metrics, how many can we generate and when does it make sense to stop generating metrics? Are the generated metrics actually usable and which ones do make sense in the given contexts? We plan to answ</context>
</contexts>
<marker>[2]</marker>
<rawString>Jagdish Bansiya, Letha Etzkorn, Carl Davis, and Wei Li. A class cohesion metric for object-oriented designs. Journal of Object-Oriented Programming, 11(8):47–52, January 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lionel C Briand</author>
<author>John W Daly</author>
<author>Jurgen K Wust</author>
</authors>
<title>A unified framework for coupling measurement in object-oriented systems.</title>
<date>1999</date>
<journal>IEEE Transactions on Software Engineering,</journal>
<volume>25</volume>
<issue>1</issue>
<contexts>
<context position="20152" citStr="[3]" startWordPosition="3270" endWordPosition="3270">ics? Are the generated metrics actually usable and which ones do make sense in the given contexts? We plan to answer some of these questions in our future work. 5.2 Related and Future Work A great body of research has been performed on the subject of metrics. We limit ourselves to list the most important references. Metrics have long been studied as a way to assess the quality and complexity of software [15], and recently this has been applied to object-oriented software as well [21, 16]. Metrics profit from their scalability and, in the case of simple ones, from their reliable definition. In [3] a mechanism is provided for comparing measures and their potential use, integrating existing measures which examine the same concepts in different ways, and facilitating more rigorous decision making regarding the definition of new measures. This paper also provides an excellent stateof-the-art which highlights that many measures have unclear definitions, as should be the case in measurement theory. In [22] a generic metamodel is used to define metrics that abstract away from the particular metamodel elements. Because of this, the generic metrics are automatically available for all the metamo</context>
</contexts>
<marker>[3]</marker>
<rawString>Lionel C. Briand, John W. Daly, and Jürgen K. Wüst. A unified framework for coupling measurement in object-oriented systems. IEEE Transactions on Software Engineering, 25(1):91–121, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Brito e Abreu</author>
<author>M Goulao</author>
<author>R Esteves</author>
</authors>
<title>Toward the design quality evaluation of object-oriented software systems.</title>
<date>1995</date>
<booktitle>In Proc. 5th Int’l Conf. Software Quality,</booktitle>
<pages>44--57</pages>
<contexts>
<context position="18977" citStr="[4]" startWordPosition="3064" endWordPosition="3064">ial world, databases, etc.) which provides us with a standard metrics suite without having to implement new metrics each time such a new context is introduced. The limits of our approach are that currently not all objectoriented software metrics can be defined in terms of our model independent metrics definitions. Certain metrics tend to be very specialized and are thus difficult to define in a generic way. Another problem is that for some metrics there is still no consensus about what is the best way to define them. For these reasons we did not consider coupling metrics (such as NCR [21], CF [4], CBO and RFC [6]) and cohesion metrics (such as LCOM [14, 6, 20], CR [1] and CAMC [2]). Furthermore, as, due to our research in reengineering, we come from a more pragmatic side, it is not solely the definition of the metrics which interest us. Indeed, it is the creation of concrete metrics, which we can then use for instance in CodeCrawler, which interests us. In this context other problems arise, whose solutions lie mainly at the implementation level: what are the names of those metrics, how many can we generate and when does it make sense to stop generating metrics? Are the generated metri</context>
</contexts>
<marker>[4]</marker>
<rawString>F. Brito e Abreu, M. Goulao, and R. Esteves. Toward the design quality evaluation of object-oriented software systems. In Proc. 5th Int’l Conf. Software Quality, pages 44–57, October 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shyam R Chidamber</author>
<author>Chris F Kemerer</author>
</authors>
<title>Towards a metrics suite for object oriented design.</title>
<date>1991</date>
<journal>ACM SIGPLAN Notices,</journal>
<booktitle>In Proceedings OOPSLA ’91,</booktitle>
<volume>26</volume>
<pages>197--211</pages>
<contexts>
<context position="2365" citStr="[5, 17, 16]" startWordPosition="346" endWordPosition="348">gs can be applied or have been applied [9], and for detecting increases or decreases of quality in the structure of evolving software systems. In the area of software reengineering and reverse engineering [7], metrics are being used for assessing the quality and complexity of software systems, as well as getting a basic understanding and providing clues about sensitive parts of software systems. If we restrict ourselves to the field of object-oriented reengineering and object-oriented metrics, we see that this field is fairly new. In the past decade a great body of research has been conducted [5, 17, 16] and various metric suites have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal was to investigate methodologies and create tools to reengineer large software systems, and whose main results have been summarized in [12, 10], we were confronted with several large scale industrial systems written in different languages, among which C++, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language ind</context>
</contexts>
<marker>[5]</marker>
<rawString>Shyam R. Chidamber and Chris F. Kemerer. Towards a metrics suite for object oriented design. In Proceedings OOPSLA ’91, ACM SIGPLAN Notices, pages 197–211, November 1991. Published as Proceedings OOPSLA ’91, ACM SIGPLAN Notices, volume 26, number 11.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shyam R Chidamber</author>
<author>Chris F Kemerer</author>
</authors>
<title>A metrics suite for object oriented design.</title>
<date>1994</date>
<journal>IEEE Transactions on Software Engineering,</journal>
<volume>20</volume>
<issue>6</issue>
<contexts>
<context position="2418" citStr="[21, 6]" startWordPosition="356" endWordPosition="357">ting increases or decreases of quality in the structure of evolving software systems. In the area of software reengineering and reverse engineering [7], metrics are being used for assessing the quality and complexity of software systems, as well as getting a basic understanding and providing clues about sensitive parts of software systems. If we restrict ourselves to the field of object-oriented reengineering and object-oriented metrics, we see that this field is fairly new. In the past decade a great body of research has been conducted [5, 17, 16] and various metric suites have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal was to investigate methodologies and create tools to reengineer large software systems, and whose main results have been summarized in [12, 10], we were confronted with several large scale industrial systems written in different languages, among which C++, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language independent FAMIX metamodel [11]. Source code in one of </context>
<context position="18994" citStr="[6]" startWordPosition="3068" endWordPosition="3068">ses, etc.) which provides us with a standard metrics suite without having to implement new metrics each time such a new context is introduced. The limits of our approach are that currently not all objectoriented software metrics can be defined in terms of our model independent metrics definitions. Certain metrics tend to be very specialized and are thus difficult to define in a generic way. Another problem is that for some metrics there is still no consensus about what is the best way to define them. For these reasons we did not consider coupling metrics (such as NCR [21], CF [4], CBO and RFC [6]) and cohesion metrics (such as LCOM [14, 6, 20], CR [1] and CAMC [2]). Furthermore, as, due to our research in reengineering, we come from a more pragmatic side, it is not solely the definition of the metrics which interest us. Indeed, it is the creation of concrete metrics, which we can then use for instance in CodeCrawler, which interests us. In this context other problems arise, whose solutions lie mainly at the implementation level: what are the names of those metrics, how many can we generate and when does it make sense to stop generating metrics? Are the generated metrics actually usabl</context>
</contexts>
<marker>[6]</marker>
<rawString>Shyam R. Chidamber and Chris F. Kemerer. A metrics suite for object oriented design. IEEE Transactions on Software Engineering, 20(6):476–493, June 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Elliot J Chikofsky</author>
<author>James H Cross</author>
</authors>
<title>Reverse engineering and design recovery: A taxonomy.</title>
<date>1990</date>
<journal>IEEE Software,</journal>
<pages>13--17</pages>
<contexts>
<context position="1962" citStr="[7]" startWordPosition="282" endWordPosition="282"> INTRODUCTION AND MOTIVATION Metrics have become essential in some disciplines of software engineering. In forward engineering they are being used to measure software quality and to estimate cost and effort of software projects [15]. In the field of software evolution, metrics can be used for identifying stable or unstable parts of software systems, as well as for identifying where refactorings can be applied or have been applied [9], and for detecting increases or decreases of quality in the structure of evolving software systems. In the area of software reengineering and reverse engineering [7], metrics are being used for assessing the quality and complexity of software systems, as well as getting a basic understanding and providing clues about sensitive parts of software systems. If we restrict ourselves to the field of object-oriented reengineering and object-oriented metrics, we see that this field is fairly new. In the past decade a great body of research has been conducted [5, 17, 16] and various metric suites have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal wa</context>
</contexts>
<marker>[7]</marker>
<rawString>Elliot J. Chikofsky and James H. Cross, II. Reverse engineering and design recovery: A taxonomy. IEEE Software, pages 13–17, January 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Serge Demeyer</author>
<author>Stephane Ducasse</author>
<author>Michele Lanza</author>
</authors>
<title>A hybrid reverse engineering platform combining metrics and program visualization.</title>
<date>1999</date>
<booktitle>Proceedings WCRE’99 (6th Working Conference on Reverse Engineering). IEEE,</booktitle>
<editor>In Francoise Balmas, Mike Blaha, and Spencer Rugaber, editors,</editor>
<contexts>
<context position="3422" citStr="[18, 8]" startWordPosition="509" endWordPosition="510">, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language independent FAMIX metamodel [11]. Source code in one of the aforementioned languages is mapped to a language independent representation, which we present in more detail in the next section. The Moose Reengineering Environment included a metrics engine, which was first implemented to perform simple queries and then greatly extended to support the development of CodeCrawler, a software visualization tool which integrates metrics in its visualizations [18, 8]. The extended metrics engine included a suite of language independent metrics, whose computation was based exclusively on the language independent metamodel representation of software artifacts. As we are now starting the implementation of a metametamodel, where apart from artifacts defined in the FAMIX metamodel, non-software artifacts can as well be accomodated, the need has arisen to extend the language independent metrics suite to become a model independent metrics suite. In this article we present and discuss our current state of research and a first implementation of a metametamodel, an</context>
<context position="15767" citStr="[18, 8, 19]" startWordPosition="2536" endWordPosition="2538">ge independent, because we need to work with legacy systems written in different implementation languages. It is extensible, since we cannot know in advance all information that is needed in future tools, and since for some reengineering problems tools might need to work with language-specific information, we allow for language plugins that extend the model with language-specific features. Next to that, we allow tool plug-ins to extend as well the model with tool-specific information. 4.2 CodeCrawler CodeCrawler supports reverse engineering through the combination of metrics and visualization [18, 8, 19]. It visualizes entities as nodes and relatioships as edges, and renders up to five metrics on the nodes by using their width, height, color and position on the display. Through these simple visualization enriched with the large metrics suite provided by Moose, it enables the user to gain insights in large systems in a short time. CodeCrawler is a tool which works best when unknown systems are approached and quick insights are needed for reverse engineering. CodeCrawler has been successfully tested on several industrial case studies. 4.3 A Model Independent Metrics Suite The motivation to impl</context>
</contexts>
<marker>[8]</marker>
<rawString>Serge Demeyer, Stéphane Ducasse, and Michele Lanza. A hybrid reverse engineering platform combining metrics and program visualization. In Francoise Balmas, Mike Blaha, and Spencer Rugaber, editors, Proceedings WCRE’99 (6th Working Conference on Reverse Engineering). IEEE, October 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Serge Demeyer</author>
<author>Stephane Ducasse</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Finding refactorings via change metrics.</title>
<date>2000</date>
<journal>ACM SIGPLAN Notices,</journal>
<booktitle>In Proceedings of OOPSLA’2000,</booktitle>
<pages>166--178</pages>
<contexts>
<context position="1796" citStr="[9]" startWordPosition="256" endWordPosition="256">ure work for the transition from language independent to domain independent metrics. Keywords: Software Metrics, Object-Oriented Programming, Language Independence 1. INTRODUCTION AND MOTIVATION Metrics have become essential in some disciplines of software engineering. In forward engineering they are being used to measure software quality and to estimate cost and effort of software projects [15]. In the field of software evolution, metrics can be used for identifying stable or unstable parts of software systems, as well as for identifying where refactorings can be applied or have been applied [9], and for detecting increases or decreases of quality in the structure of evolving software systems. In the area of software reengineering and reverse engineering [7], metrics are being used for assessing the quality and complexity of software systems, as well as getting a basic understanding and providing clues about sensitive parts of software systems. If we restrict ourselves to the field of object-oriented reengineering and object-oriented metrics, we see that this field is fairly new. In the past decade a great body of research has been conducted [5, 17, 16] and various metric suites have</context>
</contexts>
<marker>[9]</marker>
<rawString>Serge Demeyer, Stéphane Ducasse, and Oscar Nierstrasz. Finding refactorings via change metrics. In Proceedings of OOPSLA’2000, ACM SIGPLAN Notices, pages 166–178, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Serge Demeyer</author>
<author>Stephane Ducasse</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Object-Oriented Reengineering Patterns.</title>
<date>2002</date>
<publisher>Morgan Kaufmann,</publisher>
<contexts>
<context position="2703" citStr="[12, 10]" startWordPosition="402" endWordPosition="403">roviding clues about sensitive parts of software systems. If we restrict ourselves to the field of object-oriented reengineering and object-oriented metrics, we see that this field is fairly new. In the past decade a great body of research has been conducted [5, 17, 16] and various metric suites have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal was to investigate methodologies and create tools to reengineer large software systems, and whose main results have been summarized in [12, 10], we were confronted with several large scale industrial systems written in different languages, among which C++, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language independent FAMIX metamodel [11]. Source code in one of the aforementioned languages is mapped to a language independent representation, which we present in more detail in the next section. The Moose Reengineering Environment included a metrics engine, which was first implemented to perform simple queries and then greatly extended to suppo</context>
</contexts>
<marker>[10]</marker>
<rawString>Serge Demeyer, Stéphane Ducasse, and Oscar Nierstrasz. Object-Oriented Reengineering Patterns. Morgan Kaufmann, 2002. to appear, spring 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Serge Demeyer</author>
<author>Sander Tichelaar</author>
<author>Stephane Ducasse</author>
</authors>
<title>the FAMOOS information exchange model.</title>
<date>2001</date>
<journal>FAMIX</journal>
<tech>Technical report,</tech>
<volume>2</volume>
<institution>University of Bern,</institution>
<contexts>
<context position="2994" citStr="[11]" startWordPosition="446" endWordPosition="446">s have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal was to investigate methodologies and create tools to reengineer large software systems, and whose main results have been summarized in [12, 10], we were confronted with several large scale industrial systems written in different languages, among which C++, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language independent FAMIX metamodel [11]. Source code in one of the aforementioned languages is mapped to a language independent representation, which we present in more detail in the next section. The Moose Reengineering Environment included a metrics engine, which was first implemented to perform simple queries and then greatly extended to support the development of CodeCrawler, a software visualization tool which integrates metrics in its visualizations [18, 8]. The extended metrics engine included a suite of language independent metrics, whose computation was based exclusively on the language independent metamodel representation</context>
<context position="14968" citStr="[11]" startWordPosition="2419" endWordPosition="2419"> and summation metrics. Examples. The average number of accessed attributes by the methods contained in class c will be defined as the number of attributes accessed by class c divided by the number of methods contained in class c. 4. CODECRAWLER AND MOOSE In this section we shortly present the Moose Reengineering Environment and CodeCrawler, its most prominent tool, which also was the main cause for our current work in the field of metrics. 4.1 The Moose Reengineering Environment Moose is a language independent reengineering environment written in Smalltalk. It is based on the FAMIX metamodel [11], which provides for a language independent representation of object-oriented sources and contains the required information for the reengineering tasks performed by our tools. It is language independent, because we need to work with legacy systems written in different implementation languages. It is extensible, since we cannot know in advance all information that is needed in future tools, and since for some reengineering problems tools might need to work with language-specific information, we allow for language plugins that extend the model with language-specific features. Next to that, we al</context>
<context position="20783" citStr="[11]" startWordPosition="3367" endWordPosition="3367">r comparing measures and their potential use, integrating existing measures which examine the same concepts in different ways, and facilitating more rigorous decision making regarding the definition of new measures. This paper also provides an excellent stateof-the-art which highlights that many measures have unclear definitions, as should be the case in measurement theory. In [22] a generic metamodel is used to define metrics that abstract away from the particular metamodel elements. Because of this, the generic metrics are automatically available for all the metamodels (such as UML or FAMIX [11] that are mapped to the generic metamodel. For reasons of simplicity, we did not provide subtype relationships in our metamodel. However, most metamodeling approaches (such as UML) make use of subtypes. By exploiting this subtype information we can make our framework even more generic. At this time we only use properties for the nodes. In some cases it could also be useful to use properties on the edges. For example, we can make a distinction between access edges which retrieve or change the value of an attribute. In the future we plan to extend our metametamodel and its model independent metr</context>
</contexts>
<marker>[11]</marker>
<rawString>Serge Demeyer, Sander Tichelaar, and Stéphane Ducasse. FAMIX 2.1 - the FAMOOS information exchange model. Technical report, University of Bern, 2001.</rawString>
</citation>
<citation valid="true">
<date>1999</date>
<booktitle>The FAMOOS Object-Oriented Reengineering Handbook. University of Bern,</booktitle>
<editor>Stephane Ducasse and Serge Demeyer, editors.</editor>
<note>See http://www.iam.unibe.ch/˜famoos/handbook.</note>
<contexts>
<context position="2703" citStr="[12, 10]" startWordPosition="402" endWordPosition="403">roviding clues about sensitive parts of software systems. If we restrict ourselves to the field of object-oriented reengineering and object-oriented metrics, we see that this field is fairly new. In the past decade a great body of research has been conducted [5, 17, 16] and various metric suites have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal was to investigate methodologies and create tools to reengineer large software systems, and whose main results have been summarized in [12, 10], we were confronted with several large scale industrial systems written in different languages, among which C++, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language independent FAMIX metamodel [11]. Source code in one of the aforementioned languages is mapped to a language independent representation, which we present in more detail in the next section. The Moose Reengineering Environment included a metrics engine, which was first implemented to perform simple queries and then greatly extended to suppo</context>
</contexts>
<marker>[12]</marker>
<rawString>Stéphane Ducasse and Serge Demeyer, editors. The FAMOOS Object-Oriented Reengineering Handbook. University of Bern, October 1999. See http://www.iam.unibe.ch/˜famoos/handbook.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stephane Ducasse</author>
<author>Michele Lanza</author>
<author>Sander Tichelaar</author>
</authors>
<title>The moose reengineering environment. Smalltalk Chronicles,</title>
<date>2001</date>
<contexts>
<context position="2903" citStr="[13]" startWordPosition="432" endWordPosition="432">ast decade a great body of research has been conducted [5, 17, 16] and various metric suites have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal was to investigate methodologies and create tools to reengineer large software systems, and whose main results have been summarized in [12, 10], we were confronted with several large scale industrial systems written in different languages, among which C++, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language independent FAMIX metamodel [11]. Source code in one of the aforementioned languages is mapped to a language independent representation, which we present in more detail in the next section. The Moose Reengineering Environment included a metrics engine, which was first implemented to perform simple queries and then greatly extended to support the development of CodeCrawler, a software visualization tool which integrates metrics in its visualizations [18, 8]. The extended metrics engine included a suite of language independent metrics, w</context>
</contexts>
<marker>[13]</marker>
<rawString>Stéphane Ducasse, Michele Lanza, and Sander Tichelaar. The moose reengineering environment. Smalltalk Chronicles, August 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Letha Etzkorn</author>
<author>Carl Davis</author>
<author>Wei Li</author>
</authors>
<title>A practical look at the lack of cohesion in methods metric.</title>
<date>1998</date>
<journal>Journal of Object-Oriented Programming,</journal>
<volume>11</volume>
<issue>5</issue>
<contexts>
<context position="19042" citStr="[14, 6, 20]" startWordPosition="3075" endWordPosition="3077">dard metrics suite without having to implement new metrics each time such a new context is introduced. The limits of our approach are that currently not all objectoriented software metrics can be defined in terms of our model independent metrics definitions. Certain metrics tend to be very specialized and are thus difficult to define in a generic way. Another problem is that for some metrics there is still no consensus about what is the best way to define them. For these reasons we did not consider coupling metrics (such as NCR [21], CF [4], CBO and RFC [6]) and cohesion metrics (such as LCOM [14, 6, 20], CR [1] and CAMC [2]). Furthermore, as, due to our research in reengineering, we come from a more pragmatic side, it is not solely the definition of the metrics which interest us. Indeed, it is the creation of concrete metrics, which we can then use for instance in CodeCrawler, which interests us. In this context other problems arise, whose solutions lie mainly at the implementation level: what are the names of those metrics, how many can we generate and when does it make sense to stop generating metrics? Are the generated metrics actually usable and which ones do make sense in the given cont</context>
</contexts>
<marker>[14]</marker>
<rawString>Letha Etzkorn, Carl Davis, and Wei Li. A practical look at the lack of cohesion in methods metric. Journal of Object-Oriented Programming, 11(5):27–34, September 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Norman Fenton</author>
<author>Shari Lawrence Pfleeger</author>
</authors>
<title>Software Metrics: A Rigorous and Practical Approach.</title>
<date>1996</date>
<publisher>International Thomson Computer Press,</publisher>
<location>London, UK,</location>
<note>second edition,</note>
<contexts>
<context position="1591" citStr="[15]" startWordPosition="221" endWordPosition="221"> metamodel and allow for several extension in different research directions, among which concept analysis, knowledge management and software evolution. In this article we want to present our current and future work for the transition from language independent to domain independent metrics. Keywords: Software Metrics, Object-Oriented Programming, Language Independence 1. INTRODUCTION AND MOTIVATION Metrics have become essential in some disciplines of software engineering. In forward engineering they are being used to measure software quality and to estimate cost and effort of software projects [15]. In the field of software evolution, metrics can be used for identifying stable or unstable parts of software systems, as well as for identifying where refactorings can be applied or have been applied [9], and for detecting increases or decreases of quality in the structure of evolving software systems. In the area of software reengineering and reverse engineering [7], metrics are being used for assessing the quality and complexity of software systems, as well as getting a basic understanding and providing clues about sensitive parts of software systems. If we restrict ourselves to the field </context>
<context position="19960" citStr="[15]" startWordPosition="3239" endWordPosition="3239">t other problems arise, whose solutions lie mainly at the implementation level: what are the names of those metrics, how many can we generate and when does it make sense to stop generating metrics? Are the generated metrics actually usable and which ones do make sense in the given contexts? We plan to answer some of these questions in our future work. 5.2 Related and Future Work A great body of research has been performed on the subject of metrics. We limit ourselves to list the most important references. Metrics have long been studied as a way to assess the quality and complexity of software [15], and recently this has been applied to object-oriented software as well [21, 16]. Metrics profit from their scalability and, in the case of simple ones, from their reliable definition. In [3] a mechanism is provided for comparing measures and their potential use, integrating existing measures which examine the same concepts in different ways, and facilitating more rigorous decision making regarding the definition of new measures. This paper also provides an excellent stateof-the-art which highlights that many measures have unclear definitions, as should be the case in measurement theory. In [</context>
</contexts>
<marker>[15]</marker>
<rawString>Norman Fenton and Shari Lawrence Pfleeger. Software Metrics: A Rigorous and Practical Approach. International Thomson Computer Press, London, UK, second edition, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Brian Henderson-Sellers</author>
</authors>
<title>Object-Oriented Metrics: Measures of Complexity.</title>
<date>1996</date>
<publisher>Prentice-Hall,</publisher>
<contexts>
<context position="2365" citStr="[5, 17, 16]" startWordPosition="346" endWordPosition="348">gs can be applied or have been applied [9], and for detecting increases or decreases of quality in the structure of evolving software systems. In the area of software reengineering and reverse engineering [7], metrics are being used for assessing the quality and complexity of software systems, as well as getting a basic understanding and providing clues about sensitive parts of software systems. If we restrict ourselves to the field of object-oriented reengineering and object-oriented metrics, we see that this field is fairly new. In the past decade a great body of research has been conducted [5, 17, 16] and various metric suites have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal was to investigate methodologies and create tools to reengineer large software systems, and whose main results have been summarized in [12, 10], we were confronted with several large scale industrial systems written in different languages, among which C++, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language ind</context>
<context position="20041" citStr="[21, 16]" startWordPosition="3251" endWordPosition="3252">l: what are the names of those metrics, how many can we generate and when does it make sense to stop generating metrics? Are the generated metrics actually usable and which ones do make sense in the given contexts? We plan to answer some of these questions in our future work. 5.2 Related and Future Work A great body of research has been performed on the subject of metrics. We limit ourselves to list the most important references. Metrics have long been studied as a way to assess the quality and complexity of software [15], and recently this has been applied to object-oriented software as well [21, 16]. Metrics profit from their scalability and, in the case of simple ones, from their reliable definition. In [3] a mechanism is provided for comparing measures and their potential use, integrating existing measures which examine the same concepts in different ways, and facilitating more rigorous decision making regarding the definition of new measures. This paper also provides an excellent stateof-the-art which highlights that many measures have unclear definitions, as should be the case in measurement theory. In [22] a generic metamodel is used to define metrics that abstract away from the par</context>
</contexts>
<marker>[16]</marker>
<rawString>Brian Henderson-Sellers. Object-Oriented Metrics: Measures of Complexity. Prentice-Hall, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Hitz</author>
<author>B Montazeri</author>
</authors>
<title>Chidamber and kemerer’s metrics suite; a measurement theory perspective.</title>
<date>1996</date>
<journal>IEEE Transactions on Software Engineering,</journal>
<volume>22</volume>
<issue>4</issue>
<contexts>
<context position="2365" citStr="[5, 17, 16]" startWordPosition="346" endWordPosition="348">gs can be applied or have been applied [9], and for detecting increases or decreases of quality in the structure of evolving software systems. In the area of software reengineering and reverse engineering [7], metrics are being used for assessing the quality and complexity of software systems, as well as getting a basic understanding and providing clues about sensitive parts of software systems. If we restrict ourselves to the field of object-oriented reengineering and object-oriented metrics, we see that this field is fairly new. In the past decade a great body of research has been conducted [5, 17, 16] and various metric suites have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal was to investigate methodologies and create tools to reengineer large software systems, and whose main results have been summarized in [12, 10], we were confronted with several large scale industrial systems written in different languages, among which C++, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language ind</context>
</contexts>
<marker>[17]</marker>
<rawString>M. Hitz and B. Montazeri. Chidamber and kemerer’s metrics suite; a measurement theory perspective. IEEE Transactions on Software Engineering, 22(4):267–271, April 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michele Lanza</author>
</authors>
<title>Combining metrics and graphs for object oriented reverse engineering. Diploma thesis,</title>
<date>1999</date>
<institution>University of Bern,</institution>
<contexts>
<context position="3422" citStr="[18, 8]" startWordPosition="509" endWordPosition="510">, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language independent FAMIX metamodel [11]. Source code in one of the aforementioned languages is mapped to a language independent representation, which we present in more detail in the next section. The Moose Reengineering Environment included a metrics engine, which was first implemented to perform simple queries and then greatly extended to support the development of CodeCrawler, a software visualization tool which integrates metrics in its visualizations [18, 8]. The extended metrics engine included a suite of language independent metrics, whose computation was based exclusively on the language independent metamodel representation of software artifacts. As we are now starting the implementation of a metametamodel, where apart from artifacts defined in the FAMIX metamodel, non-software artifacts can as well be accomodated, the need has arisen to extend the language independent metrics suite to become a model independent metrics suite. In this article we present and discuss our current state of research and a first implementation of a metametamodel, an</context>
<context position="15767" citStr="[18, 8, 19]" startWordPosition="2536" endWordPosition="2538">ge independent, because we need to work with legacy systems written in different implementation languages. It is extensible, since we cannot know in advance all information that is needed in future tools, and since for some reengineering problems tools might need to work with language-specific information, we allow for language plugins that extend the model with language-specific features. Next to that, we allow tool plug-ins to extend as well the model with tool-specific information. 4.2 CodeCrawler CodeCrawler supports reverse engineering through the combination of metrics and visualization [18, 8, 19]. It visualizes entities as nodes and relatioships as edges, and renders up to five metrics on the nodes by using their width, height, color and position on the display. Through these simple visualization enriched with the large metrics suite provided by Moose, it enables the user to gain insights in large systems in a short time. CodeCrawler is a tool which works best when unknown systems are approached and quick insights are needed for reverse engineering. CodeCrawler has been successfully tested on several industrial case studies. 4.3 A Model Independent Metrics Suite The motivation to impl</context>
</contexts>
<marker>[18]</marker>
<rawString>Michele Lanza. Combining metrics and graphs for object oriented reverse engineering. Diploma thesis, University of Bern, October 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Michele Lanza</author>
<author>Stephane Ducasse</author>
</authors>
<title>A categorization of classes based on the visualization of their internal structure: the class blueprint.</title>
<date>2001</date>
<booktitle>In Proceedings of OOPSLA</booktitle>
<pages>300--311</pages>
<contexts>
<context position="15767" citStr="[18, 8, 19]" startWordPosition="2536" endWordPosition="2538">ge independent, because we need to work with legacy systems written in different implementation languages. It is extensible, since we cannot know in advance all information that is needed in future tools, and since for some reengineering problems tools might need to work with language-specific information, we allow for language plugins that extend the model with language-specific features. Next to that, we allow tool plug-ins to extend as well the model with tool-specific information. 4.2 CodeCrawler CodeCrawler supports reverse engineering through the combination of metrics and visualization [18, 8, 19]. It visualizes entities as nodes and relatioships as edges, and renders up to five metrics on the nodes by using their width, height, color and position on the display. Through these simple visualization enriched with the large metrics suite provided by Moose, it enables the user to gain insights in large systems in a short time. CodeCrawler is a tool which works best when unknown systems are approached and quick insights are needed for reverse engineering. CodeCrawler has been successfully tested on several industrial case studies. 4.3 A Model Independent Metrics Suite The motivation to impl</context>
</contexts>
<marker>[19]</marker>
<rawString>Michele Lanza and Stéphane Ducasse. A categorization of classes based on the visualization of their internal structure: the class blueprint. In Proceedings of OOPSLA 2001, pages 300–311, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W Li</author>
<author>S Henry</author>
</authors>
<title>Object oriented metrics that predict maintainability.</title>
<date>1993</date>
<journal>Journal of System Software,</journal>
<volume>23</volume>
<issue>2</issue>
<contexts>
<context position="19042" citStr="[14, 6, 20]" startWordPosition="3075" endWordPosition="3077">dard metrics suite without having to implement new metrics each time such a new context is introduced. The limits of our approach are that currently not all objectoriented software metrics can be defined in terms of our model independent metrics definitions. Certain metrics tend to be very specialized and are thus difficult to define in a generic way. Another problem is that for some metrics there is still no consensus about what is the best way to define them. For these reasons we did not consider coupling metrics (such as NCR [21], CF [4], CBO and RFC [6]) and cohesion metrics (such as LCOM [14, 6, 20], CR [1] and CAMC [2]). Furthermore, as, due to our research in reengineering, we come from a more pragmatic side, it is not solely the definition of the metrics which interest us. Indeed, it is the creation of concrete metrics, which we can then use for instance in CodeCrawler, which interests us. In this context other problems arise, whose solutions lie mainly at the implementation level: what are the names of those metrics, how many can we generate and when does it make sense to stop generating metrics? Are the generated metrics actually usable and which ones do make sense in the given cont</context>
</contexts>
<marker>[20]</marker>
<rawString>W. Li and S. Henry. Object oriented metrics that predict maintainability. Journal of System Software, 23(2):111–122, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Lorenz</author>
<author>Jeff Kidd</author>
</authors>
<title>Object-Oriented Software Metrics: A Practical Guide.</title>
<date>1994</date>
<publisher>Prentice-Hall,</publisher>
<contexts>
<context position="2418" citStr="[21, 6]" startWordPosition="356" endWordPosition="357">ting increases or decreases of quality in the structure of evolving software systems. In the area of software reengineering and reverse engineering [7], metrics are being used for assessing the quality and complexity of software systems, as well as getting a basic understanding and providing clues about sensitive parts of software systems. If we restrict ourselves to the field of object-oriented reengineering and object-oriented metrics, we see that this field is fairly new. In the past decade a great body of research has been conducted [5, 17, 16] and various metric suites have been proposed [21, 6], which cover most of the relevant aspects of object-oriented software. In the context of the European FAMOOS Esprit Project, whose main goal was to investigate methodologies and create tools to reengineer large software systems, and whose main results have been summarized in [12, 10], we were confronted with several large scale industrial systems written in different languages, among which C++, Java, Smalltalk and Ada. Therefore we created the Moose Reengineering Environment [13], a repository and tool environment, based on the language independent FAMIX metamodel [11]. Source code in one of </context>
<context position="18969" citStr="[21]" startWordPosition="3062" endWordPosition="3062">he financial world, databases, etc.) which provides us with a standard metrics suite without having to implement new metrics each time such a new context is introduced. The limits of our approach are that currently not all objectoriented software metrics can be defined in terms of our model independent metrics definitions. Certain metrics tend to be very specialized and are thus difficult to define in a generic way. Another problem is that for some metrics there is still no consensus about what is the best way to define them. For these reasons we did not consider coupling metrics (such as NCR [21], CF [4], CBO and RFC [6]) and cohesion metrics (such as LCOM [14, 6, 20], CR [1] and CAMC [2]). Furthermore, as, due to our research in reengineering, we come from a more pragmatic side, it is not solely the definition of the metrics which interest us. Indeed, it is the creation of concrete metrics, which we can then use for instance in CodeCrawler, which interests us. In this context other problems arise, whose solutions lie mainly at the implementation level: what are the names of those metrics, how many can we generate and when does it make sense to stop generating metrics? Are the generat</context>
</contexts>
<marker>[21]</marker>
<rawString>Mark Lorenz and Jeff Kidd. Object-Oriented Software Metrics: A Practical Guide. Prentice-Hall, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Vojislav B Misic</author>
<author>Simon Moser</author>
</authors>
<title>From formal metamodels to metrics: An object-oriented approach.</title>
<date>1998</date>
<booktitle>In Proc. Technology of Object-Oriented Languages and Systems (TOOLS-24).</booktitle>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="20563" citStr="[22]" startWordPosition="3331" endWordPosition="3331">], and recently this has been applied to object-oriented software as well [21, 16]. Metrics profit from their scalability and, in the case of simple ones, from their reliable definition. In [3] a mechanism is provided for comparing measures and their potential use, integrating existing measures which examine the same concepts in different ways, and facilitating more rigorous decision making regarding the definition of new measures. This paper also provides an excellent stateof-the-art which highlights that many measures have unclear definitions, as should be the case in measurement theory. In [22] a generic metamodel is used to define metrics that abstract away from the particular metamodel elements. Because of this, the generic metrics are automatically available for all the metamodels (such as UML or FAMIX [11] that are mapped to the generic metamodel. For reasons of simplicity, we did not provide subtype relationships in our metamodel. However, most metamodeling approaches (such as UML) make use of subtypes. By exploiting this subtype information we can make our framework even more generic. At this time we only use properties for the nodes. In some cases it could also be useful to u</context>
</contexts>
<marker>[22]</marker>
<rawString>Vojislav B. Mǐsić and Simon Moser. From formal metamodels to metrics: An object-oriented approach. In Proc. Technology of Object-Oriented Languages and Systems (TOOLS-24). IEEE Computer Society Press, 1998.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>