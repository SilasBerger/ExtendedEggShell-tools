<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.8362185">
Declaratively Codifying Software Architectures
using Virtual Software Classi cations
</title>
<author confidence="0.803699">
Kim Mens and Roel Wuytsy
</author>
<affiliation confidence="0.611436">
Programming Technology Lab
</affiliation>
<table confidence="0.5153145">
Vrije Universiteit Brussel
Pleinlaan 2, 1050 Brussel, Belgium
e-mail: f kimmens j rwuyts g@vub.ac.be
February 16, 1999
</table>
<sectionHeader confidence="0.949856" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.9970444">
Most current-day software engineering tools and environments do not suciently allow
software engineers to declare or enforce the intended software architecture. On the one hand,
architectures are typically described at a too low level, inhibiting their evolution and un-
derstanding. On the other hand most tools provide little support to automatically verify
whether the source code conforms to the architecture. Therefore, a formalism is needed in
which architectures can be expressed at a suciently abstract level, without losing the ability
to perform automatic conformance checking. We propose to declaratively codify software ar-
chitectures using virtual software classi cations and relationships among these classi cations.
We illustrate how software architectures can be expressed elegantly in terms of these virtual
classi cations and how to keep them synchronized with the source code.
</bodyText>
<sectionHeader confidence="0.998245" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.997251631578947">
The problem of architectural mismatch [GAO95] is a well-known problem: by the time an archi-
tecture speci cation is published, it is already wrong. It is also an important problem, because
although the time to design an architecture may take up to one year, the engineers must then live
with the architecture for up to 15 years of development and maintenance [SSWA96].
To solve the problem of architectural mismatch, we not only need to describe the software
architecture explicitly at a suciently high level of abstraction, but also provide support for
keeping the source code conform to it. Therefore, the contribution of this paper is to present
a formalism in which architectural knowledge can be codi ed1 with the ability to automatically
check conformance of source code. Preferably, such a formalism should possess the following
characteristics:
 It should allow reasoning at suciently high levels of abstraction, i.e., in terms of the com-
ponents that are the focus of interest at that time. At architectural level, we reason about
components, connectors, architectural styles, . . . ; at design level, we reason in terms of
classes, methods, inheritance, aggregations, . . . and at implementation level we are inter-
ested in individual statements, message expressions, and so on.
 We prefer a declarative formalism because this makes the architectural descriptions easier
to understand and maintain.
Research funded by the Brussels Capital Region (Belgium)
yResearch conducted on a doctoral grant from the Instituut voorWetenschap en Technologie (Flanders, Belgium)
</bodyText>
<footnote confidence="0.923139">
1We use the term `codifying&amp;apos; in a slightly stronger sense than [SG96]. In our terminology, `codifying&amp;apos; means:
\to make explicit so that it can be automatically manipulated in tools&quot;.
</footnote>
<page confidence="0.617603">
1
</page>
<bodyText confidence="0.96919156">
 Because we do not want to be limited in expressiveness, we want to use a full-
edged pro-
gramming language. More speci cally, because we want a declarative formalism, we prefer a
logic programming language in which we can exploit the full power of uni cation.
 To allow conformance checking of the source code to the architecture, we need an explicit
link between source-code artifacts and high-level architectural abstractions. We want to be
able to map architectural components and relationships to all possible kinds of source-code
artifacts and dependencies.
 We want the formalism to be as open as possible. For example, it should be possible at all
times to introduce new kinds of relationships between architectural components, to reason
about new kinds of source-code artifacts at architectural level, or to de ne new mappings
between architectural components and source-level artifacts.
The formalismwe propose in this paper adheres to the above characteristics. More speci cally,
we will introduce virtual classi cations to map source-level artifacts to higher-level architectural
components (and vice versa). We will declare explicit relationships between these virtual classi -
cations that describe the co-operations among them. The underlying medium that will allow us
to de ne virtual classi cations and their relationships, and that links them to the source code is
SOUL, the Smalltalk Open Uni cation Language [Wuy98]. This combination allows us to codify
explicitly and declaratively software architectures at a high level of abstraction. We will present
an example of declaring an architecture in this formalism, and illustrate how to automatically
check conformance of the source code to this architecture.
Before explaining our approach in section 3, we highlight the essential di erences with some
closely related work in the next section. Section 4 illustrates and validates our approach by means
of some experiments. Before concluding (section 6), section 5 discusses the achieved results and
future work.
</bodyText>
<sectionHeader confidence="0.969056" genericHeader="related work">
2 Related Work on Software Architectures
</sectionHeader>
<bodyText confidence="0.996891615384616">
The architecture of a software system de nes that system in terms of high-level components and
interactions among those components. In addition to specifying the structure and topology of the
system, the architecture shows the correspondence between the system requirements and elements
of the constructed system, thereby providing some rationale for the design decisions [SG96]. In
this paper, we focus on the structural aspects of software architectures only.
Shaw and Garlan [SG96] provide a taxonomy of some of the current issues in software archi-
tecture research. Using this taxonomy some may want to characterize our work as the search for
new Architectural Description Languages (ADLs). Personally, we would situate it in the area of
developing formalisms for reasoning about architectural designs. SOUL should therefore be viewed
merely as a medium in which we validate our claims about the proposed formalism. We do not
intend to promote SOUL as a new or better ADL.
In the area of software architecture, much research has been done that is similar to ours.
Murphy [MNS95] introduces `software re
exion models&amp;apos; that show where an engineer&amp;apos;s high-level
model of the software does and does not agree with a source model, based on a declarative
mapping between the two models. Module Interconnection Languages (MILs) [PDN87] can be
used to formally describe the global structure of a software system, by specifying the interfaces
and interconnections among the components (`modules&amp;apos;) that make up the system. These formal
descriptions can be processed automatically to verify system integrity. A MIL describes the
interconnections between modules in terms of the entities they contain (e.g. variables, constants,
procedures, type de nitions, ...). Typical syntax primitives are: provide, require, has-access-to and
consists-of.
Shaw and Garlan [SG96] argue that MILs force software architects to use a lower level of
abstraction than is appropriate, because they focus too much on `implementation&amp;apos; rather than
`interaction&amp;apos; relationships between modules. In our opinion, software re
exion models su er from
</bodyText>
<page confidence="0.980948">
2
</page>
<bodyText confidence="0.999138909090909">
the same problem: high-level relationships between architectural components are typicallymapped
to calling relations, le-dependencies, cross-reference lists and so on. Our formalism tries to extend
approaches such as software re
exion models or MILs, to higher levels of abstraction allowing, for
example, the declaration of:
 architectural components that are mapped to multiple software artifacts spread throughout
the source code;
 more complex relations dealing with transitive closures, protocols, programming conventions,
design styles, ...;
 higher-level architectural components that are described in terms of other high-level compo-
nents and relationships themselves.
Another di erence between software re
exion models and our approach is the di erence in
focus. To obtain more
exibility and eciency  |at the cost of decreased precision  |GailMurphy
[MN95] rejects the use of parsers, but uses lexically-based tools that produce approximate results
to extract information from source code. We approach the problem from the other end of the
spectrum. Because we do not want to restrict a priori the kinds of source-code artifacts we want
to reason about at architectural level, we do use parsers. Furthermore, to allow powerful reasoning
about this information, we use the technique of uni cation. Our goal is to allow describing
software architectures at the highest abstraction level possible (without losing the ability to verify
conformance of source code), at the cost of decreased eciency.
</bodyText>
<sectionHeader confidence="0.974676" genericHeader="method">
3 Our Approach
</sectionHeader>
<bodyText confidence="0.999789857142857">
In developing our formalism,we were inspired by De Hondt&amp;apos;s dissertation about software classi ca-
tion as an approach to architectural recovery in evolving object-oriented systems [Hon98]. In this
paper, we will investigate the power of virtual software classi cations to codify and reason about
software architectures. Another source of inspiration was SOUL, the Smalltalk Open Uni cation
Language [Wuy98], which we chose as a medium in which to conduct our experiments. In the next
subsections, we clarify both virtual classi cations and SOUL, and explain which experiments we
conducted to justify the claims of this paper.
</bodyText>
<subsectionHeader confidence="0.999318">
3.1 Virtual Classi cations
</subsectionHeader>
<bodyText confidence="0.980301071428571">
In his PhD dissertation [Hon98], De Hondt reports on positive experiences with recovering archi-
tectural knowledge in terms of simple software classi cations. The idea of a software classi cation
is to group together software artifacts that should be considered as a whole. All artifacts in such
a classi cation typically share some important feature2.
In this paper we investigate to which extent virtual classi cations of software artifacts and the
relationships among such classi cations can be used to declare explicitly architectural knowledge.
Virtual classi cations are special classi cations that compute their elements. This makes them
more abstract than manually constructed classi cations, because they actually describe in an ex-
plicit (and in our case, declarative) way which artifacts are intended to belong to the classi cation.
For reasons of brevity, in the remainder of this paper we will often write `virtual classi cation&amp;apos;
or even `classi cation&amp;apos; instead of `virtual software classi cation&amp;apos;. When we mean `software classi-
cation&amp;apos; in the sense of [Hon98], this will be explicitly mentioned. Also note that our terminology
of `virtual classi cation&amp;apos; di ers slightly from that of De Hondt [Hon98]: our de nition of virtual
classi cation corresponds to his de nition of `computed classi cation&amp;apos;.
</bodyText>
<footnote confidence="0.877897">
2Jacobson [JGJ97] provides some examples of (functional) features and the FODA methodology [KCH+90]
considers distinct types of features: operational, non-functional, development, . . .
</footnote>
<page confidence="0.98026">
3
</page>
<figureCaption confidence="0.999796">
Figure 1: Rule-Based System Architecture
</figureCaption>
<subsectionHeader confidence="0.983418">
3.2 SOUL
</subsectionHeader>
<bodyText confidence="0.995073416666667">
SOUL is a re
ective, PROLOG-like, declarative rule-based language implemented in Smalltalk
[Wuy98]. It allows the declaration of structural rules about Smalltalk source code. These rules
can be used to query the software system to nd occurrences of certain structures, or to enforce
the presence of structures. Currently, SOUL comes with a layered framework of rules that allow
reasoning at the implementation and the design level.
In this paper, we not only use SOUL as a medium in which to codify architectural knowledge
(by adding an architectural layer), but also as a case study to express the architecture of the SOUL
reasoning engine. We chose this case, not only because of our rst hand knowledge of the SOUL
implementation, but also because the basic architecture of rule-based systems is explicitly docu-
mented upon in literature. Our slightly modi ed variant of the rule-based architecture presented
in [SG96, HR85] is depicted in gure 1.
</bodyText>
<subsectionHeader confidence="0.996263">
3.3 Validation
</subsectionHeader>
<bodyText confidence="0.946497">
In order to validate the claims made in section 1 we need to show two things:
</bodyText>
<listItem confidence="0.623022666666667">
1. that virtual classi cations and their relationships codify software architectures at a su-
ciently abstract level,
2. that we can automatically check conformance of source code to the architectural descriptions.
</listItem>
<bodyText confidence="0.999018545454545">
Therefore, we set up the following experiment: we codify the architecture of the SOUL reason-
ing engine and check the conformance of the actual (Smalltalk) implementation of SOUL to this
architecture. The architecture is depicted in gure 2 which is a re nement of gure 1. More par-
ticularly the names of some virtual classi cations were made a bit more speci c, the relationships
were given an intuitive name such as uses or creates (optionally annotated with a `*&amp;apos; denoting the
transitive closure of that relationship), and two cardinalities were attached to each relationship.
The cardinality 9 means `one or more&amp;apos; or `at least one&amp;apos; and 8 means `every&amp;apos;. For example the `uses&amp;apos;
relationship between `Input&amp;apos; and `Query Interpreter&amp;apos; could be read as: `every item in the Input
classi cation should use at least one item in the Query Interpreter classi cation&amp;apos;. Note that the
all-to-one cardinality 8 is stronger than typical many-to-one cardinalities available in most design
notations.
</bodyText>
<sectionHeader confidence="0.9995" genericHeader="method">
4 Experiments
</sectionHeader>
<bodyText confidence="0.998857">
Using the experiment described in section 3.3 we argue why virtual classi cations and their re-
lationships seem to provide a good abstraction for describing architectural entities, ranging from
</bodyText>
<page confidence="0.98771">
4
</page>
<figureCaption confidence="0.999235">
Figure 2: SOUL Reasoning Engine Architecture
</figureCaption>
<bodyText confidence="0.8582152">
architectural components and connectors, through architectures and subarchitectures, to archi-
tectural patterns. Using the same experiment we explain how to perform conformance checking:
we explain how virtual classi cations can be computed from source-code artifacts, how relations
among virtual classi cations are mapped to more primitive dependencies between source-code arti-
facts and how to check conformance of entire architectures (possibly containing subarchitectures).
</bodyText>
<subsectionHeader confidence="0.99983">
4.1 Declaring Virtual Classi cations
</subsectionHeader>
<bodyText confidence="0.939703619047619">
This rst section declares the virtual classi cations of the SOUL reasoning engine architecture
depicted in gure 2. This illustrates how virtual classi cations expressed in SOUL provide an
abstract mapping of high-level architectural entities to low-level source-code artifacts. All code
extracts are presented in SOUL syntax which is very similar to Prolog syntax, with a few note-
worthy di erences. Instead of using square brackets `[&amp;apos; and `]&amp;apos;, SOUL lists are delimited by `&amp;lt;&amp;apos;
and `&amp;gt;&amp;apos;. In SOUL, `[ ... ]&amp;apos; denotes a re-i cation of Smalltalk code in the SOUL language. Finally,
SOUL variables start with a `?&amp;apos; instead of with a capital.
The experiment starts with virtual classi cations that are straightforward mappings to source-
code artifacts, but we then show mappings that cross-cut the system, or that are expressed in
terms of other architectural entities.
Working Memory. The rst virtual classi cation we declare is workingMemory. Conceptually
this classi cation contains only those classes that have something to do with the working
memory of the SOUL reasoning engine. This boils down to the SOULBindings class and all
subclasses thereof, because these are responsible for handling the bindings that are assigned
to variables during uni cation. This is straightforwardly implemented as follows, using the
prede ned hierarchy predicate:
Rule classIsClassi edAs(?Class, workingMemory) if
hierarchy([SOULBindings], ?Class).
Once this rule is de ned, we can launch a query that computes all classes belonging to this
classi cation. This query results in every class that is a subclass of SOULBindings.
Query classIsClassi edAs(?Class, workingMemory).
</bodyText>
<footnote confidence="0.91954225">
Rule Selection. The classi cation ruleSelection groups all software artifacts that deal with se-
lecting the relevant rules from the logic repository during query evaluation. This classi cation
consists of methods3 only, namely all methods named unifyingClauses: de ned on classes in
3In SOUL, methods will be represented by their parse-tree representation, including their class, name and body.
</footnote>
<page confidence="0.991919">
5
</page>
<bodyText confidence="0.983049">
the SOUL system. The body of the rule implementing this consists of a conjunction of two
statements: the rst restricts the scope to SOUL classes (using an auxiliary classi cation
soulClass), and the second retrieves from these classes all methods named unifyingClauses:.
The prede ned SOUL predicate classImplements nds the method with a given name in a
given class.
Rule methodIsClassi edAs(?Method, ruleSelection) if
classIsClassi edAs(?Class, soulClass),
classImplements(?Class, [#unifyingClauses:], ?Method).
Although this classi cation looks very simple, it actually speci es a mapping that crosses
the boundaries among many di erent classes and hierarchies: the ruleSelection methods can
be spread throughout the entire SOUL system.
Query Interpreter. The queryInterpreter classi cation consists of all methods that deal with
the actual interpretation of queries. Conceptually, these are all the methods that get called
 |directly or indirectly  |when a query is interpreted. Because interpretation of a query
is started by invoking the method interpret:repository: on class SOULQuery, we merely
need to compute the transitive closure of all methods that are invoked by this method. For
reasons of eciency, we also restrict the scope to relevant classes and methods only, skipping
for example methods that have to do with input/output, displaying, . . . All this is done by
the auxiliary predicate reaches.
Rule methodIsClassi edAs(?Method, queryInterpreter) if
classImplements([SOULQuery], [#interpret:repository:], ?M),
reaches(?M, ?Method).
Note that this classi cation de nes a real cross-cut of the SOUL code, starting from one
method and collecting all methods that are transitively invoked by this initiating method.
Input. The input classi cation is an example of a classi cation that is not de ned directly as
a mapping to lower-level artifacts, but at a higher and more abstract level, in terms of its
relation with another classi cation. It contains the classes that initiate the interpretation
process of a query. Conceptually, these are the classes that belong to the soulApplication
classi cation consisting of all SOUL GUI applications, and that use a method that is classi ed
in the queryInterpreter classi cation.
Rule classIsClassi edAs(?Class, input) if
classIsClassi edAs(?Class, soulApplication),
methodIsClassi edAs(?Method, queryInterpreter),
uses(?Class, ?Method).
Repository. The repository of a rule-based system is typically made up of a rule base and the
fact memory. We de ned this classi cation as consisting of methods that access (read or
write) directly or indirectly the instance variable clauses of class SOULRepository.
Results. The results classi cation contains software artifacts that deal with the results of queries.
In SOUL this is done by one class, SOULResult, so the classi cation contains just this class
and its subclasses.
</bodyText>
<subsectionHeader confidence="0.999702">
4.2 Codifying a Software Architecture
</subsectionHeader>
<bodyText confidence="0.998293">
This section illustrates how to codify a software architecture using virtual classi cations and
relationships among them. We also show how conformance checking from source code to an
architecture is done.
</bodyText>
<page confidence="0.986883">
6
</page>
<subsubsectionHeader confidence="0.997483">
4.2.1 Relationships between Components
</subsubsectionHeader>
<bodyText confidence="0.990558235294118">
Before discussing how to describe software architectures using virtual classi cations and their
relationships, we rst explain the kinds of relationships that can be expressed. The idea is to
connect architectural components (in our case: virtual classi cations) with high-level intuitive
connectors such as uses, creates, accesses, ... However, because we want to check conformance
to architectures, and architectural relationships in particular, we need to map these high-level
connectors to more primitive dependencies (such as message invocations, instance creation, reading
or writing variables, and combinations thereof) that can actually be found in the source code.
In order to map a relationship between 2 classi cations containing many source-code artifacts
to dependencies between those artifacts, we also need to specify cardinalities. For example,
uses(allToOne,input,queryInterpreter)
means that all artifacts in the input classi cation should use at least one artifact in the queryInter-
preter classi cation. Other cardinalities are oneToOne, oneToAll, and allToAll. In the examples
that follow, we will often use shortcuts such as
usesAllToOne(input,queryInterpreter)
where the cardinalities are absorbed in the name of the predicate instead of given as extra argument
when calling the predicate.
The uses relationship (and others) is not only de ned between classi cations, but is overloaded
at many levels of abstraction. At the highest abstraction level, it works with classi cation names.
This is translated into a uses relationship between lists of source-code artifacts (corresponding
to the classi cations named). Next, using the speci ed cardinality, this is translated to one or
more uses relationships among the classi ed artifacts. Depending on the kinds of artifacts, the
relationship is further re ned. In the case of uses between two methods, we just check whether
there is a message invocation between the two. When one of the arguments is a class, we de ne
the uses relationship in terms of a uses relationship on the methods of that class. For example, a
class uses a method if at least one of its methods uses that method.
Finally, we want to stress that the high-level connectors between architectural components can
have an arbitrary complexity. uses is an example of a simple connector that maps almost directly
to message invocations at source-code level. The creates relationship is a bit more complex.
Without going into the details, the mapping for this relationship takes into account both lazy
initialization and direct invocation of class creation methods (constructors) [Bec97], and instance
creation through factory methods or class factories [GHJV94]. Another example of a more complex
relationship is usesTrans which corresponds to the transitive closure of the uses relationship. Also
negative relationships (stating for example that two classi cations should not be connected) can
be expressed.
</bodyText>
<subsubsectionHeader confidence="0.97711">
4.2.2 The SOUL Architecture
</subsubsectionHeader>
<bodyText confidence="0.9990988">
As an example of a concrete architecture, we illustrate how the architecture of the SOUL reasoning
engine ( gure 2) can be expressed in terms of the virtual classi cations declared in section 4.1.
As is illustrated by the declarations below, an architectural description consists of a unique name,
a list of components of which the architecture is composed (in this example, the components are
virtual classi cations), and a list of relationships among the architectural components.
</bodyText>
<equation confidence="0.626929888888889">
Fact architecture(soul,
&amp;lt; input, queryInterpreter, workingMemory,
ruleSelection, repository, results &amp;gt;,
&amp;lt; usesAllToOne(input, queryInterpreter),
usesOneToOne(queryInterpreter, workingMemory),
usesTransOneToOne(queryInterpreter, ruleSelection),
usesTransAllToOne(ruleSelection, repository),
createsOneToOne(ruleSelection, workingMemory),
usesOneToOne(ruleSelection, workingMemory),
</equation>
<page confidence="0.989861">
7
</page>
<figureCaption confidence="0.996659">
Figure 3: Query Interpreter Architecture
</figureCaption>
<bodyText confidence="0.5549355">
createsOneToOne(queryInterpreter, results),
not(related(workingMemory, repository)) &amp;gt;).
</bodyText>
<subsubsectionHeader confidence="0.834617">
4.2.3 Conformance Checking
</subsubsectionHeader>
<bodyText confidence="0.969307">
Once an architecture description has been asserted, it can be used to verify whether the source
code conforms to it. Indeed, because an architecture declares relationships among virtual classi -
cations, and virtual classi cations and their relationships can be mapped to source-code artifacts
and dependencies among these artifacts, an architecture indirectly de nes a relationship between
source-code artifacts. To check whether an architecture with some name is valid (i.e., whether the
source code conforms to it), we
</bodyText>
<listItem confidence="0.765755571428571">
1. fetch the description of the architecture with that name,
2. check whether the architecture is well-formed, i.e., that the components have been declared
and that the relationships between the enumerated components are well-formed,
3. check whether the declared relationships between the architectural components hold.
Rule checkArchitecture(?ArchitectureName) if
architecture(?ArchitectureName, ?Components, ?Relationships),
wellFormedArchitecture(?Components, ?Relationships),
</listItem>
<bodyText confidence="0.971994444444444">
checkArchitecturalRelationships(?Relationships).
The auxiliary predicate checkArchitecturalRelationships checks whether the declared relation-
ships hold, by invoking them one by one. For example, in the case of the soul architecture, the
rst relationship
usesAllToOne(input,queryInterpreter)
checks whether every item in the input classi cation uses at least one item in the queryInterpreter
classi cation (see also section 4.2.1).
Our initial conformance checking tool was very primitive, merely returning a `true&amp;apos; or `false&amp;apos;
depending on the success of the conformance check. We are currently extending the tool to pro-
vide more detailed information on the conformance checking process. More precisely, in analogy
to [MNS95], we could compute the convergences (where the source code agrees with the archi-
tecture), the divergences (where the source code shows dependencies that are not predicted by
the architecture) and the absences (where the source code does not contain dependencies that are
described by the architecture). We do this by making our cardinality predicates (8 and 9) more
intelligent. For example, when checking a relationship, the predicate for 9 remembers for which
artifacts the relationship holds and the predicate for 8 remembers which artifacts failed to satisfy
the relationship (if any). However, because the predicates are implemented with lazy evaluation
 |for eciency reasons |, the extra information they provide is restricted by their lazyness.
</bodyText>
<page confidence="0.990526">
8
</page>
<subsectionHeader confidence="0.94296">
4.3 Re ning a Classi cation as a Software Architecture
</subsectionHeader>
<bodyText confidence="0.9998415">
The soul architecture codi ed in section 4.2.2 used only software classi cations as components.
However, software architectures can have subarchitectures as components as well. To illustrate
this, this section re nes the queryInterpreter classi cation presented earlier as an architecture
itself. More precisely, we de ne two subclassi cations and declare relationships between them, as
illustrated in gure 3. This results in a classi cation queryInterpreter that is de ned at a high
level of abstraction, and that can still be checked for source-code conformance.
</bodyText>
<subsubsectionHeader confidence="0.933004">
4.3.1 The Interpretation and Substitution Subclassi cations
</subsubsectionHeader>
<bodyText confidence="0.989460666666667">
The original queryInterpreter classi cation consisted of software artifacts that deal with the inter-
pretation of queries. This interpretation process actually consists of two phases: the interpretation
phase where terms and clauses are interpreted, and a substitution phase, where bindings found
during uni cation are substituted in the term that is currently being interpreted. We will declare
these two phases as subclassi cations: interpretation and substitution. Note that both implemen-
tations use Smalltalk protocols4 to select the relevant methods.
</bodyText>
<construct confidence="0.908856428571429">
Rule methodIsClassi edAs(?Method, interpretation) if
classIsClassi edAs(?Class, soulClass),
or( methodInProtocol(?Class, [#interpretation], ?Method),
methodInProtocol(?Class, [#interpreting], ?Method) ).
Rule methodIsClassi edAs(?Method, substitution) if
classIsClassi edAs(?Class, soulClass),
methodInProtocol(?Class, [#substitution], ?Method).
</construct>
<subsubsectionHeader confidence="0.721028">
4.3.2 The QueryInterpreter Subarchitecture
</subsubsectionHeader>
<bodyText confidence="0.894461">
Based on these subclassi cations we can rede ne the queryInterpreter classi cation as their union.
Rule isClassi edAs(?artifact, queryInterpreter) if
unionClassi cation(interpretation, substitution, ?C),
member(?artifact, ?C).
However, because there are a number of important relationships between these subclassi -
cations, the ruleInterpreter classi cation is more than a mere union. In fact, it is in turn an
architecture composed of these subclassi cations together with their relationships.
Fact architecture(queryInterpreter,
&amp;lt; interpretation, substitution &amp;gt;,
&amp;lt; usesOneToOne(interpretation, substitution),
usesOneToOne(interpretation, interpretation) &amp;gt;).
When adopting a coarse-grained view, queryInterpreter is simply a classi cation that is con-
nected to other classi cations. But in a more ne-grained view, we consider it as an architecture
consisting of several components with their own relationships. In the latter view the connections
between queryInterpreter and other classi cations can be re ned in terms of these components.
This is typically done by introducing ports [SG96]. We simulate ports by de ning a port mapping
that re nes relationships between architectural components in terms of relationships between their
subcomponents. For example, we can re ne the uses relationship from input to queryInterpreter,
into a uses relationship from input to interpretation (which is a subclassi cation of queryInter-
preter). The mapping for this example is implemented by the rst fact below. Figure 4 illustrates
</bodyText>
<footnote confidence="0.5404765">
4Smalltalk environments typically subdivide the methods of a class in protocols such as printing, accessing,
initialize, . . .
</footnote>
<page confidence="0.963666">
9
</page>
<figureCaption confidence="0.99957">
Figure 4: Port Mapping
</figureCaption>
<bodyText confidence="0.906773642857143">
some other mappings, and their SOUL implementation is also presented below. Note that some
relationships may be re ned into more than one relationship, as is the case for the uses relationship
between queryInterpreter and workingMemory.
Fact portMapping(uses, input, queryInterpreter, input, interpretation).
Fact portMapping(creates, queryInterpreter, output, interpretation, output).
Fact portMapping(uses, queryInterpreter, workingMemory,
interpretation, workingMemory).
Fact portMapping(uses, queryInterpreter, workingMemory,
substitution, workingMemory).
Fact portMapping(uses,queryInterpreter,ruleSelection,
interpretation,ruleSelection).
For some relationships between classi cations, a mapping in terms of their subclassi cations
may not be provided. When checking those relationships, the coarse-grained view is adopted, by
considering the classi cations as a mere union of their subclassi cations.
</bodyText>
<subsubsectionHeader confidence="0.910124">
4.3.3 Conformance Checking  |Revisited
</subsubsectionHeader>
<bodyText confidence="0.942458214285714">
Finally, we revisit the conformance checking rules in the current situation where classi cations
can be architectures that are, in turn, built up from many classi cations. To deal with this
situation, the checkArchitecture rule needs to be re ned with an extra clause checkSubArchitec-
tures(?Components) which checks for each of the components whether its architecture is valid. For
components that are ordinary classi cations, nothing special needs to be done, but for components
that are again architectures, the checkArchitecture predicate is called recursively to check confor-
mance to that (sub)architecture. Also, the checkArchitecturalRelationships predicate needs to take
the port mappings into account. For those relationships that are re ned by a port mapping, the
re ned version(s) should be checked.
Rule checkArchitecture(?ArchitectureName) if
architecture(?ArchitectureName, ?Components, ?Relationships),
wellFormedArchitecture(?Components, ?Relationships),
checkSubArchitectures(?Components),
checkArchitecturalRelationships(?Relationships).
</bodyText>
<subsectionHeader confidence="0.999009">
4.4 Architectural Patterns
</subsectionHeader>
<bodyText confidence="0.99835">
This section shows how we can easily de ne architectural patterns in our formalism, demonstrating
again that it can be used at very high levels of abstraction, without losing the ability to do
</bodyText>
<page confidence="0.995149">
10
</page>
<bodyText confidence="0.966081142857143">
conformance checking. As an example we de ne the rule-based system architectural pattern (see
gure 1), of which the soul architecture is a speci c instance.
An architectural pattern describes an architectural structure consisting of architectural com-
ponents and relationships. However, as opposed to a concrete architecture, it provides a template
that can contain `holes&amp;apos; (implemented by logic variables) that need to be lled in upon instantia-
tion. The predicates below implement the rule-based system architectural pattern, and show how
this template can be used to re-implement the soul architecture in term of this pattern.
</bodyText>
<table confidence="0.92978175">
Fact ruleBasedSystemPattern(
?Related1, ?Related2, ?Related3, ?Related4, ?Related5, ?Related6,
description( &amp;lt; ?Input, ?RuleInterpreter, ?WorkingMemory,
?RuleSelection, ?KnowledgeBase, ?Output &amp;gt;,
&amp;lt; ?Related1(?Input, ?RuleInterpreter),
?Related2(?RuleInterpreter, ?WorkingMemory),
?Related3(?RuleInterpreter, ?RuleSelection),
?Related4(?RuleSelection, ?KnowledgeBase),
?Related5(?RuleSelection, ?WorkingMemory),
?Related6(?RuleInterpreter, ?Output),
not(related(?WorkingMemory, ?KnowledgeBase)) &amp;gt;)).
Rule architecture(soul, ?Components, ?Relationships) if
</table>
<bodyText confidence="0.929083842105263">
equals(?Components,
&amp;lt; input, queryInterpreter, workingMemory,
ruleSelection, repository, results &amp;gt;),
ruleBasedSystemPattern(
usesAllToOne, usesOneToOne, usesTransOneToOne,
usesTransAllToOne, createsAndUsesOneToOne, createsOneToOne,
description(?Components, ?Relationships)).
Note that the rule instantiating the soul architecture merely lls in the holes of the pattern by
supplying the concrete components and relationships. Although not visible in this example, upon
instantiation of a pattern, some more speci c constraints that are not provided by the pattern
may be declared as well. Similarly, more complex architectural patterns make use not only of
(uni cation of) logic variables, but also use logic reasoning to declare the structure of the pattern
itself (e.g., the relationships between the components). An example of such a pattern is the pipe
and lter architectural pattern de ned below.
Rule pipeAndFilterPattern(?Connector, description(?Filters, ?Pipes)) if
computePipes(?Connector, ?Filters, ?Pipes).
The computePipes auxiliary predicate states that the set ?Pipes of relationships between ?Fil-
ters should be such that the rst lter is connected to the second one, the second to the third one,
and so on. The variable ?Connector denotes the kind of connection.
</bodyText>
<table confidence="0.7352765">
Rule computePipes( ?Connector, &amp;lt; ?Filter1, ?Filter2 j ?OtherFilters &amp;gt;,
&amp;lt; ?Connector(?Filter1, ?Filter2) j ?OtherPipes &amp;gt;) if
computePipes(?Connector, &amp;lt; ?Filter2 j ?OtherFilters &amp;gt;, ?OtherPipes).
Fact computePipes(?KindOfPipe, &amp;lt;?LastFilter &amp;gt;, &amp;lt;&amp;gt;).
</table>
<sectionHeader confidence="0.973055" genericHeader="evaluation">
5 Discussion and Future Work
</sectionHeader>
<bodyText confidence="0.9936575">
Our initial experiments were very promising. We actually succeeded in declaring the architecture
of part of the SOUL system, and checking conformance of the source code to this architecture. We
</bodyText>
<page confidence="0.99629">
11
</page>
<bodyText confidence="0.99969808">
even de ned subarchitectures and declared the architecture in terms of an architectural pattern,
while still being able to check conformance.
To validate the practical usability (eciency, simplicity, ease of use, readability, ...) of our
formalism, more experiments are needed. One such experiment is to declare an architecture and
check conformance of di erent versions of the source code to it. E.g., what should we do when a
new version no longer conforms to the architecture? A related experiment is to investigate how
re ning an architecture a ects the source code&amp;apos;s conformance to it. Experiments such as these t
in our longer term research goal to develop a formalism for managing the evolution of software
architectures. To achieve this goal, we will extend the current formalism with the technique of
reuse contracts [SLMD96, Luc97]. The reuse contract technique facilitates software reuse and
evolution of software artifacts by explicitly annotating reused or modi ed artifacts, as well as the
modi cations themselves, by so-called \reuse contracts&quot;. Reuse contracts extend existing notations
with extra information on the hidden assumptions of software artifacts and the modi cations made
to them. This information allows us to (semi-automatically) detect potential evolution con
icts,
and gives an indication of where and why these con
icts occur.
During the initial experiments, we noticed that the current implementation of our formalism
is not very performant. Computing some classi cations or checking some relationships (especially
those involving transitive closures) can take a very long time (more than one hour). Therefore, in
the near future we want to incorporate in SOUL extra search techniques and advanced uni cation
schemes to gain more performance.
Another future research track is to further develop and promote SOUL as a general medium for
expressing software development styles ranging from programming conventions and idioms [Mic97],
through design patterns [Wuy98], to software architectures and architectural styles.
</bodyText>
<sectionHeader confidence="0.99787" genericHeader="conclusions">
6 Conclusion
</sectionHeader>
<bodyText confidence="0.999790733333333">
The experiments showed that our consistent use of a declarative programming language through-
out all abstraction layers  |from source-code level through the design and architectural level to
architectural patterns  |provides a viable formalism to reason about architectural knowledge on a
suciently high level of abstraction while still allowing conformance checking of source code. Vir-
tual classi cations proved their worth as suitable abstractions of architectural components. They
hide the details of the lower-level design and source-code artifacts on which they are mapped,
yet allowing us to reason about their relationships with other architectural components indepen-
dently of the artifacts they actually contain. Our layered formalismalso provides a powerful way of
de ning highly abstract relationships between architectural components, by building them up from
lower-level relationships that are again constructed from even lower level ones. As such, simple
low-level relationships can be successfully combined into complex high-level relationships. Finally,
these mappings of architectural components to lower-level components, and of architectural rela-
tionships to lower-level relationships, made it easy to implement the conformance checking rules
by implementing conformance checking at a high level in terms of conformance checking rules at
lower levels, all the way down to the source code.
</bodyText>
<sectionHeader confidence="0.998816" genericHeader="acknowledgments">
7 Acknowledgements
</sectionHeader>
<bodyText confidence="0.89758025">
We wish to thank our advisor Theo D&amp;apos;Hondt for the many fruitful discussions which led to this
paper. Furthermore we thank our colleagues at the Programming Technology Lab for proof-
reading and discussing this paper: Kris De Volder, Carine Lucas, Tom Mens, Tom Tourwe and
Bart Wouters.
</bodyText>
<page confidence="0.962891">
12
</page>
<sectionHeader confidence="0.962865" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999588421052632">
[Bec97] K. Beck.
Smalltalk Best Practice Patterns.
Prentice Hall, 1997.
[GAO95] D. Garlan, R. Allen, and J. Ockerbloom.
Architectural mismatch: Why reuse is so hard.
IEEE Software, November 1995.
[GHJV94] E. Gamma, R. Helm, R. Johnson, and J. Vlissides.
Design Patterns.
Addisson-Wesley, 1994.
[Hon98] K. De Hondt.
A Novel Approach to Architectural Recovery in Evolving
Object-Oriented Systems.
PhD thesis, Dept. of Computer Science, Vrije Universiteit Brussel,
Belgium, 1998.
[HR85] F. Hayes-Roth.
Rule-based systems.
Communications of the ACM, 28(9):921{932, September 1985.
[JGJ97] I. Jacobson, M.L. Griss, and P. Jonsson.
Software Reuse: Architecture, Process and Organization for
Business Success.
Addisson-Wesley, 1997.
[KCH+90] K. C. Kang, S. G. Cohen, J. A. Hess, W. E. Novak, and A. S. Peterson.
Feature-oriented domain analysis (foda) feasibility study.
Technical report, Carnegie-Mellon University Software Engineering
Institute, November 1990.
[Luc97] Carine Lucas.
Documenting Reuse and Evolution with Reuse Contracts.
PhD thesis, Dept. of Computer Science, Vrije Universiteit Brussel,
Belgium, 1997.
[Mic97] I. Michiels.
Using logic meta-programming for building sophisticated development
tools.
Computer science graduation report, Vrije Universiteit Brussel,
Belgium, 1997.
[MN95] G. Murphy and D. Notkin.
Lightweight source model extraction.
In Proceedings of SIGSOFT&amp;apos;95, Third ACM SIGSOFT Symposium on the
Foundations of Software Engineering, pages 116{127. ACM Press, 1995.
</reference>
<page confidence="0.988067">
13
</page>
<reference confidence="0.999092041666667">
[MNS95] G. Murphy, D. Notkin, and K. Sullivan.
Software re
exion models: Bridging the gap between source and
high-level models.
In Proceedings of SIGSOFT&amp;apos;95, Third ACM SIGSOFT Symposium on the
Foundations of Software Engineering, pages 18{28. ACM Press, 1995.
[PDN87] R. Prieto-Diaz and J. M. Neighbors.
Module interconnection languages.
Journal of Systems and Software, 6(4):307{334, November 1987.
[SG96] M. Shaw and D. Garlan.
Software Architecture  |Perspectives on an Emerging
Discipline.
Prentice Hall, 1996.
[SLMD96] P. Steyaert, C. Lucas, K. Mens, and T. D&amp;apos;Hondt.
Reuse contracts: Managing the evolution of reusable assets.
In Proceedings OOPSLA &amp;apos;96, ACM SIGPLAN Notices, pages 268{285.
ACM Press, 1996.
[SSWA96] R. W. Schwanke, V. A. Strack, and T. Werthmann-Auzinger.
Industrial software architecture with gestalt.
In Proceedings of IWSSD-8. IEEE, 1996.
[Wuy98] R. Wuyts.
Declarative reasoning about the structure of object-oriented systems.
In Proceedings TOOLS USA&amp;apos;98, IEEE Computer Society Press, pages
112{124, 1998.
</reference>
<page confidence="0.999235">
14
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.936101">
<title confidence="0.998081">Declaratively Codifying Software Architectures using Virtual Software Classi cations</title>
<author confidence="0.998059">Kim Mens</author>
<author confidence="0.998059">Roel Wuytsy</author>
<affiliation confidence="0.97685">Programming Technology Lab Vrije Universiteit Brussel</affiliation>
<address confidence="0.998502">Pleinlaan 2, 1050 Brussel, Belgium</address>
<email confidence="0.99315">e-mail:fkimmensjrwuytsg@vub.ac.be</email>
<date confidence="0.998582">February 16, 1999</date>
<abstract confidence="0.999497">Most current-day software engineering tools and environments do not suciently allow software engineers to declare or enforce the intended software architecture. On the one hand, architectures are typically described at a too low level, inhibiting their evolution and understanding. On the other hand most tools provide little support to automatically verify whether the source code conforms to the architecture. Therefore, a formalism is needed in which architectures can be expressed at a suciently abstract level, without losing the ability to perform automatic conformance checking. We propose to declaratively codify software architectures using virtual software classi cations and relationships among these classi cations. We illustrate how software architectures can be expressed elegantly in terms of these virtual classi cations and how to keep them synchronized with the source code.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>K Beck</author>
</authors>
<title>Smalltalk Best Practice Patterns.</title>
<date>1997</date>
<publisher>Prentice Hall,</publisher>
<contexts>
<context position="21682" citStr="[Bec97]" startWordPosition="3295" endWordPosition="3295">erms of a uses relationship on the methods of that class. For example, a class uses a method if at least one of its methods uses that method. Finally, we want to stress that the high-level connectors between architectural components can have an arbitrary complexity. uses is an example of a simple connector that maps almost directly to message invocations at source-code level. The creates relationship is a bit more complex. Without going into the details, the mapping for this relationship takes into account both lazy initialization and direct invocation of class creation methods (constructors) [Bec97], and instance creation through factory methods or class factories [GHJV94]. Another example of a more complex relationship is usesTrans which corresponds to the transitive closure of the uses relationship. Also negative relationships (stating for example that two classi cations should not be connected) can be expressed. 4.2.2 The SOUL Architecture As an example of a concrete architecture, we illustrate how the architecture of the SOUL reasoning engine ( gure 2) can be expressed in terms of the virtual classi cations declared in section 4.1. As is illustrated by the declarations below, an arch</context>
</contexts>
<marker>[Bec97]</marker>
<rawString>K. Beck. Smalltalk Best Practice Patterns. Prentice Hall, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Garlan</author>
<author>R Allen</author>
<author>J Ockerbloom</author>
</authors>
<title>Architectural mismatch: Why reuse is so hard.</title>
<date>1995</date>
<journal>IEEE Software,</journal>
<contexts>
<context position="1221" citStr="[GAO95]" startWordPosition="172" endWordPosition="172">lly verify whether the source code conforms to the architecture. Therefore, a formalism is needed in which architectures can be expressed at a suciently abstract level, without losing the ability to perform automatic conformance checking. We propose to declaratively codify software architectures using virtual software classi cations and relationships among these classi cations. We illustrate how software architectures can be expressed elegantly in terms of these virtual classi cations and how to keep them synchronized with the source code. 1 Introduction The problem of architectural mismatch [GAO95] is a well-known problem: by the time an architecture speci cation is published, it is already wrong. It is also an important problem, because although the time to design an architecture may take up to one year, the engineers must then live with the architecture for up to 15 years of development and maintenance [SSWA96]. To solve the problem of architectural mismatch, we not only need to describe the software architecture explicitly at a suciently high level of abstraction, but also provide support for keeping the source code conform to it. Therefore, the contribution of this paper is to pres</context>
</contexts>
<marker>[GAO95]</marker>
<rawString>D. Garlan, R. Allen, and J. Ockerbloom. Architectural mismatch: Why reuse is so hard. IEEE Software, November 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>E Gamma</author>
<author>R Helm</author>
<author>R Johnson</author>
<author>J Vlissides</author>
</authors>
<title>Design Patterns.</title>
<date>1994</date>
<publisher>Addisson-Wesley,</publisher>
<contexts>
<context position="21757" citStr="[GHJV94]" startWordPosition="3305" endWordPosition="3305">lass uses a method if at least one of its methods uses that method. Finally, we want to stress that the high-level connectors between architectural components can have an arbitrary complexity. uses is an example of a simple connector that maps almost directly to message invocations at source-code level. The creates relationship is a bit more complex. Without going into the details, the mapping for this relationship takes into account both lazy initialization and direct invocation of class creation methods (constructors) [Bec97], and instance creation through factory methods or class factories [GHJV94]. Another example of a more complex relationship is usesTrans which corresponds to the transitive closure of the uses relationship. Also negative relationships (stating for example that two classi cations should not be connected) can be expressed. 4.2.2 The SOUL Architecture As an example of a concrete architecture, we illustrate how the architecture of the SOUL reasoning engine ( gure 2) can be expressed in terms of the virtual classi cations declared in section 4.1. As is illustrated by the declarations below, an architectural description consists of a unique name, a list of components of wh</context>
</contexts>
<marker>[GHJV94]</marker>
<rawString>E. Gamma, R. Helm, R. Johnson, and J. Vlissides. Design Patterns. Addisson-Wesley, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K De</author>
</authors>
<title>Hondt. A Novel Approach to Architectural Recovery in Evolving Object-Oriented Systems.</title>
<date>1998</date>
<tech>PhD thesis,</tech>
<institution>Dept. of Computer Science, Vrije Universiteit Brussel,</institution>
<contexts>
<context position="8831" citStr="[Hon98]" startWordPosition="1337" endWordPosition="1337">iori the kinds of source-code artifacts we want to reason about at architectural level, we do use parsers. Furthermore, to allow powerful reasoning about this information, we use the technique of uni cation. Our goal is to allow describing software architectures at the highest abstraction level possible (without losing the ability to verify conformance of source code), at the cost of decreased eciency. 3 Our Approach In developing our formalism,we were inspired by De Hondt&amp;apos;s dissertation about software classi cation as an approach to architectural recovery in evolving object-oriented systems [Hon98]. In this paper, we will investigate the power of virtual software classi cations to codify and reason about software architectures. Another source of inspiration was SOUL, the Smalltalk Open Uni cation Language [Wuy98], which we chose as a medium in which to conduct our experiments. In the next subsections, we clarify both virtual classi cations and SOUL, and explain which experiments we conducted to justify the claims of this paper. 3.1 Virtual Classi cations In his PhD dissertation [Hon98], De Hondt reports on positive experiences with recovering architectural knowledge in terms of simple s</context>
<context position="10367" citStr="[Hon98]" startWordPosition="1578" endWordPosition="1578"> among such classi cations can be used to declare explicitly architectural knowledge. Virtual classi cations are special classi cations that compute their elements. This makes them more abstract than manually constructed classi cations, because they actually describe in an explicit (and in our case, declarative) way which artifacts are intended to belong to the classi cation. For reasons of brevity, in the remainder of this paper we will often write `virtual classi cation&amp;apos; or even `classi cation&amp;apos; instead of `virtual software classi cation&amp;apos;. When we mean `software classication&amp;apos; in the sense of [Hon98], this will be explicitly mentioned. Also note that our terminology of `virtual classi cation&amp;apos; di ers slightly from that of De Hondt [Hon98]: our de nition of virtual classi cation corresponds to his de nition of `computed classi cation&amp;apos;. 2Jacobson [JGJ97] provides some examples of (functional) features and the FODA methodology [KCH+90] considers distinct types of features: operational, non-functional, development, . . . 3 Figure 1: Rule-Based System Architecture 3.2 SOUL SOUL is a re ective, PROLOG-like, declarative rule-based language implemented in Smalltalk [Wuy98]. It allows the declarati</context>
</contexts>
<marker>[Hon98]</marker>
<rawString>K. De Hondt. A Novel Approach to Architectural Recovery in Evolving Object-Oriented Systems. PhD thesis, Dept. of Computer Science, Vrije Universiteit Brussel, Belgium, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>F Hayes-Roth</author>
</authors>
<title>Rule-based systems.</title>
<date>1985</date>
<journal>Communications of the ACM,</journal>
<volume>28</volume>
<issue>9</issue>
<contexts>
<context position="11769" citStr="[SG96, HR85]" startWordPosition="1796" endWordPosition="1797">rrently, SOUL comes with a layered framework of rules that allow reasoning at the implementation and the design level. In this paper, we not only use SOUL as a medium in which to codify architectural knowledge (by adding an architectural layer), but also as a case study to express the architecture of the SOUL reasoning engine. We chose this case, not only because of our rst hand knowledge of the SOUL implementation, but also because the basic architecture of rule-based systems is explicitly documented upon in literature. Our slightly modi ed variant of the rule-based architecture presented in [SG96, HR85] is depicted in gure 1. 3.3 Validation In order to validate the claims made in section 1 we need to show two things: 1. that virtual classi cations and their relationships codify software architectures at a su- ciently abstract level, 2. that we can automatically check conformance of source code to the architectural descriptions. Therefore, we set up the following experiment: we codify the architecture of the SOUL reasoning engine and check the conformance of the actual (Smalltalk) implementation of SOUL to this architecture. The architecture is depicted in gure 2 which is a re nement of gure</context>
</contexts>
<marker>[HR85]</marker>
<rawString>F. Hayes-Roth. Rule-based systems. Communications of the ACM, 28(9):921{932, September 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Jacobson</author>
<author>M L Griss</author>
<author>P Jonsson</author>
</authors>
<title>Software Reuse: Architecture, Process and Organization for Business Success.</title>
<date>1997</date>
<publisher>Addisson-Wesley,</publisher>
<contexts>
<context position="10623" citStr="[JGJ97]" startWordPosition="1619" endWordPosition="1619">ly describe in an explicit (and in our case, declarative) way which artifacts are intended to belong to the classi cation. For reasons of brevity, in the remainder of this paper we will often write `virtual classi cation&amp;apos; or even `classi cation&amp;apos; instead of `virtual software classi cation&amp;apos;. When we mean `software classication&amp;apos; in the sense of [Hon98], this will be explicitly mentioned. Also note that our terminology of `virtual classi cation&amp;apos; di ers slightly from that of De Hondt [Hon98]: our de nition of virtual classi cation corresponds to his de nition of `computed classi cation&amp;apos;. 2Jacobson [JGJ97] provides some examples of (functional) features and the FODA methodology [KCH+90] considers distinct types of features: operational, non-functional, development, . . . 3 Figure 1: Rule-Based System Architecture 3.2 SOUL SOUL is a re ective, PROLOG-like, declarative rule-based language implemented in Smalltalk [Wuy98]. It allows the declaration of structural rules about Smalltalk source code. These rules can be used to query the software system to nd occurrences of certain structures, or to enforce the presence of structures. Currently, SOUL comes with a layered framework of rules that allow r</context>
</contexts>
<marker>[JGJ97]</marker>
<rawString>I. Jacobson, M.L. Griss, and P. Jonsson. Software Reuse: Architecture, Process and Organization for Business Success. Addisson-Wesley, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>K C Kang</author>
<author>S G Cohen</author>
<author>J A Hess</author>
<author>W E Novak</author>
<author>A S Peterson</author>
</authors>
<title>Feature-oriented domain analysis (foda) feasibility study.</title>
<date>1990</date>
<tech>Technical report,</tech>
<institution>Carnegie-Mellon University Software Engineering Institute,</institution>
<marker>[KCH+90]</marker>
<rawString>K. C. Kang, S. G. Cohen, J. A. Hess, W. E. Novak, and A. S. Peterson. Feature-oriented domain analysis (foda) feasibility study. Technical report, Carnegie-Mellon University Software Engineering Institute, November 1990.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carine Lucas</author>
</authors>
<title>Documenting Reuse and Evolution with Reuse Contracts.</title>
<date>1997</date>
<tech>PhD thesis,</tech>
<institution>Dept. of Computer Science, Vrije Universiteit Brussel,</institution>
<contexts>
<context position="34831" citStr="[SLMD96, Luc97]" startWordPosition="5033" endWordPosition="5034">...) of our formalism, more experiments are needed. One such experiment is to declare an architecture and check conformance of di erent versions of the source code to it. E.g., what should we do when a new version no longer conforms to the architecture? A related experiment is to investigate how re ning an architecture a ects the source code&amp;apos;s conformance to it. Experiments such as these t in our longer term research goal to develop a formalism for managing the evolution of software architectures. To achieve this goal, we will extend the current formalism with the technique of reuse contracts [SLMD96, Luc97]. The reuse contract technique facilitates software reuse and evolution of software artifacts by explicitly annotating reused or modi ed artifacts, as well as the modi cations themselves, by so-called \reuse contracts&quot;. Reuse contracts extend existing notations with extra information on the hidden assumptions of software artifacts and the modi cations made to them. This information allows us to (semi-automatically) detect potential evolution con icts, and gives an indication of where and why these con icts occur. During the initial experiments, we noticed that the current implementation of our</context>
</contexts>
<marker>[Luc97]</marker>
<rawString>Carine Lucas. Documenting Reuse and Evolution with Reuse Contracts. PhD thesis, Dept. of Computer Science, Vrije Universiteit Brussel, Belgium, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Michiels</author>
</authors>
<title>Using logic meta-programming for building sophisticated development tools. Computer science graduation report, Vrije Universiteit</title>
<date>1997</date>
<location>Brussel, Belgium,</location>
<contexts>
<context position="35954" citStr="[Mic97]" startWordPosition="5200" endWordPosition="5200">r. During the initial experiments, we noticed that the current implementation of our formalism is not very performant. Computing some classi cations or checking some relationships (especially those involving transitive closures) can take a very long time (more than one hour). Therefore, in the near future we want to incorporate in SOUL extra search techniques and advanced uni cation schemes to gain more performance. Another future research track is to further develop and promote SOUL as a general medium for expressing software development styles ranging from programming conventions and idioms [Mic97], through design patterns [Wuy98], to software architectures and architectural styles. 6 Conclusion The experiments showed that our consistent use of a declarative programming language throughout all abstraction layers |from source-code level through the design and architectural level to architectural patterns |provides a viable formalism to reason about architectural knowledge on a suciently high level of abstraction while still allowing conformance checking of source code. Virtual classi cations proved their worth as suitable abstractions of architectural components. They hide the details o</context>
</contexts>
<marker>[Mic97]</marker>
<rawString>I. Michiels. Using logic meta-programming for building sophisticated development tools. Computer science graduation report, Vrije Universiteit Brussel, Belgium, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Murphy</author>
<author>D Notkin</author>
</authors>
<title>Lightweight source model extraction.</title>
<date>1995</date>
<booktitle>In Proceedings of SIGSOFT&amp;apos;95, Third ACM SIGSOFT Symposium on the Foundations of Software Engineering,</booktitle>
<pages>116--127</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="7991" citStr="[MN95]" startWordPosition="1207" endWordPosition="1207"> levels of abstraction allowing, for example, the declaration of:  architectural components that are mapped to multiple software artifacts spread throughout the source code;  more complex relations dealing with transitive closures, protocols, programming conventions, design styles, ...;  higher-level architectural components that are described in terms of other high-level components and relationships themselves. Another di erence between software re exion models and our approach is the di erence in focus. To obtain more exibility and eciency |at the cost of decreased precision |GailMurphy [MN95] rejects the use of parsers, but uses lexically-based tools that produce approximate results to extract information from source code. We approach the problem from the other end of the spectrum. Because we do not want to restrict a priori the kinds of source-code artifacts we want to reason about at architectural level, we do use parsers. Furthermore, to allow powerful reasoning about this information, we use the technique of uni cation. Our goal is to allow describing software architectures at the highest abstraction level possible (without losing the ability to verify conformance of source co</context>
</contexts>
<marker>[MN95]</marker>
<rawString>G. Murphy and D. Notkin. Lightweight source model extraction. In Proceedings of SIGSOFT&amp;apos;95, Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, pages 116{127. ACM Press, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Murphy</author>
<author>D Notkin</author>
<author>K Sullivan</author>
</authors>
<title>Software re exion models: Bridging the gap between source and high-level models.</title>
<date>1995</date>
<booktitle>In Proceedings of SIGSOFT&amp;apos;95, Third ACM SIGSOFT Symposium on the Foundations of Software Engineering,</booktitle>
<pages>18--28</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="6091" citStr="[MNS95]" startWordPosition="934" endWordPosition="934">lan [SG96] provide a taxonomy of some of the current issues in software architecture research. Using this taxonomy some may want to characterize our work as the search for new Architectural Description Languages (ADLs). Personally, we would situate it in the area of developing formalisms for reasoning about architectural designs. SOUL should therefore be viewed merely as a medium in which we validate our claims about the proposed formalism. We do not intend to promote SOUL as a new or better ADL. In the area of software architecture, much research has been done that is similar to ours. Murphy [MNS95] introduces `software re exion models&amp;apos; that show where an engineer&amp;apos;s high-level model of the software does and does not agree with a source model, based on a declarative mapping between the two models. Module Interconnection Languages (MILs) [PDN87] can be used to formally describe the global structure of a software system, by specifying the interfaces and interconnections among the components (`modules&amp;apos;) that make up the system. These formal descriptions can be processed automatically to verify system integrity. A MIL describes the interconnections between modules in terms of the entities the</context>
<context position="24782" citStr="[MNS95]" startWordPosition="3689" endWordPosition="3689">er the declared relationships hold, by invoking them one by one. For example, in the case of the soul architecture, the rst relationship usesAllToOne(input,queryInterpreter) checks whether every item in the input classi cation uses at least one item in the queryInterpreter classi cation (see also section 4.2.1). Our initial conformance checking tool was very primitive, merely returning a `true&amp;apos; or `false&amp;apos; depending on the success of the conformance check. We are currently extending the tool to provide more detailed information on the conformance checking process. More precisely, in analogy to [MNS95], we could compute the convergences (where the source code agrees with the architecture), the divergences (where the source code shows dependencies that are not predicted by the architecture) and the absences (where the source code does not contain dependencies that are described by the architecture). We do this by making our cardinality predicates (8 and 9) more intelligent. For example, when checking a relationship, the predicate for 9 remembers for which artifacts the relationship holds and the predicate for 8 remembers which artifacts failed to satisfy the relationship (if any). However, b</context>
</contexts>
<marker>[MNS95]</marker>
<rawString>G. Murphy, D. Notkin, and K. Sullivan. Software re exion models: Bridging the gap between source and high-level models. In Proceedings of SIGSOFT&amp;apos;95, Third ACM SIGSOFT Symposium on the Foundations of Software Engineering, pages 18{28. ACM Press, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Prieto-Diaz</author>
<author>J M Neighbors</author>
</authors>
<title>Module interconnection languages.</title>
<date>1987</date>
<journal>Journal of Systems and Software,</journal>
<volume>6</volume>
<issue>4</issue>
<contexts>
<context position="6340" citStr="[PDN87]" startWordPosition="972" endWordPosition="972">it in the area of developing formalisms for reasoning about architectural designs. SOUL should therefore be viewed merely as a medium in which we validate our claims about the proposed formalism. We do not intend to promote SOUL as a new or better ADL. In the area of software architecture, much research has been done that is similar to ours. Murphy [MNS95] introduces `software re exion models&amp;apos; that show where an engineer&amp;apos;s high-level model of the software does and does not agree with a source model, based on a declarative mapping between the two models. Module Interconnection Languages (MILs) [PDN87] can be used to formally describe the global structure of a software system, by specifying the interfaces and interconnections among the components (`modules&amp;apos;) that make up the system. These formal descriptions can be processed automatically to verify system integrity. A MIL describes the interconnections between modules in terms of the entities they contain (e.g. variables, constants, procedures, type de nitions, ...). Typical syntax primitives are: provide, require, has-access-to and consists-of. Shaw and Garlan [SG96] argue that MILs force software architects to use a lower level of abstrac</context>
</contexts>
<marker>[PDN87]</marker>
<rawString>R. Prieto-Diaz and J. M. Neighbors. Module interconnection languages. Journal of Systems and Software, 6(4):307{334, November 1987.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Shaw</author>
<author>D Garlan</author>
</authors>
<title>Software Architecture |Perspectives on an Emerging Discipline.</title>
<date>1996</date>
<publisher>Prentice Hall,</publisher>
<contexts>
<context position="2822" citStr="[SG96]" startWordPosition="425" endWordPosition="425"> components, connectors, architectural styles, . . . ; at design level, we reason in terms of classes, methods, inheritance, aggregations, . . . and at implementation level we are interested in individual statements, message expressions, and so on.  We prefer a declarative formalism because this makes the architectural descriptions easier to understand and maintain. Research funded by the Brussels Capital Region (Belgium) yResearch conducted on a doctoral grant from the Instituut voorWetenschap en Technologie (Flanders, Belgium) 1We use the term `codifying&amp;apos; in a slightly stronger sense than [SG96]. In our terminology, `codifying&amp;apos; means: \to make explicit so that it can be automatically manipulated in tools&quot;. 1  Because we do not want to be limited in expressiveness, we want to use a fulledged programming language. More speci cally, because we want a declarative formalism, we prefer a logic programming language in which we can exploit the full power of uni cation.  To allow conformance checking of the source code to the architecture, we need an explicit link between source-code artifacts and high-level architectural abstractions. We want to be able to map architectural components and </context>
<context position="5388" citStr="[SG96]" startWordPosition="818" endWordPosition="818"> the next section. Section 4 illustrates and validates our approach by means of some experiments. Before concluding (section 6), section 5 discusses the achieved results and future work. 2 Related Work on Software Architectures The architecture of a software system de nes that system in terms of high-level components and interactions among those components. In addition to specifying the structure and topology of the system, the architecture shows the correspondence between the system requirements and elements of the constructed system, thereby providing some rationale for the design decisions [SG96]. In this paper, we focus on the structural aspects of software architectures only. Shaw and Garlan [SG96] provide a taxonomy of some of the current issues in software architecture research. Using this taxonomy some may want to characterize our work as the search for new Architectural Description Languages (ADLs). Personally, we would situate it in the area of developing formalisms for reasoning about architectural designs. SOUL should therefore be viewed merely as a medium in which we validate our claims about the proposed formalism. We do not intend to promote SOUL as a new or better ADL. In</context>
<context position="6866" citStr="[SG96]" startWordPosition="1046" endWordPosition="1046"> mapping between the two models. Module Interconnection Languages (MILs) [PDN87] can be used to formally describe the global structure of a software system, by specifying the interfaces and interconnections among the components (`modules&amp;apos;) that make up the system. These formal descriptions can be processed automatically to verify system integrity. A MIL describes the interconnections between modules in terms of the entities they contain (e.g. variables, constants, procedures, type de nitions, ...). Typical syntax primitives are: provide, require, has-access-to and consists-of. Shaw and Garlan [SG96] argue that MILs force software architects to use a lower level of abstraction than is appropriate, because they focus too much on `implementation&amp;apos; rather than `interaction&amp;apos; relationships between modules. In our opinion, software re exion models su er from 2 the same problem: high-level relationships between architectural components are typicallymapped to calling relations, le-dependencies, cross-reference lists and so on. Our formalism tries to extend approaches such as software re exion models or MILs, to higher levels of abstraction allowing, for example, the declaration of:  architectural</context>
<context position="11769" citStr="[SG96, HR85]" startWordPosition="1796" endWordPosition="1797">rrently, SOUL comes with a layered framework of rules that allow reasoning at the implementation and the design level. In this paper, we not only use SOUL as a medium in which to codify architectural knowledge (by adding an architectural layer), but also as a case study to express the architecture of the SOUL reasoning engine. We chose this case, not only because of our rst hand knowledge of the SOUL implementation, but also because the basic architecture of rule-based systems is explicitly documented upon in literature. Our slightly modi ed variant of the rule-based architecture presented in [SG96, HR85] is depicted in gure 1. 3.3 Validation In order to validate the claims made in section 1 we need to show two things: 1. that virtual classi cations and their relationships codify software architectures at a su- ciently abstract level, 2. that we can automatically check conformance of source code to the architectural descriptions. Therefore, we set up the following experiment: we codify the architecture of the SOUL reasoning engine and check the conformance of the actual (Smalltalk) implementation of SOUL to this architecture. The architecture is depicted in gure 2 which is a re nement of gure</context>
<context position="28251" citStr="[SG96]" startWordPosition="4165" endWordPosition="4165">tionships. Fact architecture(queryInterpreter, &amp;lt; interpretation, substitution &amp;gt;, &amp;lt; usesOneToOne(interpretation, substitution), usesOneToOne(interpretation, interpretation) &amp;gt;). When adopting a coarse-grained view, queryInterpreter is simply a classi cation that is connected to other classi cations. But in a more ne-grained view, we consider it as an architecture consisting of several components with their own relationships. In the latter view the connections between queryInterpreter and other classi cations can be re ned in terms of these components. This is typically done by introducing ports [SG96]. We simulate ports by de ning a port mapping that re nes relationships between architectural components in terms of relationships between their subcomponents. For example, we can re ne the uses relationship from input to queryInterpreter, into a uses relationship from input to interpretation (which is a subclassi cation of queryInterpreter). The mapping for this example is implemented by the rst fact below. Figure 4 illustrates 4Smalltalk environments typically subdivide the methods of a class in protocols such as printing, accessing, initialize, . . . 9 Figure 4: Port Mapping some other mapp</context>
</contexts>
<marker>[SG96]</marker>
<rawString>M. Shaw and D. Garlan. Software Architecture  |Perspectives on an Emerging Discipline. Prentice Hall, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>P Steyaert</author>
<author>C Lucas</author>
<author>K Mens</author>
<author>T D&amp;apos;Hondt</author>
</authors>
<title>Reuse contracts: Managing the evolution of reusable assets.</title>
<date>1996</date>
<journal>ACM SIGPLAN Notices,</journal>
<booktitle>In Proceedings OOPSLA &amp;apos;96,</booktitle>
<pages>268--285</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="34831" citStr="[SLMD96, Luc97]" startWordPosition="5033" endWordPosition="5034">...) of our formalism, more experiments are needed. One such experiment is to declare an architecture and check conformance of di erent versions of the source code to it. E.g., what should we do when a new version no longer conforms to the architecture? A related experiment is to investigate how re ning an architecture a ects the source code&amp;apos;s conformance to it. Experiments such as these t in our longer term research goal to develop a formalism for managing the evolution of software architectures. To achieve this goal, we will extend the current formalism with the technique of reuse contracts [SLMD96, Luc97]. The reuse contract technique facilitates software reuse and evolution of software artifacts by explicitly annotating reused or modi ed artifacts, as well as the modi cations themselves, by so-called \reuse contracts&quot;. Reuse contracts extend existing notations with extra information on the hidden assumptions of software artifacts and the modi cations made to them. This information allows us to (semi-automatically) detect potential evolution con icts, and gives an indication of where and why these con icts occur. During the initial experiments, we noticed that the current implementation of our</context>
</contexts>
<marker>[SLMD96]</marker>
<rawString>P. Steyaert, C. Lucas, K. Mens, and T. D&amp;apos;Hondt. Reuse contracts: Managing the evolution of reusable assets. In Proceedings OOPSLA &amp;apos;96, ACM SIGPLAN Notices, pages 268{285. ACM Press, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R W Schwanke</author>
<author>V A Strack</author>
<author>T Werthmann-Auzinger</author>
</authors>
<title>Industrial software architecture with gestalt.</title>
<date>1996</date>
<booktitle>In Proceedings of IWSSD-8.</booktitle>
<publisher>IEEE,</publisher>
<contexts>
<context position="1542" citStr="[SSWA96]" startWordPosition="228" endWordPosition="228"> classi cations and relationships among these classi cations. We illustrate how software architectures can be expressed elegantly in terms of these virtual classi cations and how to keep them synchronized with the source code. 1 Introduction The problem of architectural mismatch [GAO95] is a well-known problem: by the time an architecture speci cation is published, it is already wrong. It is also an important problem, because although the time to design an architecture may take up to one year, the engineers must then live with the architecture for up to 15 years of development and maintenance [SSWA96]. To solve the problem of architectural mismatch, we not only need to describe the software architecture explicitly at a suciently high level of abstraction, but also provide support for keeping the source code conform to it. Therefore, the contribution of this paper is to present a formalism in which architectural knowledge can be codi ed1 with the ability to automatically check conformance of source code. Preferably, such a formalism should possess the following characteristics:  It should allow reasoning at suciently high levels of abstraction, i.e., in terms of the components that are t</context>
</contexts>
<marker>[SSWA96]</marker>
<rawString>R. W. Schwanke, V. A. Strack, and T. Werthmann-Auzinger. Industrial software architecture with gestalt. In Proceedings of IWSSD-8. IEEE, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Wuyts</author>
</authors>
<title>Declarative reasoning about the structure of object-oriented systems.</title>
<date>1998</date>
<booktitle>In Proceedings TOOLS USA&amp;apos;98, IEEE</booktitle>
<pages>112--124</pages>
<publisher>Computer Society Press,</publisher>
<contexts>
<context position="4373" citStr="[Wuy98]" startWordPosition="667" endWordPosition="667">appings between architectural components and source-level artifacts. The formalismwe propose in this paper adheres to the above characteristics. More speci cally, we will introduce virtual classi cations to map source-level artifacts to higher-level architectural components (and vice versa). We will declare explicit relationships between these virtual classi - cations that describe the co-operations among them. The underlying medium that will allow us to de ne virtual classi cations and their relationships, and that links them to the source code is SOUL, the Smalltalk Open Uni cation Language [Wuy98]. This combination allows us to codify explicitly and declaratively software architectures at a high level of abstraction. We will present an example of declaring an architecture in this formalism, and illustrate how to automatically check conformance of the source code to this architecture. Before explaining our approach in section 3, we highlight the essential di erences with some closely related work in the next section. Section 4 illustrates and validates our approach by means of some experiments. Before concluding (section 6), section 5 discusses the achieved results and future work. 2 Re</context>
<context position="9050" citStr="[Wuy98]" startWordPosition="1370" endWordPosition="1370"> to allow describing software architectures at the highest abstraction level possible (without losing the ability to verify conformance of source code), at the cost of decreased eciency. 3 Our Approach In developing our formalism,we were inspired by De Hondt&amp;apos;s dissertation about software classi cation as an approach to architectural recovery in evolving object-oriented systems [Hon98]. In this paper, we will investigate the power of virtual software classi cations to codify and reason about software architectures. Another source of inspiration was SOUL, the Smalltalk Open Uni cation Language [Wuy98], which we chose as a medium in which to conduct our experiments. In the next subsections, we clarify both virtual classi cations and SOUL, and explain which experiments we conducted to justify the claims of this paper. 3.1 Virtual Classi cations In his PhD dissertation [Hon98], De Hondt reports on positive experiences with recovering architectural knowledge in terms of simple software classi cations. The idea of a software classi cation is to group together software artifacts that should be considered as a whole. All artifacts in such a classi cation typically share some important feature2. I</context>
<context position="10942" citStr="[Wuy98]" startWordPosition="1662" endWordPosition="1662">ication&amp;apos; in the sense of [Hon98], this will be explicitly mentioned. Also note that our terminology of `virtual classi cation&amp;apos; di ers slightly from that of De Hondt [Hon98]: our de nition of virtual classi cation corresponds to his de nition of `computed classi cation&amp;apos;. 2Jacobson [JGJ97] provides some examples of (functional) features and the FODA methodology [KCH+90] considers distinct types of features: operational, non-functional, development, . . . 3 Figure 1: Rule-Based System Architecture 3.2 SOUL SOUL is a re ective, PROLOG-like, declarative rule-based language implemented in Smalltalk [Wuy98]. It allows the declaration of structural rules about Smalltalk source code. These rules can be used to query the software system to nd occurrences of certain structures, or to enforce the presence of structures. Currently, SOUL comes with a layered framework of rules that allow reasoning at the implementation and the design level. In this paper, we not only use SOUL as a medium in which to codify architectural knowledge (by adding an architectural layer), but also as a case study to express the architecture of the SOUL reasoning engine. We chose this case, not only because of our rst hand kno</context>
<context position="35987" citStr="[Wuy98]" startWordPosition="5204" endWordPosition="5204">, we noticed that the current implementation of our formalism is not very performant. Computing some classi cations or checking some relationships (especially those involving transitive closures) can take a very long time (more than one hour). Therefore, in the near future we want to incorporate in SOUL extra search techniques and advanced uni cation schemes to gain more performance. Another future research track is to further develop and promote SOUL as a general medium for expressing software development styles ranging from programming conventions and idioms [Mic97], through design patterns [Wuy98], to software architectures and architectural styles. 6 Conclusion The experiments showed that our consistent use of a declarative programming language throughout all abstraction layers |from source-code level through the design and architectural level to architectural patterns |provides a viable formalism to reason about architectural knowledge on a suciently high level of abstraction while still allowing conformance checking of source code. Virtual classi cations proved their worth as suitable abstractions of architectural components. They hide the details of the lower-level design and sour</context>
</contexts>
<marker>[Wuy98]</marker>
<rawString>R. Wuyts. Declarative reasoning about the structure of object-oriented systems. In Proceedings TOOLS USA&amp;apos;98, IEEE Computer Society Press, pages 112{124, 1998.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>