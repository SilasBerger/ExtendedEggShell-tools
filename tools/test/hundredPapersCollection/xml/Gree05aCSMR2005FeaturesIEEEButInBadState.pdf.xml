<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<table confidence="0.438131666666667">
Correlating Features and Code
Using A Compact Two-Sided Trace Analysis Approach
accepted to CSMR 2005
Orla Greevy and Stéphane Ducasse
Software Composition Group
Institut für Informatik und angewandte Mathematik
</table>
<affiliation confidence="0.989975">
University of Bern, Switzerland
</affiliation>
<email confidence="0.971116">
{greevy, ducasse}@iam.unibe.ch
</email>
<sectionHeader confidence="0.990659" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999781466666667">
Software developers are constantly required to modify
and adapt application features in response to changing re-
quirements. The problem is that just by reading the source
code, it is difficult to determine how classes and methods
contribute to the runtime behavior of features. Moreover,
dependencies between system features are not obvious, con-
sequently software maintenance operations often result in
unintended side effects. To tackle these problems, we pro-
pose a compact feature-driven approach (i.e., summarized
trace information) based on dynamic analysis to character-
ize features and computational units of an application. We
extract execution traces to achieve an explicit mapping be-
tween features and classes using two complementary per-
spectives. We apply our approach to two case studies and
we report our findings.
</bodyText>
<sectionHeader confidence="0.846669" genericHeader="keywords">
Keywords: Feature, Feature-Traces, Dynamic Analysis,
</sectionHeader>
<keyword confidence="0.482326">
Software Evolution, Software Metrics.
</keyword>
<sectionHeader confidence="0.991345" genericHeader="introduction">
1. Introduction
</sectionHeader>
<bodyText confidence="0.994764277777778">
Developers who maintain and extend complex software
systems are expected to translate change requests and bug
reports into modifications in the code. This task is difficult
because such requests are usually expressed in a language
that reflects a feature perspective of the system [14]. As a re-
sult, developers spend lot of time locating relevant parts of
the code before making the required modifications. If they
are uncertain about how the features of a system interact,
they risk adversely impacting other features as a result of
their changes.
To address these problems we propose a two-sided ap-
proach to feature analysis. Essentially we aim to answer the
following questions:
• How do features relate to classes? Understanding how
a feature is implemented is essential for the software
maintenance phase of a system. Moreover, developers
tend to use their knowledge of how existing features
are implemented as a basis for adding new features.
</bodyText>
<listItem confidence="0.9758375">
• How do classes relate to features? Knowledge of the
role of a class in the behavior of a system is useful,
when a developer needs to modify or adapt it.
• How are features related to each other? Know-
</listItem>
<bodyText confidence="0.995435">
ing which features could be affected by modifica-
tions helps the developer estimate which parts of the
system could be affected and need regression test-
ing.
Several works [4, 25] have shown that dynamic analy-
sis is a reliable means of associating behaviors of a system
with the internal components of its implementation. How-
ever, dynamic analysis-based approaches tend to be com-
plex. The main reason is it is diffcult to design tools that
process the huge volume of trace data and present the infor-
mation in an understandable form [20, 26, 3].
Considering the characteristics of previous works, the
key contributions of our approach are: (1) an easy-to-use
approach, (2) compactness of the trace information and (3)
two-sided views.
Our approach is easy-to-use as we define a simple map-
ping between system behaviors and features. We automate
the capture of individual traces of features that can be repro-
duced every time we need to experiment with them. More-
over, we compute some simple sets from the traces, which
we use to characterize features and computational units of
an application.
We tackle the problem of handling huge amount of in-
formation by compacting the traces to focus on key infor-
mation. We refer to the compacted versions of the traces as
feature-fingerprints.
Our two-sided approach characterizes both features and
computational units. Firstly, we extract a feature perspec-
tive of a system by characterizing features in isolation and
in combination with other features. Secondly, we extract a
computational unit perspective which we use to characterize
computational units based on how they participate in fea-
tures.
The aim of our work is to define a technique that is easily
integrated in the software life-cycle as means of supporting
software developers when they have to modify or add fea-
tures to an application.
Structure of the Paper. This paper is structured as follows:
in Section 2 we introduce the terminology of our approach.
In Sections 3 and 4 we introduce our two-sided approach
and the high-level views we extract. In Section 5 we re-
port on two case studies we conducted using our approach
and present the results. Subsequently, in Section 6 we dis-
cuss our findings and outline the constraints and limitations
of our approach. We summarize related work in Section 7.
Finally, we outline our conclusions and future work in Sec-
tion 8.
</bodyText>
<sectionHeader confidence="0.993766" genericHeader="method">
2. Terminology
</sectionHeader>
<bodyText confidence="0.997147395348837">
In this paper we adopt the definitions of features and
computational units proposed by Eisenbarth et al.[4] and re-
fine them for the purpose of our approach.
Feature. “A feature is a realized functional requirement of
a system. A feature is an observable unit of behavior of a
system triggered by the user” [4].
Not all features of an application satisfy this definition.
System internal housekeeping tasks, for example, are not
triggered directly as a result of user interaction. We limit
the scope of our investigation to user-initiated features. We
focus on the user-interface of an application to determine
which user-observable features are most adequate to include
in our analysis.
Computational units. “A computational unit is an exe-
cutable part of a system” [4]. In our approach, we focus
on characterizing features of object-oriented applications.
We consider classes as computational units. However, our
approach is also applicable to finer-grained computational
units such as methods, or coarser-grained computational
units such as packages.
Feature-Traces. We introduce the term feature-trace to re-
fer to an individual execution trace captured as a result of
triggering a feature. A feature-trace consists of performed
method calls.
Feature-Fingerprints. A feature-fingerprint is a set of
classes and/or methods which conform to a certain rule
(described in Section 3.2). Due to iteration and recur-
sion, feature-traces contain multiple references to the same
classes and methods. Feature-fingerprints reduce the vol-
ume of information but at the same time preserve the
necessary information to establish the relationships be-
tween features and computational units.
The Feature Model. In Figure 1 we show the relationship
between feature-traces and class and method entities, we
obtain by extracting a model of the source code.
We assume a one-to-one mapping between feature-traces
and features. This is a simplification of reality, as the exe-
cution path of a feature varies depending on the combina-
tion of user inputs when it is triggered. Exhaustive execu-
tion of a feature is costly. We see that one path of execution
is useful enough to reveal a mapping which directs the soft-
ware developer to the relevant computational units (as dis-
cussed in Section 6).
</bodyText>
<figure confidence="0.984330333333333">
*
*
Feature
invokes
user
Feature Model
Feature
1 1
External Perspective
Class
Method
Feature-Trace
</figure>
<figureCaption confidence="0.999874">
Figure 1. The Relationship between Features
</figureCaption>
<bodyText confidence="0.826688">
and Feature-Model (in UML notation). ‘Class’
and ‘Method’ are model entities extracted by
static analysis of the source code.
</bodyText>
<sectionHeader confidence="0.498964" genericHeader="method">
3. Two-Sided Metric-Based Feature-Oriented
Approach
</sectionHeader>
<bodyText confidence="0.986650125">
The basis of our approach is to obtain a feature model,
that combines dynamic information with a static model of
the application under analysis as shown in Figure 1. Our
feature model represents the relationship between the exter-
nal viewpoint of a system in terms of features and the inter-
nal viewpoint in terms of computational units.
The focus of our approach is to apply a two-sided anal-
ysis of the feature model by extracting two distinct but re-
</bodyText>
<listItem confidence="0.91913325">
lated perspectives:
• A Feature Perspective, to identify the characteristics of
feature-trace entities.
• A Computational Unit Perspective, to identify charac-
</listItem>
<bodyText confidence="0.930234">
teristics of class and method entities with respect to the
features.
Figure 2 describes the overall process of our approach:
first the system is instrumented, individual behaviors are
triggered and for each behavior, a feature-trace is collected.
The feature-fingerprints (described in Section 3.1) are com-
puted for each feature-trace. Based on this information, dif-
ferent perspectives are developed supported by graphical
views.
</bodyText>
<figure confidence="0.9971063125">
A
B
Login
Edit
899 34 5
950 45 3
887... ...
feature-
fingerprints
Computational Unit Perspective
Feature Perspective
A
B
Login
Edit
Traces
</figure>
<figureCaption confidence="0.892324333333333">
Figure 2. Our Two-Sided approach. We pro-
pose two views based on summarized traces.
3.1. Obtaining Reproducible Feature-Traces.
</figureCaption>
<bodyText confidence="0.998206736842105">
Our first step is to identify the features to include in our
analysis. We do not require complete coverage of the sys-
tem’s functionality to obtain a feature model (as discussed
in Section 6). Our approach allows the developer to focus
on a subset of features of interest.
We build an analysis tool TraceScraper which uses
method wrappers [2] to instrument the application code.
The unit of observable behavior that we identify as be-
ing a feature should be defined as small as possible [6].
This limits the volume of data generated by the feature cap-
ture. Our tool simulates the user by scripting user actions
and invokes each script separately. In this way it interacts
with the application to trigger the feature behavior. The be-
havior is traced in a controlled environment. This means
that no other system activity occurs at the time of cap-
ture. For each feature-trace captured, we start our case
study application before triggering the individual fea-
ture. By doing so we ensure that our technique always
yields the same feature-trace.
</bodyText>
<subsectionHeader confidence="0.527047">
3.2. The Features Perspective
</subsectionHeader>
<bodyText confidence="0.981443777777778">
With the feature-perspective we focus on the character-
ization of the features of our feature model. We consider
both the standalone feature, and the feature in relation to
other features of the model. We obtain a characterization
of features by applying feature-specific measurements to
features-traces and their respective feature-fingerprints.
Feature-fingerprints. We extract 6 distinct feature-
fingerprints from each feature-trace based on the following
rules:
</bodyText>
<listItem confidence="0.995828727272727">
• Cf is the set of all classes which participate in a
feature-trace.
• Mf is the set of all methods which participate in a
feature-trace.
• CSf is the set of all classes which are specific to a
feature-trace.
• CCf is the set of all classes which are common to
more than one feature-trace.
• MSf is the set of all methods which are specific to a
feature-trace.
• MCf is the set of all methods which are common to
</listItem>
<bodyText confidence="0.992877333333333">
more than one feature-trace.
We group our measurements according to whether we
are considering a standalone feature, or a feature in rela-
tion to other features.
Standalone feature measurements. These measure-
ments enable us to characterize the features of an ap-
plication in terms of their complexity. The complexity
features is determined by the measurements shown in Ta-
ble 1.
</bodyText>
<subsectionHeader confidence="0.876876">
Metric Description
</subsectionHeader>
<bodyText confidence="0.883860363636364">
NOMf # method calls in a feature-trace
NMRf # methods referenced in a feature-traces
NCRf # classes referenced in feature-trace
Table 1. Standalone Feature Measurements
Feature relationship measurements. We apply these mea-
surements to obtain a characterization of a feature in rela-
tion to other features of our model. We measure the number
of classes that are specific to a feature-trace (the cardinal-
ity of CSf ), and the number of classes that are referenced
in other feature-traces (the cardinality of CCf ). These mea-
surements are listed in Table 2.
</bodyText>
<figure confidence="0.370613">
Metric Description
NOCSf # classes specific in feature-trace
NOCCf # classes common in other feature-traces
PCCf % classes common to other feature-traces
PCSf % classes specific to one feature-trace
</figure>
<tableCaption confidence="0.549497">
Table 2. Feature Relationship Measurements
</tableCaption>
<bodyText confidence="0.688373333333333">
Based on the feature relationship measurements, we de-
fine a vocabulary to characterize feature-traces in terms of
their participating classes:
</bodyText>
<listItem confidence="0.974934">
• Disjoint. A disjoint feature-trace does not share classes
with other feature-traces. (NOCCf = 0)
• Completely related. A completely related feature-trace
shares all of its classes with other feature-traces.
(NOCSf = 0)
• Tightly related. A tightly related feature-trace shares &amp;gt;
50 % of its classes with other feature-traces. (NOCCf
&amp;gt; (NCRf / 2) )
• Loosely related. A loosely related feature-trace
</listItem>
<bodyText confidence="0.510177">
shares ≤ 50% of its classes with other feature traces.
(NOCCf ≤ (NCRf / 2))
</bodyText>
<subsectionHeader confidence="0.955706">
3.3. The Computational Unit Perspective
</subsectionHeader>
<bodyText confidence="0.985137666666667">
We focus on characterizing the classes of an application
based on their participation in the features of our model.
Computational Unit Measurements. We define two types of
measurements: (1) we calculate the frequency with which a
computational unit is referenced in a feature trace and (2)
the number of feature-traces referencing the computational
units.
The class related measurements are summarized in Ta-
ble 3.
</bodyText>
<subsectionHeader confidence="0.547924">
Metric Description
</subsectionHeader>
<construct confidence="0.44522475">
NOFRC # feature-traces referencing a class
NORCf # references to a class in a features-trace
Table 3. Computational unit measurements
relating to feature-traces
</construct>
<bodyText confidence="0.924377666666667">
The measurement # references to a class in a features-
trace (NORCf ) counts all (including duplicate) references
to classes in features. This measurement indicates how fre-
quently a class is participating in a feature.
Computational Unit Characterization. We use the mea-
surement # feature-traces referencing a class (NOFRC)
for class characterization. As with feature characterization,
we also define a vocabulary to characterize classes with re-
spect to the feature model.
</bodyText>
<listItem confidence="0.967521181818182">
• Infrastructural classes participate in at least 50% of the
features. These classes are providing common func-
tionality, that is not specific to an individual feature
(NOFRC &amp;gt; (NCRf / 2)).
• Single-feature classes participate in only one feature-
trace of the feature model (NOFRC = 1).
• Group-feature classes participate in a group feature-
traces of the feature model. If group-feature classes
are detected, this leads us to identify groups of related
feature-traces ( 1 &amp;lt; NOFRC ≤ (NCRf / 2) ).
• Non-participating classes do not participate in any
</listItem>
<bodyText confidence="0.95531325">
feature-traces of the model ( NOFRC = 0 ).
We use this characterization of classes to partition an ap-
plication into single-feature, group-feature and infrastruc-
tural classes.
</bodyText>
<sectionHeader confidence="0.489815" genericHeader="method">
4. Feature and Computational Unit Perspec-
</sectionHeader>
<bodyText confidence="0.9200255">
tive High-Level Views
We use a simple graph visualization to illustrate and con-
vey the results of our two-sided approach to feature analy-
sis. These visualizations represent both the feature perspec-
tive characterizations and the computational unit perspec-
tive. We generate all views using our TraceScraper tool.
</bodyText>
<subsectionHeader confidence="0.727865">
4.1. Feature Perspective Views
</subsectionHeader>
<bodyText confidence="0.990555875">
We define two types of feature perspective views: The
Feature Characterization View and The Feature Class Cor-
relation Views.
Feature Characterization View. The purpose of this view is
to represent a characterization of features in terms of the
distribution of functionality in the participating computa-
tional units. We describe a Feature Characterization View
based on the participating classes. We present a stacked
bar chart, where each bar represents a distinct feature.
We use color to represent the percentage of classes of the
trace which are shared by other traces and those which are
specific to one feature-trace. We calculate percentages for
each feature using the measurements % classes common to
other feature-traces (PCCf ) and % classes specific to one
feature-trace (PCSf ). We represent each metric using a
color on a bar chart as shown in Figure 3.
</bodyText>
<figure confidence="0.997076411764706">
%
Classes
f1
(Disjoint)
f2
(Completely
Related)
f3
(Tightly
Related)
f4
(Loosely
Related)
% Infrastructural functionality% Specific functionality
Features
0
100
</figure>
<figureCaption confidence="0.999833">
Figure 3. Feature Characterization View cal-
</figureCaption>
<bodyText confidence="0.975903875">
culated using the metrics PCCf and PCSf .
If a feature is disjoint, it is displayed in red 1. This means
that with respect to the other features of the model, all
its participating computational units are only referenced by
this feature. If a feature is displayed in green it means that
it is completely related. In other words all its computational
units are referenced by other features of the model. (Fig-
ure 6 shows the results of applying this view to our Small-
Wiki case study.)
Feature Class Correlation Views. Correlation views reveal
detailed information about which classes participate in a
feature-trace. For applications with lots of classes, a grid
view is difficult interpret due to its size. We address this
problem by providing subviews which base the correlation
between features and classes on subsets of the classes. We
describe the following views:
</bodyText>
<listItem confidence="0.725332625">
• Shared-Class-to-Feature-Correlation-View. This view
uses a grid to illustrate which classes of the feature-
fingerprint CCf participate in which features. Figure 5
shows the correlation of shared classes to features that
we generated for our SmallWiki case study.
• Exclusive-Class-to-Feature-Correlation-View. Simi-
larly this view displays a grid of the classes of the
feature-fingerprint CSf (the set of specific classes)
</listItem>
<bodyText confidence="0.838601666666667">
participate in the features of our model. As this is sim-
ilar in appearance to Figure 5, we do not include it in
this paper.
</bodyText>
<footnote confidence="0.902467">
1 On printed versions green will be displayed lighter than red
4.2. The Computational Unit Perspective View
</footnote>
<subsectionHeader confidence="0.390492">
The Class Characterization View represents graphically
</subsectionHeader>
<bodyText confidence="0.9463024">
the types of classes of a system based on the characteri-
zation outlined in Section 3.3. We present a bar chart as
show in Figure 4, where each color represents the number
of classes that fall into each of the identified class charac-
terizations.
</bodyText>
<figure confidence="0.9130142">
13098
# Classes
70 45
Infrastructuralgroup-featuresingle-feature not-covered
0 100 200 300
</figure>
<figureCaption confidence="0.999299">
Figure 4. The Class Characterization View.
</figureCaption>
<sectionHeader confidence="0.843112" genericHeader="method">
5. Case Studies
</sectionHeader>
<bodyText confidence="0.7115682">
In this section we present the results of applying our
feature-driven approach to two concrete case studies, For
our experiments we chose two systems developed by our
group: SmallWiki and BibOuter.
Table 4 gives an overview of the case studies.
</bodyText>
<table confidence="0.903583">
Application Size # of Features Analyzed
SmallWiki 464 classes 11
BibOuter 126 classes 3
</table>
<tableCaption confidence="0.981045">
Table 4. Case Studies
</tableCaption>
<subsectionHeader confidence="0.237033">
5.1. Identifying Features for our Analysis.
</subsectionHeader>
<bodyText confidence="0.982884176470588">
SmallWiki [19] is a collaborative content management sys-
tem used to create, edit and manage hypertext pages on
the web. It is implemented predominately by two develop-
ers from our group. The application is used widely in the
Smalltalk community.
As it is a web-based application. User interaction with
the features of SmallWiki is achieved by selecting the hy-
perlink and form options on its pages. To identify features
Figure 5. Shared-Class-To-Feature-Correlation-View. This shows the correlation between infrastruc-
tural classes and features.
of SmallWiki we associate features with the links and en-
try forms of the SmallWiki pages. We assume that each link
on a page or button of an entry form triggers a distinct fea-
ture of the application.
To achieve a characterization of SmallWiki features, we
selected 11 features for feature-driven analysis. Using or
approach, we consider one possible path of execution for
each feature. Table 5 lists the features of our case study and
the results of applying standalone and relationship measure-
ments.
For each feature we implemented scripts to simulate the
user interactions and thus we trigger these features and cap-
ture a feature-trace in a controlled environment as described
in Section 3. SmallWiki requires a user to login to the sys-
tem before executing some of the features of the system. As
a result our feature-traces initially contain the feature-trace
method calls of the login feature. Therefore we filter out the
login trace calls from our feature-traces so that our traces
are not composed of other features.
BibOuter. This is a small application which is used to parse
a library of references to generate documents in various for-
mats, namely HTML, Latex and XML. We identify 3 fea-
tures of the application by mapping each formatting capa-
bility of the application to a feature.
</bodyText>
<subsectionHeader confidence="0.90172">
5.2. Case Study Results
</subsectionHeader>
<bodyText confidence="0.993702384615385">
Feature Perspective. We applied a feature perspective anal-
ysis to our SmallWiki feature model. Table 5 lists the
features we selected for analysis and shows some of the
measurements we obtained by applying standalone feature
measurements and NOMf # method calls in a feature-
trace (NOMf ) and # classes referenced in feature-trace
(NCRf ). These measurements give an indication of the
size and complexity of the features.
We show a result of applying # classes specific in
feature-trace (NOCSf ). This is a feature relationship
metric. This provides the developer obtain with more pre-
cise information about the number of single-feature classes
that participate in each feature.
</bodyText>
<table confidence="0.99519625">
Feature-trace NOMf NCRf NOCSf Characterization
admin opt 2074 52 0 completely related
changes 2280 46 0 completely related
comps 7944 58 4 tightly related
contents 2615 43 1 tightly related
edit page 7251 67 11 tightly related
edit template 9377 66 10 tightly related
history 2402 54 2 tightly related
login 5273 60 0 completely related
properties 4320 54 1 tightly related
rss generate 2764 33 2 tightly related
stylesheet 6274 54 1 tightly related
</table>
<tableCaption confidence="0.98093">
Table 5. SmallWiki Feature Characterization.
</tableCaption>
<bodyText confidence="0.984111647058823">
The # classes specific in feature-trace (NOCSf ) mea-
surement indicates how many classes are exclusive to
one feature-trace. The feature-set CSf contains ref-
erences to the actual classes. For example, for the
feature-trace rss generate we discover that there are two
single-feature classes, namely RSSChangeFeed and Link.
Similarly, we for the feature-trace edit template we de-
tect 10 single-feature classes.
Figure 6 shows our Feature Characterization View of the
SmallWiki case study. We see these features are either com-
pletely related or tightly related.
Correlation Views. For space reasons, we have included
only one correlation view, namely the Shared-Class-To-
Feature-Correlation-View of our SmallWiki case study as
shown in Figure 5,. We see which of the features are us-
ing the shared computational units. For example, the class
Action is participating in all SmallWiki features.
</bodyText>
<table confidence="0.95324475">
Feature-trace NOMf NCRf NOCSf Characterization
latex opt 11250 13 1 tightly related
html 11339 17 0 completely related
xml 11340 19 2 tightly related
</table>
<tableCaption confidence="0.954201">
Table 6. BibOuter Feature Characterization.
</tableCaption>
<bodyText confidence="0.97139175">
BibOuter Feature Characterization. Table 6 shows the re-
sults of our feature characterization of the BibOuter fea-
tures. From the characterizations we see that these three fea-
tures share most of their functionality. For Latex generation
there is one single-feature class and for XML generation,
there are 2 single-feature classes.
The Class Perspectives We apply our technique to obtain a
characterization of classes and use our TraceScraper tool to
generate class perspective views.
We calculate the measurements # feature-traces refer-
encing a class NOFRC and # references to a class in a
features-trace (NORCf ) to discover the number of infras-
tructural, single-feature and group-feature classes with re-
spect to the feature-model. Figure 7 shows the Class Char-
acterization View obtained for SmallWiki. We summarize
the results obtained for class characterization of both our
</bodyText>
<table confidence="0.92998">
case studies in Table 7.
Characterization SmallWiki BibOuter
# single-feature 34 4
# group-feature 25 0
# infrastructural 67 19
# not-participating 83 40
</table>
<tableCaption confidence="0.99188">
Table 7. Class Characterizations
</tableCaption>
<listItem confidence="0.7582235">
6. Discussion and Evaluation
6.1. Results of the Experiment
</listItem>
<bodyText confidence="0.999742853658536">
The case studies show that by applying our two-sided ap-
proach, we obtain useful information about the way the fea-
tures of a system are implemented and about how the classes
are providing functionality to the features.
Our simple graphical visualizations of feature character-
istics reveal how the functionality of the application is dis-
tributed among the features. Our Feature Characterization
View shows the types of features in an application based on
the characterizations we defined in Section 3.1. This view
shows how features are related in terms of computational
units. For both case studies, we obtained only tightly re-
lated and completely related features. This indicates that
the features share most or all of their computational units
to realize their functionality. We did not discover any dis-
joint or loosely related features. The existence of a disjoint
feature would mean that the behavior of that feature is com-
pletely unique to it. In the case of SmallWiki, we do not ex-
pect to discover disjoint features. We expect the function-
ality that handles user interaction with the web server to be
implemented once and shared by each feature.
Similarly in the case of the BibOuter application, we
evaluate three features that generate documents. The only
variation in these features is that they generate different for-
mats. Therefore we expect that these features share large
parts of their functionality and that the format specific parts
are restricted to a small number of classes. This expecta-
tion corresponds with the results of our analysis.
Our approach promotes an understanding of how ex-
isting features are implemented. Using the high-level fea-
ture and computational unit views, the developer determines
roles that classes and methods play in the features. This
makes it easier for a developer to design and implement a
new feature and reuse existing functionality. Moreover, the
risk of code duplication is minimized, as the developer un-
derstands how existing classes and methods contribute to
the dynamic behavior of the application. For example, if a
developer has to add a new feature to SmallWiki, he can use
his understanding of existing feature implementation to de-
termine which parts of the code he can reuse. Moreover, he
is more likely to adopt existing conventions of the applica-
tion he is modifying to realize the feature.
</bodyText>
<subsectionHeader confidence="0.924289">
6.2. Contributions
</subsectionHeader>
<bodyText confidence="0.850993">
The main contributions of our approach are:
</bodyText>
<listItem confidence="0.99299275">
• We focus the description of our approach in the con-
text of object-oriented applications.
• We propose to combine our feature model with a lan-
guage independent meta-model to relate class, method
</listItem>
<figureCaption confidence="0.9998915">
Figure 6. Feature-Characterization-View for SmallWiki.
Figure 7. The Class Characterization View for SmallWiki.
</figureCaption>
<listItem confidence="0.8608695">
and feature entities. This makes our approach gener-
ally applicable to systems written in different object-
oriented programming languages.
• The emphasis of our approach is ease-of-use and com-
</listItem>
<bodyText confidence="0.959601">
pactness of dynamic information. We condense the in-
formation in the feature-traces to focus on key infor-
mation to achieve the characterizations.
• Our approach proposes a two-sided approach: the fea-
ture perspective and computational unit perspective.
We have shown how our feature-oriented approach es-
tablishes the mapping and relationships between concep-
tual views of the system in terms of requirements and user
views.
The results of our approach depend on the type of chosen
case study application. The reuse of functionality for multi-
ple features is more feasible in infrastructural classes than
in single-feature classes.
</bodyText>
<subsectionHeader confidence="0.905164">
6.3. Constraints and Limitations
</subsectionHeader>
<bodyText confidence="0.999322205128205">
Simplicity: One of arguments against dynamic anal-
ysis based approaches is that it is difficult to achieve
completeness, as all possible paths of execution are not ex-
ercised [24]. We argue that for the purpose of feature loca-
tion, completeness is not necessary. By triggering a feature
in a controlled environment, we collect sufficient data to es-
tablish relationships between features and computational
units.
Mapping traces to features: In our approach we define a
one-to-one mapping between an execution trace and a fea-
ture. Other approaches [4] combine traces from multiple
scenario executions to obtain a feature mapping. At present,
our approach does not consider exhaustive execution of in-
dividual features. Our experiments show that one path of ex-
ecution is sufficient to establish the required mapping. How-
ever, our technique for collecting features is easily extensi-
ble and by adapting our model, we could define a one-to-
many relationship between features and feature-traces.
Size of applications: The size of the system under analy-
sis is an important factor when considering our approach.
Our case studies are relatively small applications. For larger
systems, it would be useful to apply an iterative approach
to locate features by initially considering a coarser granu-
larity of computational unit e.g., a package or subsystem.
Further iterations then focus on classes and methods.
Coverage: In general, coverage of the application by the
feature model affects the characterizations of the features.
If the model contains only one feature, the feature can
only be considered in isolation. Only by executing all fea-
tures of an application do we achieve a stable characteri-
zation of features and computational units. For example,
a class is characterized as single-feature, if participates in
one feature. However, this characterization may change as
soon as the feature-model includes another feature which
references this class. Then the characterization changes to
group-feature.
User-triggerable features: Our approach is limited to user-
triggerable features. However, it is easily extensible to en-
compass features such as housekeeping tasks of a system.
</bodyText>
<sectionHeader confidence="0.907826" genericHeader="related work">
7. Related Work
</sectionHeader>
<bodyText confidence="0.999758651162791">
Many researchers have identified the potential of feature-
centric approaches in software engineering and in particu-
lar as a basis for reverse-engineering [21, 6, 12, 5, 14, 8].
The basis of our work is directly related to the field of dy-
namic analysis [1, 24, ?], requirement and aspect mining
extraction in legacy systems, and user-driven approaches
[10, 9, 15]. A major research focus is in visualization of dy-
namic information [16, 3, 13, 17, 11, 18, 22]. These fields
of research represent the groundwork on which our research
is based.
The research efforts that are closely related to our ap-
proach for identifying features are Wilde and Scully [23],
Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer
et al. [7] and Wong et al. [25]. All of them have developed
techniques based on execution traces. We describe briefly
the approaches that are most closely related to ours.
Wilde and Scully [23] developed a method called Soft-
ware Reconnaissence. They uses test cases to aid in locat-
ing product features. They have applied their methodology
to legacy system case studies written in C.
Eisenbarth et al. [4] describe a methodology which com-
bines dynamic, static and concept analysis. They collect ex-
ecution traces and categorize the methods according to their
degree of specificity to a given feature. The analysis auto-
matically produces a set of concepts which are presented in
a lattice. Using this technique they identify general and spe-
cific parts of the code.
Wong et al. [25] propose three different metrics for mea-
suring the binding of features to components or program
code. They quantitatively capture the disparity between a
program component and a feature, the concentration of a
feature in a program component, and the dedication of pro-
gram component to a feature.
Our approach complements these approaches. In contrast
to the above approaches [4, 23], our main focus is applying
feature-driven analysis to object-oriented applications. We
also emphasize the ease-of-use of our technique. Moreover,
we adopt a two-sided approach in that we consider both
feature and class perspectives in our analysis and charac-
terization. We discover relationships between features and
classes. We define a finer characterization of features based
on simple measurements. We also define measurements to
characterize classes in the context of features.
</bodyText>
<sectionHeader confidence="0.895204" genericHeader="conclusions">
8. Conclusions
</sectionHeader>
<bodyText confidence="0.96864009375">
Software developers handle change requests and bug re-
ports that are expressed in a language that reflects a feature
perspective of a system. We cope with this problem by con-
sidering a feature a first class entity of analysis. We abstract
a feature model of feature-traces and feature-fingerprints
to correlate classes and features. We adopt a two-sided ap-
proach to obtain a characterization of features and computa-
tional units. We outline a feature perspective, and a compu-
tational unit perspective. We define measurements for both
perspectives. Based on our measurements, we defined a vo-
cabulary to characterize features as disjoint, loosely related,
tightly related and completely related.
In our computational unit perspective, we defined a vo-
cabulary to characterize the classes with respect to features.
We characterize the classes as single-feature, group-feature
or infrastructural.
We used a simple graphical visualizations to convey the
results of our two-sided approach. We display both charac-
terization and correlation views from both perspectives.
8.1. Future Work
In the future work, we plan to extend the scope of our
feature approach to consider applying compression and fil-
tering techniques to the dynamic information. In addition,
we plan to extend our feature representation within the fea-
ture model to include multiple paths of execution of a fea-
ture. We expect that as a result we achieve a higher coverage
of classes and methods and increase the accuracy of our ap-
proach.
Acknowledgments: We thank Gabriela Arévalo and Tudor Gı̂rba
for helpful comments. We gratefully acknowledge the financial
support of the Swiss National Science Foundation for the project
“The Achievement and Validation of Evolution-Oriented Software
</bodyText>
<sectionHeader confidence="0.563028" genericHeader="acknowledgments">
Systems” (SNF Project No. PMCD2-102511).
References
</sectionHeader>
<reference confidence="0.999830131868132">
[1] T. Ball. The concept of dynamic analysis. In Proceedings
of ESEC/FSE ’99, number 1687 in LNCS, pages 216–234,
1999.
[2] J. Brant, B. Foote, R. Johnson, and D. Roberts. Wrappers
to the Rescue. In Proceedings ECOOP ’98, volume 1445 of
LNCS, pages 396–417. Springer-Verlag, 1998.
[3] S. Ducasse, M. Lanza, and R. Bertuli. High-level polymet-
ric views of condensed run-time information. In Proceed-
ings of CSMR 2004 (Conference on Software Maintenance
and Reengineering), pages 309 – 318, 2004.
[4] T. Eisenbarth, R. Koschke, and D. Simon. Locating features
in source code. IEEE Computer, 29(3):210–224, Mar. 2003.
[5] M. El-Ramly, E. Stroulia, and P. Sorenson. Recovering soft-
ware requirements from system-user interaction traces. In
Proceedings of the 14th international conference on Soft-
ware engineering and knowledge engineering, pages 447–
454, 2002.
[6] E.Pulvermüller, A. Speck, J.O.Coplien, M. D’Hondt, and
W.DeMeuter. Position paper: Feature interaction in com-
posed systems. In Proceedings of the European Conference
on Object-Oriented Programming, ECOOP 2001, pages 1–6,
2001.
[7] M. Fischer, M. Pinzger, and H. Gall. Analyzing and relating
bug report data for feature tracking. In Proceedings of the
10th Working Conference on Reverse Engineering (WCRE
2003), pages 90–99, Nov. 2003.
[8] I. Hsi and C. Potts. Ontological excavation: Unearthing the
core concepts of an application. In Proceedings of the 2003
10th Working Conference on Reverse Engineering, pages
345–352, Nov. 2003.
[9] I. Jacobson. Use cases and aspects—working seamlessly to-
gether. Journal of Object Technology, 2(4):7–28, July 2003.
[10] I. Jacobson, M. Christerson, P. Jonsson, and G. Over-
gaard. Object-Oriented Software Engineering — A Use Case
Driven Approach. Addison Wesley/ACM Press, Reading,
Mass., 1992.
[11] M. Lanza and S. Ducasse. Understanding software evolution
using a combination of software visualization and software
metrics. In Proceedings of LMO 2002 (Langages et Modèles
à Objets, pages 135–149, 2002.
[12] D. Licata, C. Harris, and S. Krishnamurthi. The feature sig-
natures of evolving programs. Automated Software Engi-
neering, 2003.
[13] L. M. A. G. J. Martin. Dynamic component program visual-
ization. In Proceedings of ninth Working Conference on Re-
verse Engineering, 2002.
[14] A. Mehta and G. T. Heineman. Evolving legacy systems fea-
tures using regression test cases and components. In Pro-
ceedings of the 4th international workshop on Principles of
software evolution, pages 190–193. ACM Press, 2002.
[15] A. Memon, I. Banerjee, and A. Nagarajan. Gui ripping: Re-
verse engineering of graphical user interfaces for testing. In
Proceedings of the 2003 10 Working Conference on Reverse
Engineering (WCRE’03), pages 260–269, Victoria, Canada,
2003.
[16] M. Pacione, M. Roper, and M. Wood. A Comparative Eval-
uation of Dynamic Visualization Tools. In Proceedings
of WCRE ’03, pages 80–89. IEEE Computer Society, Nov.
2003.
[17] W. D. Pauw, R. Helm, D. Kimelman, and J. Vlissides. Visu-
alizing the behavior of object-oriented systems. In Proceed-
ings OOPSLA ’93, pages 326–337, Oct. 1993.
[18] S. P. Reiss, editor. Visualizing Java in Action, May 2003.
[19] L. Renggli. Smallwiki: Collaborative content management.
Informatikprojekt, University of Bern, 2003.
[20] T. Richner and S. Ducasse. Using dynamic information for
the iterative recovery of collaborations and roles. In Pro-
ceedings of ICSM ’2002 (International Conference on Soft-
ware Maintenance), Oct. 2002.
[21] C. R. Turner, A. L. Wolf, A. Fuggetta, and L. Lavazza. Fea-
ture engineering. In Proceedings of the 9th International
Workshop on Software Specification and Design, page 162.
IEEE Computer Society, 1998.
[22] R. J. Walker, G. C. Murphy, B. Freeman-Benson, D. Wright,
D. Swanson, and J. Isaak. Visualizing dynamic software sys-
tem information through high-level models. In Proceedings
OOPSLA ’98, pages 271–283. ACM, Oct. 1998.
[23] N. Wilde and M. C. Scully. Software reconnaisance: Map-
ping program features to code. Software Maintenance: Re-
search and Practice, 7(1):49–62, 1995.
[24] J. Winstead and D. Evans. Towards differential program
analysis. In Proceedings WODA 2003 the Workshop on Dy-
namic Analysis, pages 37–40, Portland, Oregon, May 2003.
[25] W. E. Wong, S. S. Gokhale, and J. R. Horgan. Quantifying
the closeness between program components and features. J.
Syst. Softw., 54(2):87–98, 2000.
[26] A. Zaidman and S. Demeyer. Managing trace data volume
through a heuristical clustering process based on event exe-
cution frequency. In Proceedings of the 8th European Con-
ference on Software Maintenance and Reengineering, pages
329–338, Mar. 2004.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.118106">
<title confidence="0.7797505">Correlating Features and Code Using A Compact Two-Sided Trace Analysis Approach</title>
<note confidence="0.650906">accepted to CSMR 2005</note>
<author confidence="0.717371">Orla Greevy</author>
<author confidence="0.717371">Stéphane Ducasse</author>
<affiliation confidence="0.902128">Software Composition Group Institut für Informatik und angewandte Mathematik University of Bern, Switzerland</affiliation>
<email confidence="0.974732">greevy@iam.unibe.ch</email>
<email confidence="0.974732">ducasse@iam.unibe.ch</email>
<abstract confidence="0.999932625">Software developers are constantly required to modify and adapt application features in response to changing requirements. The problem is that just by reading the source code, it is difficult to determine how classes and methods contribute to the runtime behavior of features. Moreover, dependencies between system features are not obvious, consequently software maintenance operations often result in unintended side effects. To tackle these problems, we propose a compact feature-driven approach (i.e., summarized trace information) based on dynamic analysis to characterize features and computational units of an application. We extract execution traces to achieve an explicit mapping between features and classes using two complementary perspectives. We apply our approach to two case studies and we report our findings.</abstract>
<keyword confidence="0.7904335">Keywords: Feature, Feature-Traces, Dynamic Analysis, Software Evolution, Software Metrics.</keyword>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>T Ball</author>
</authors>
<title>The concept of dynamic analysis.</title>
<date>1999</date>
<booktitle>In Proceedings of ESEC/FSE ’99, number 1687 in LNCS,</booktitle>
<pages>216--234</pages>
<marker>[1]</marker>
<rawString>T. Ball. The concept of dynamic analysis. In Proceedings of ESEC/FSE ’99, number 1687 in LNCS, pages 216–234, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Brant</author>
<author>B Foote</author>
<author>R Johnson</author>
<author>D Roberts</author>
</authors>
<title>Wrappers to the Rescue.</title>
<date>1998</date>
<booktitle>In Proceedings ECOOP ’98,</booktitle>
<volume>1445</volume>
<pages>396--417</pages>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="8979" citStr="[2]" startWordPosition="1417" endWordPosition="1417">B Login Edit 899 34 5 950 45 3 887... ... featurefingerprints Computational Unit Perspective Feature Perspective A B Login Edit Traces Figure 2. Our Two-Sided approach. We propose two views based on summarized traces. 3.1. Obtaining Reproducible Feature-Traces. Our first step is to identify the features to include in our analysis. We do not require complete coverage of the system’s functionality to obtain a feature model (as discussed in Section 6). Our approach allows the developer to focus on a subset of features of interest. We build an analysis tool TraceScraper which uses method wrappers [2] to instrument the application code. The unit of observable behavior that we identify as being a feature should be defined as small as possible [6]. This limits the volume of data generated by the feature capture. Our tool simulates the user by scripting user actions and invokes each script separately. In this way it interacts with the application to trigger the feature behavior. The behavior is traced in a controlled environment. This means that no other system activity occurs at the time of capture. For each feature-trace captured, we start our case study application before triggering the in</context>
</contexts>
<marker>[2]</marker>
<rawString>J. Brant, B. Foote, R. Johnson, and D. Roberts. Wrappers to the Rescue. In Proceedings ECOOP ’98, volume 1445 of LNCS, pages 396–417. Springer-Verlag, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Ducasse</author>
<author>M Lanza</author>
<author>R Bertuli</author>
</authors>
<title>High-level polymetric views of condensed run-time information.</title>
<date>2004</date>
<booktitle>In Proceedings of CSMR 2004 (Conference on Software Maintenance and Reengineering),</booktitle>
<pages>309--318</pages>
<contexts>
<context position="2909" citStr="[20, 26, 3]" startWordPosition="452" endWordPosition="454"> to modify or adapt it. • How are features related to each other? Knowing which features could be affected by modifications helps the developer estimate which parts of the system could be affected and need regression testing. Several works [4, 25] have shown that dynamic analysis is a reliable means of associating behaviors of a system with the internal components of its implementation. However, dynamic analysis-based approaches tend to be complex. The main reason is it is diffcult to design tools that process the huge volume of trace data and present the information in an understandable form [20, 26, 3]. Considering the characteristics of previous works, the key contributions of our approach are: (1) an easy-to-use approach, (2) compactness of the trace information and (3) two-sided views. Our approach is easy-to-use as we define a simple mapping between system behaviors and features. We automate the capture of individual traces of features that can be reproduced every time we need to experiment with them. Moreover, we compute some simple sets from the traces, which we use to characterize features and computational units of an application. We tackle the problem of handling huge amount of inf</context>
<context position="29490" citStr="[16, 3, 13, 17, 11, 18, 22]" startWordPosition="4655" endWordPosition="4661">tures: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to leg</context>
</contexts>
<marker>[3]</marker>
<rawString>S. Ducasse, M. Lanza, and R. Bertuli. High-level polymetric views of condensed run-time information. In Proceedings of CSMR 2004 (Conference on Software Maintenance and Reengineering), pages 309 – 318, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Eisenbarth</author>
<author>R Koschke</author>
<author>D Simon</author>
</authors>
<title>Locating features in source code.</title>
<date>2003</date>
<journal>IEEE Computer,</journal>
<volume>29</volume>
<issue>3</issue>
<contexts>
<context position="2545" citStr="[4, 25]" startWordPosition="390" endWordPosition="391">nderstanding how a feature is implemented is essential for the software maintenance phase of a system. Moreover, developers tend to use their knowledge of how existing features are implemented as a basis for adding new features. • How do classes relate to features? Knowledge of the role of a class in the behavior of a system is useful, when a developer needs to modify or adapt it. • How are features related to each other? Knowing which features could be affected by modifications helps the developer estimate which parts of the system could be affected and need regression testing. Several works [4, 25] have shown that dynamic analysis is a reliable means of associating behaviors of a system with the internal components of its implementation. However, dynamic analysis-based approaches tend to be complex. The main reason is it is diffcult to design tools that process the huge volume of trace data and present the information in an understandable form [20, 26, 3]. Considering the characteristics of previous works, the key contributions of our approach are: (1) an easy-to-use approach, (2) compactness of the trace information and (3) two-sided views. Our approach is easy-to-use as we define a si</context>
<context position="4856" citStr="[4]" startWordPosition="772" endWordPosition="772">s follows: in Section 2 we introduce the terminology of our approach. In Sections 3 and 4 we introduce our two-sided approach and the high-level views we extract. In Section 5 we report on two case studies we conducted using our approach and present the results. Subsequently, in Section 6 we discuss our findings and outline the constraints and limitations of our approach. We summarize related work in Section 7. Finally, we outline our conclusions and future work in Section 8. 2. Terminology In this paper we adopt the definitions of features and computational units proposed by Eisenbarth et al.[4] and refine them for the purpose of our approach. Feature. “A feature is a realized functional requirement of a system. A feature is an observable unit of behavior of a system triggered by the user” [4]. Not all features of an application satisfy this definition. System internal housekeeping tasks, for example, are not triggered directly as a result of user interaction. We limit the scope of our investigation to user-initiated features. We focus on the user-interface of an application to determine which user-observable features are most adequate to include in our analysis. Computational units.</context>
<context position="27398" citStr="[4]" startWordPosition="4334" endWordPosition="4334">ingle-feature classes. 6.3. Constraints and Limitations Simplicity: One of arguments against dynamic analysis based approaches is that it is difficult to achieve completeness, as all possible paths of execution are not exercised [24]. We argue that for the purpose of feature location, completeness is not necessary. By triggering a feature in a controlled environment, we collect sufficient data to establish relationships between features and computational units. Mapping traces to features: In our approach we define a one-to-one mapping between an execution trace and a feature. Other approaches [4] combine traces from multiple scenario executions to obtain a feature mapping. At present, our approach does not consider exhaustive execution of individual features. Our experiments show that one path of execution is sufficient to establish the required mapping. However, our technique for collecting features is easily extensible and by adapting our model, we could define a one-tomany relationship between features and feature-traces. Size of applications: The size of the system under analysis is an important factor when considering our approach. Our case studies are relatively small applicatio</context>
<context position="29709" citStr="[4]" startWordPosition="4697" endWordPosition="4697">hes in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to legacy system case studies written in C. Eisenbarth et al. [4] describe a methodology which combines dynamic, static and concept analysis. They collect execution traces and categorize the methods according to their degree </context>
</contexts>
<marker>[4]</marker>
<rawString>T. Eisenbarth, R. Koschke, and D. Simon. Locating features in source code. IEEE Computer, 29(3):210–224, Mar. 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M El-Ramly</author>
<author>E Stroulia</author>
<author>P Sorenson</author>
</authors>
<title>Recovering software requirements from system-user interaction traces.</title>
<date>2002</date>
<booktitle>In Proceedings of the 14th international conference on Software engineering and knowledge engineering,</booktitle>
<pages>447--454</pages>
<contexts>
<context position="29208" citStr="[21, 6, 12, 5, 14, 8]" startWordPosition="4606" endWordPosition="4611">e, a class is characterized as single-feature, if participates in one feature. However, this characterization may change as soon as the feature-model includes another feature which references this class. Then the characterization changes to group-feature. User-triggerable features: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed tec</context>
</contexts>
<marker>[5]</marker>
<rawString>M. El-Ramly, E. Stroulia, and P. Sorenson. Recovering software requirements from system-user interaction traces. In Proceedings of the 14th international conference on Software engineering and knowledge engineering, pages 447– 454, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Speck E Pulvermuller</author>
<author>M D’Hondt J O Coplien</author>
</authors>
<title>and W.DeMeuter. Position paper: Feature interaction in composed systems.</title>
<date>2001</date>
<booktitle>In Proceedings of the European Conference on Object-Oriented Programming, ECOOP</booktitle>
<pages>1--6</pages>
<contexts>
<context position="9126" citStr="[6]" startWordPosition="1443" endWordPosition="1443">r Two-Sided approach. We propose two views based on summarized traces. 3.1. Obtaining Reproducible Feature-Traces. Our first step is to identify the features to include in our analysis. We do not require complete coverage of the system’s functionality to obtain a feature model (as discussed in Section 6). Our approach allows the developer to focus on a subset of features of interest. We build an analysis tool TraceScraper which uses method wrappers [2] to instrument the application code. The unit of observable behavior that we identify as being a feature should be defined as small as possible [6]. This limits the volume of data generated by the feature capture. Our tool simulates the user by scripting user actions and invokes each script separately. In this way it interacts with the application to trigger the feature behavior. The behavior is traced in a controlled environment. This means that no other system activity occurs at the time of capture. For each feature-trace captured, we start our case study application before triggering the individual feature. By doing so we ensure that our technique always yields the same feature-trace. 3.2. The Features Perspective With the feature-per</context>
<context position="29208" citStr="[21, 6, 12, 5, 14, 8]" startWordPosition="4606" endWordPosition="4611">e, a class is characterized as single-feature, if participates in one feature. However, this characterization may change as soon as the feature-model includes another feature which references this class. Then the characterization changes to group-feature. User-triggerable features: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed tec</context>
</contexts>
<marker>[6]</marker>
<rawString>E.Pulvermüller, A. Speck, J.O.Coplien, M. D’Hondt, and W.DeMeuter. Position paper: Feature interaction in composed systems. In Proceedings of the European Conference on Object-Oriented Programming, ECOOP 2001, pages 1–6, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Fischer</author>
<author>M Pinzger</author>
<author>H Gall</author>
</authors>
<title>Analyzing and relating bug report data for feature tracking.</title>
<date>2003</date>
<booktitle>In Proceedings of the 10th Working Conference on Reverse Engineering (WCRE</booktitle>
<pages>90--99</pages>
<contexts>
<context position="29755" citStr="[7]" startWordPosition="4705" endWordPosition="4705">as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to legacy system case studies written in C. Eisenbarth et al. [4] describe a methodology which combines dynamic, static and concept analysis. They collect execution traces and categorize the methods according to their degree of specificity to a given feature. The analysi</context>
</contexts>
<marker>[7]</marker>
<rawString>M. Fischer, M. Pinzger, and H. Gall. Analyzing and relating bug report data for feature tracking. In Proceedings of the 10th Working Conference on Reverse Engineering (WCRE 2003), pages 90–99, Nov. 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Hsi</author>
<author>C Potts</author>
</authors>
<title>Ontological excavation: Unearthing the core concepts of an application.</title>
<date>2003</date>
<booktitle>In Proceedings of the 2003 10th Working Conference on Reverse Engineering,</booktitle>
<pages>345--352</pages>
<contexts>
<context position="29208" citStr="[21, 6, 12, 5, 14, 8]" startWordPosition="4606" endWordPosition="4611">e, a class is characterized as single-feature, if participates in one feature. However, this characterization may change as soon as the feature-model includes another feature which references this class. Then the characterization changes to group-feature. User-triggerable features: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed tec</context>
</contexts>
<marker>[8]</marker>
<rawString>I. Hsi and C. Potts. Ontological excavation: Unearthing the core concepts of an application. In Proceedings of the 2003 10th Working Conference on Reverse Engineering, pages 345–352, Nov. 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Jacobson</author>
</authors>
<title>Use cases and aspects—working seamlessly together.</title>
<date>2003</date>
<journal>Journal of Object Technology,</journal>
<volume>2</volume>
<issue>4</issue>
<contexts>
<context position="29395" citStr="[10, 9, 15]" startWordPosition="4641" endWordPosition="4643">class. Then the characterization changes to group-feature. User-triggerable features: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They </context>
</contexts>
<marker>[9]</marker>
<rawString>I. Jacobson. Use cases and aspects—working seamlessly together. Journal of Object Technology, 2(4):7–28, July 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Jacobson</author>
<author>M Christerson</author>
<author>P Jonsson</author>
<author>G Overgaard</author>
</authors>
<title>Object-Oriented Software Engineering — A Use Case Driven Approach.</title>
<date>1992</date>
<publisher>Addison Wesley/ACM Press,</publisher>
<location>Reading, Mass.,</location>
<contexts>
<context position="29395" citStr="[10, 9, 15]" startWordPosition="4641" endWordPosition="4643">class. Then the characterization changes to group-feature. User-triggerable features: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They </context>
</contexts>
<marker>[10]</marker>
<rawString>I. Jacobson, M. Christerson, P. Jonsson, and G. Overgaard. Object-Oriented Software Engineering — A Use Case Driven Approach. Addison Wesley/ACM Press, Reading, Mass., 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Lanza</author>
<author>S Ducasse</author>
</authors>
<title>Understanding software evolution using a combination of software visualization and software metrics.</title>
<date>2002</date>
<booktitle>In Proceedings of LMO 2002 (Langages et Modeles a Objets,</booktitle>
<pages>135--149</pages>
<contexts>
<context position="29490" citStr="[16, 3, 13, 17, 11, 18, 22]" startWordPosition="4655" endWordPosition="4661">tures: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to leg</context>
</contexts>
<marker>[11]</marker>
<rawString>M. Lanza and S. Ducasse. Understanding software evolution using a combination of software visualization and software metrics. In Proceedings of LMO 2002 (Langages et Modèles à Objets, pages 135–149, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Licata</author>
<author>C Harris</author>
<author>S Krishnamurthi</author>
</authors>
<title>The feature signatures of evolving programs. Automated Software Engineering,</title>
<date>2003</date>
<contexts>
<context position="29208" citStr="[21, 6, 12, 5, 14, 8]" startWordPosition="4606" endWordPosition="4611">e, a class is characterized as single-feature, if participates in one feature. However, this characterization may change as soon as the feature-model includes another feature which references this class. Then the characterization changes to group-feature. User-triggerable features: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed tec</context>
</contexts>
<marker>[12]</marker>
<rawString>D. Licata, C. Harris, and S. Krishnamurthi. The feature signatures of evolving programs. Automated Software Engineering, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L M A G J Martin</author>
</authors>
<title>Dynamic component program visualization.</title>
<date>2002</date>
<booktitle>In Proceedings of ninth Working Conference on Reverse Engineering,</booktitle>
<contexts>
<context position="29490" citStr="[16, 3, 13, 17, 11, 18, 22]" startWordPosition="4655" endWordPosition="4661">tures: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to leg</context>
</contexts>
<marker>[13]</marker>
<rawString>L. M. A. G. J. Martin. Dynamic component program visualization. In Proceedings of ninth Working Conference on Reverse Engineering, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Mehta</author>
<author>G T Heineman</author>
</authors>
<title>Evolving legacy systems features using regression test cases and components.</title>
<date>2002</date>
<booktitle>In Proceedings of the 4th international workshop on Principles of software evolution,</booktitle>
<pages>190--193</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="1503" citStr="[14]" startWordPosition="213" endWordPosition="213">an application. We extract execution traces to achieve an explicit mapping between features and classes using two complementary perspectives. We apply our approach to two case studies and we report our findings. Keywords: Feature, Feature-Traces, Dynamic Analysis, Software Evolution, Software Metrics. 1. Introduction Developers who maintain and extend complex software systems are expected to translate change requests and bug reports into modifications in the code. This task is difficult because such requests are usually expressed in a language that reflects a feature perspective of the system [14]. As a result, developers spend lot of time locating relevant parts of the code before making the required modifications. If they are uncertain about how the features of a system interact, they risk adversely impacting other features as a result of their changes. To address these problems we propose a two-sided approach to feature analysis. Essentially we aim to answer the following questions: • How do features relate to classes? Understanding how a feature is implemented is essential for the software maintenance phase of a system. Moreover, developers tend to use their knowledge of how existi</context>
<context position="29208" citStr="[21, 6, 12, 5, 14, 8]" startWordPosition="4606" endWordPosition="4611">e, a class is characterized as single-feature, if participates in one feature. However, this characterization may change as soon as the feature-model includes another feature which references this class. Then the characterization changes to group-feature. User-triggerable features: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed tec</context>
</contexts>
<marker>[14]</marker>
<rawString>A. Mehta and G. T. Heineman. Evolving legacy systems features using regression test cases and components. In Proceedings of the 4th international workshop on Principles of software evolution, pages 190–193. ACM Press, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Memon</author>
<author>I Banerjee</author>
<author>A Nagarajan</author>
</authors>
<title>Gui ripping: Reverse engineering of graphical user interfaces for testing.</title>
<date>2003</date>
<booktitle>In Proceedings of the 2003 10 Working Conference on Reverse Engineering (WCRE’03),</booktitle>
<pages>260--269</pages>
<location>Victoria, Canada,</location>
<contexts>
<context position="29395" citStr="[10, 9, 15]" startWordPosition="4641" endWordPosition="4643">class. Then the characterization changes to group-feature. User-triggerable features: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They </context>
</contexts>
<marker>[15]</marker>
<rawString>A. Memon, I. Banerjee, and A. Nagarajan. Gui ripping: Reverse engineering of graphical user interfaces for testing. In Proceedings of the 2003 10 Working Conference on Reverse Engineering (WCRE’03), pages 260–269, Victoria, Canada, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Pacione</author>
<author>M Roper</author>
<author>M Wood</author>
</authors>
<title>A Comparative Evaluation of Dynamic Visualization Tools.</title>
<date>2003</date>
<booktitle>In Proceedings of WCRE ’03,</booktitle>
<pages>80--89</pages>
<publisher>IEEE Computer Society,</publisher>
<contexts>
<context position="29490" citStr="[16, 3, 13, 17, 11, 18, 22]" startWordPosition="4655" endWordPosition="4661">tures: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to leg</context>
</contexts>
<marker>[16]</marker>
<rawString>M. Pacione, M. Roper, and M. Wood. A Comparative Evaluation of Dynamic Visualization Tools. In Proceedings of WCRE ’03, pages 80–89. IEEE Computer Society, Nov. 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W D Pauw</author>
<author>R Helm</author>
<author>D Kimelman</author>
<author>J Vlissides</author>
</authors>
<title>Visualizing the behavior of object-oriented systems.</title>
<date>1993</date>
<booktitle>In Proceedings OOPSLA ’93,</booktitle>
<pages>326--337</pages>
<contexts>
<context position="29490" citStr="[16, 3, 13, 17, 11, 18, 22]" startWordPosition="4655" endWordPosition="4661">tures: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to leg</context>
</contexts>
<marker>[17]</marker>
<rawString>W. D. Pauw, R. Helm, D. Kimelman, and J. Vlissides. Visualizing the behavior of object-oriented systems. In Proceedings OOPSLA ’93, pages 326–337, Oct. 1993.</rawString>
</citation>
<citation valid="true">
<date>2003</date>
<booktitle>Visualizing Java in Action,</booktitle>
<editor>S. P. Reiss, editor.</editor>
<contexts>
<context position="29490" citStr="[16, 3, 13, 17, 11, 18, 22]" startWordPosition="4655" endWordPosition="4661">tures: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to leg</context>
</contexts>
<marker>[18]</marker>
<rawString>S. P. Reiss, editor. Visualizing Java in Action, May 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>L Renggli</author>
</authors>
<title>Smallwiki: Collaborative content management.</title>
<date>2003</date>
<institution>Informatikprojekt, University of Bern,</institution>
<contexts>
<context position="18060" citStr="[19]" startWordPosition="2856" endWordPosition="2856"> the identified class characterizations. 13098 # Classes 70 45 Infrastructuralgroup-featuresingle-feature not-covered 0 100 200 300 Figure 4. The Class Characterization View. 5. Case Studies In this section we present the results of applying our feature-driven approach to two concrete case studies, For our experiments we chose two systems developed by our group: SmallWiki and BibOuter. Table 4 gives an overview of the case studies. Application Size # of Features Analyzed SmallWiki 464 classes 11 BibOuter 126 classes 3 Table 4. Case Studies 5.1. Identifying Features for our Analysis. SmallWiki [19] is a collaborative content management system used to create, edit and manage hypertext pages on the web. It is implemented predominately by two developers from our group. The application is used widely in the Smalltalk community. As it is a web-based application. User interaction with the features of SmallWiki is achieved by selecting the hyperlink and form options on its pages. To identify features Figure 5. Shared-Class-To-Feature-Correlation-View. This shows the correlation between infrastructural classes and features. of SmallWiki we associate features with the links and entry forms of th</context>
</contexts>
<marker>[19]</marker>
<rawString>L. Renggli. Smallwiki: Collaborative content management. Informatikprojekt, University of Bern, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T Richner</author>
<author>S Ducasse</author>
</authors>
<title>Using dynamic information for the iterative recovery of collaborations and roles.</title>
<date>2002</date>
<booktitle>In Proceedings of ICSM ’2002 (International Conference on Software Maintenance),</booktitle>
<contexts>
<context position="2909" citStr="[20, 26, 3]" startWordPosition="452" endWordPosition="454"> to modify or adapt it. • How are features related to each other? Knowing which features could be affected by modifications helps the developer estimate which parts of the system could be affected and need regression testing. Several works [4, 25] have shown that dynamic analysis is a reliable means of associating behaviors of a system with the internal components of its implementation. However, dynamic analysis-based approaches tend to be complex. The main reason is it is diffcult to design tools that process the huge volume of trace data and present the information in an understandable form [20, 26, 3]. Considering the characteristics of previous works, the key contributions of our approach are: (1) an easy-to-use approach, (2) compactness of the trace information and (3) two-sided views. Our approach is easy-to-use as we define a simple mapping between system behaviors and features. We automate the capture of individual traces of features that can be reproduced every time we need to experiment with them. Moreover, we compute some simple sets from the traces, which we use to characterize features and computational units of an application. We tackle the problem of handling huge amount of inf</context>
</contexts>
<marker>[20]</marker>
<rawString>T. Richner and S. Ducasse. Using dynamic information for the iterative recovery of collaborations and roles. In Proceedings of ICSM ’2002 (International Conference on Software Maintenance), Oct. 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C R Turner</author>
<author>A L Wolf</author>
<author>A Fuggetta</author>
<author>L Lavazza</author>
</authors>
<title>Feature engineering.</title>
<date>1998</date>
<booktitle>In Proceedings of the 9th International Workshop on Software Specification and Design,</booktitle>
<pages>162</pages>
<publisher>IEEE Computer Society,</publisher>
<contexts>
<context position="29208" citStr="[21, 6, 12, 5, 14, 8]" startWordPosition="4606" endWordPosition="4611">e, a class is characterized as single-feature, if participates in one feature. However, this characterization may change as soon as the feature-model includes another feature which references this class. Then the characterization changes to group-feature. User-triggerable features: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed tec</context>
</contexts>
<marker>[21]</marker>
<rawString>C. R. Turner, A. L. Wolf, A. Fuggetta, and L. Lavazza. Feature engineering. In Proceedings of the 9th International Workshop on Software Specification and Design, page 162. IEEE Computer Society, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R J Walker</author>
<author>G C Murphy</author>
<author>B Freeman-Benson</author>
<author>D Wright</author>
<author>D Swanson</author>
<author>J Isaak</author>
</authors>
<title>Visualizing dynamic software system information through high-level models.</title>
<date>1998</date>
<booktitle>In Proceedings OOPSLA ’98,</booktitle>
<pages>271--283</pages>
<publisher>ACM,</publisher>
<contexts>
<context position="29490" citStr="[16, 3, 13, 17, 11, 18, 22]" startWordPosition="4655" endWordPosition="4661">tures: Our approach is limited to usertriggerable features. However, it is easily extensible to encompass features such as housekeeping tasks of a system. 7. Related Work Many researchers have identified the potential of featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to leg</context>
</contexts>
<marker>[22]</marker>
<rawString>R. J. Walker, G. C. Murphy, B. Freeman-Benson, D. Wright, D. Swanson, and J. Isaak. Visualizing dynamic software system information through high-level models. In Proceedings OOPSLA ’98, pages 271–283. ACM, Oct. 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Wilde</author>
<author>M C Scully</author>
</authors>
<title>Software reconnaisance: Mapping program features to code.</title>
<date>1995</date>
<journal>Software Maintenance: Research and Practice,</journal>
<volume>7</volume>
<issue>1</issue>
<contexts>
<context position="29686" citStr="[23]" startWordPosition="4693" endWordPosition="4693">f featurecentric approaches in software engineering and in particular as a basis for reverse-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to legacy system case studies written in C. Eisenbarth et al. [4] describe a methodology which combines dynamic, static and concept analysis. They collect execution traces and categorize the methods acc</context>
<context position="30905" citStr="[4, 23]" startWordPosition="4892" endWordPosition="4893">eir degree of specificity to a given feature. The analysis automatically produces a set of concepts which are presented in a lattice. Using this technique they identify general and specific parts of the code. Wong et al. [25] propose three different metrics for measuring the binding of features to components or program code. They quantitatively capture the disparity between a program component and a feature, the concentration of a feature in a program component, and the dedication of program component to a feature. Our approach complements these approaches. In contrast to the above approaches [4, 23], our main focus is applying feature-driven analysis to object-oriented applications. We also emphasize the ease-of-use of our technique. Moreover, we adopt a two-sided approach in that we consider both feature and class perspectives in our analysis and characterization. We discover relationships between features and classes. We define a finer characterization of features based on simple measurements. We also define measurements to characterize classes in the context of features. 8. Conclusions Software developers handle change requests and bug reports that are expressed in a language that ref</context>
</contexts>
<marker>[23]</marker>
<rawString>N. Wilde and M. C. Scully. Software reconnaisance: Mapping program features to code. Software Maintenance: Research and Practice, 7(1):49–62, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Winstead</author>
<author>D Evans</author>
</authors>
<title>Towards differential program analysis.</title>
<date>2003</date>
<booktitle>In Proceedings WODA 2003 the Workshop on Dynamic Analysis,</booktitle>
<pages>37--40</pages>
<location>Portland, Oregon,</location>
<contexts>
<context position="27028" citStr="[24]" startWordPosition="4276" endWordPosition="4276">unit perspective. We have shown how our feature-oriented approach establishes the mapping and relationships between conceptual views of the system in terms of requirements and user views. The results of our approach depend on the type of chosen case study application. The reuse of functionality for multiple features is more feasible in infrastructural classes than in single-feature classes. 6.3. Constraints and Limitations Simplicity: One of arguments against dynamic analysis based approaches is that it is difficult to achieve completeness, as all possible paths of execution are not exercised [24]. We argue that for the purpose of feature location, completeness is not necessary. By triggering a feature in a controlled environment, we collect sufficient data to establish relationships between features and computational units. Mapping traces to features: In our approach we define a one-to-one mapping between an execution trace and a feature. Other approaches [4] combine traces from multiple scenario executions to obtain a feature mapping. At present, our approach does not consider exhaustive execution of individual features. Our experiments show that one path of execution is sufficient t</context>
</contexts>
<marker>[24]</marker>
<rawString>J. Winstead and D. Evans. Towards differential program analysis. In Proceedings WODA 2003 the Workshop on Dynamic Analysis, pages 37–40, Portland, Oregon, May 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W E Wong</author>
<author>S S Gokhale</author>
<author>J R Horgan</author>
</authors>
<title>Quantifying the closeness between program components and features.</title>
<date>2000</date>
<journal>J. Syst. Softw.,</journal>
<volume>54</volume>
<issue>2</issue>
<contexts>
<context position="2545" citStr="[4, 25]" startWordPosition="390" endWordPosition="391">nderstanding how a feature is implemented is essential for the software maintenance phase of a system. Moreover, developers tend to use their knowledge of how existing features are implemented as a basis for adding new features. • How do classes relate to features? Knowledge of the role of a class in the behavior of a system is useful, when a developer needs to modify or adapt it. • How are features related to each other? Knowing which features could be affected by modifications helps the developer estimate which parts of the system could be affected and need regression testing. Several works [4, 25] have shown that dynamic analysis is a reliable means of associating behaviors of a system with the internal components of its implementation. However, dynamic analysis-based approaches tend to be complex. The main reason is it is diffcult to design tools that process the huge volume of trace data and present the information in an understandable form [20, 26, 3]. Considering the characteristics of previous works, the key contributions of our approach are: (1) an easy-to-use approach, (2) compactness of the trace information and (3) two-sided views. Our approach is easy-to-use as we define a si</context>
<context position="29776" citStr="[25]" startWordPosition="4710" endWordPosition="4710">se-engineering [21, 6, 12, 5, 14, 8]. The basis of our work is directly related to the field of dynamic analysis [1, 24, ?], requirement and aspect mining extraction in legacy systems, and user-driven approaches [10, 9, 15]. A major research focus is in visualization of dynamic information [16, 3, 13, 17, 11, 18, 22]. These fields of research represent the groundwork on which our research is based. The research efforts that are closely related to our approach for identifying features are Wilde and Scully [23], Eisenbarth et al. [4], Mehta and Heinemann [14], Fischer et al. [7] and Wong et al. [25]. All of them have developed techniques based on execution traces. We describe briefly the approaches that are most closely related to ours. Wilde and Scully [23] developed a method called Software Reconnaissence. They uses test cases to aid in locating product features. They have applied their methodology to legacy system case studies written in C. Eisenbarth et al. [4] describe a methodology which combines dynamic, static and concept analysis. They collect execution traces and categorize the methods according to their degree of specificity to a given feature. The analysis automatically produ</context>
</contexts>
<marker>[25]</marker>
<rawString>W. E. Wong, S. S. Gokhale, and J. R. Horgan. Quantifying the closeness between program components and features. J. Syst. Softw., 54(2):87–98, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Zaidman</author>
<author>S Demeyer</author>
</authors>
<title>Managing trace data volume through a heuristical clustering process based on event execution frequency.</title>
<date>2004</date>
<booktitle>In Proceedings of the 8th European Conference on Software Maintenance and Reengineering,</booktitle>
<pages>329--338</pages>
<contexts>
<context position="2909" citStr="[20, 26, 3]" startWordPosition="452" endWordPosition="454"> to modify or adapt it. • How are features related to each other? Knowing which features could be affected by modifications helps the developer estimate which parts of the system could be affected and need regression testing. Several works [4, 25] have shown that dynamic analysis is a reliable means of associating behaviors of a system with the internal components of its implementation. However, dynamic analysis-based approaches tend to be complex. The main reason is it is diffcult to design tools that process the huge volume of trace data and present the information in an understandable form [20, 26, 3]. Considering the characteristics of previous works, the key contributions of our approach are: (1) an easy-to-use approach, (2) compactness of the trace information and (3) two-sided views. Our approach is easy-to-use as we define a simple mapping between system behaviors and features. We automate the capture of individual traces of features that can be reproduced every time we need to experiment with them. Moreover, we compute some simple sets from the traces, which we use to characterize features and computational units of an application. We tackle the problem of handling huge amount of inf</context>
</contexts>
<marker>[26]</marker>
<rawString>A. Zaidman and S. Demeyer. Managing trace data volume through a heuristical clustering process based on event execution frequency. In Proceedings of the 8th European Conference on Software Maintenance and Reengineering, pages 329–338, Mar. 2004.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>