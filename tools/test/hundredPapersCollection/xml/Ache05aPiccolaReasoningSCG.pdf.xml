<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.9506555">
A Calculus for Reasoning about
Software Composition
</title>
<author confidence="0.727835">
Franz Achermann and Oscar Nierstrasz
</author>
<affiliation confidence="0.8251815">
Software Composition Group
University of Bern, Switzerland
</affiliation>
<email confidence="0.685377">
www.iam.unibe.ch/∼scg
</email>
<sectionHeader confidence="0.982677" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.919072333333334">
Although the term software component has become commonplace, there is no uni-
versally accepted definition of the term, nor does there exist a common foundation
for specifying various kinds of components and their compositions. We propose such
a foundation. The Piccola calculus is a process calculus, based on the asynchronous
π-calculus, extended with explicit namespaces. The calculus is high-level, rather
than minimal, and is consequently convenient for expressing and reasoning about
software components, and different styles of composition. We motivate and present
the calculus, and outline how it is used to specify the semantics of Piccola, a small
composition language. We demonstrate how the calculus can be used to simplify
compositions by partial evaluation, and we briefly outline some other applications
of the calculus to reasoning about compositional styles.
Keywords: Software components, process calculi, software architecture
Preprint submitted to Elsevier Science. Final version published as:
Franz Achermann and Oscar Nierstrasz, “A Calculus for Reasoning about Software
Components,” Theoretical Computer Science, vol. 331, no. 2-3, 2005, pp. 367-396.
</bodyText>
<sectionHeader confidence="0.977524" genericHeader="keywords">
1 Introduction
</sectionHeader>
<bodyText confidence="0.991025027027027">
Component-Based Software Development (CBSD) offers us the promise of flex-
ible applications being constructed from stable, robust software components.
But how are components plugged into an application? How do we specify the
way in which components are configured and composed?
Preprint submitted to Elsevier Science 31 March 2005
In addition to components, we clearly need some means to specify composi-
tions of components. A composition language [39] is a language for specifying
operators for connecting components (i.e., “connectors”), glue abstractions
for adapting component interfaces, and scripts that instantiate and connect
components. Piccola [4,6] is a prototype for such a composition language, and
JPiccola is an implementation which targets the composition of Java software
components [38].
A key challenge for a composition language is to offer a means to answer the
question, What, precisely, do we mean by composition? There are many dif-
ferent notions of component composition and interconnection in practice, so a
composition language must offer a neutral foundation in which different forms
of composition can be expressed. We therefore need a semantic foundation for
specifying compositional abstractions. Components may be configured and
adapted in many different ways, which may or may not have an impact on the
resulting composition. We therefore also need to reason about equivalence of
different expressions of composition.
Drawing from our experience modeling various component models, we have
developed the Piccola calculus as a tool for expressing the semantics of soft-
ware composition and for reasoning about equivalence of compositions. The
Piccola calculus extends the asychronous π-calculus [32,45] with forms—first-
class, extensible namespaces [5]. Forms are not only convenient for expressing
components, but play other important roles as well.
This calculus serves both as the semantic target and as an executable abstract
machine for Piccola. In this paper we first motivate the calculus by establishing
a set of requirements for modeling composition of software components in
section 2. Next, we address these requirements by presenting the syntax and
semantics of the Piccola calculus in section 3. In section 4 we provide a brief
overview of the Piccola language, and summarize how the calculus helps us
to define its semantics. In section 5, we show how the calculus helps us to
reason about Piccola compositions and optimize the language bridge by partial
evaluation while preserving its semantics. Finally, we conclude with a few
remarks about related and ongoing work in sections 6 and 7.
</bodyText>
<sectionHeader confidence="0.989525" genericHeader="introduction">
2 Modeling Software Composition
</sectionHeader>
<bodyText confidence="0.999615">
We take as our starting point the view that
</bodyText>
<subsubsectionHeader confidence="0.670354">
Applications = Components + Scripts
</subsubsectionHeader>
<page confidence="0.847207">
2
</page>
<listItem confidence="0.962934384615385">
Piccola
• extensible, immutable records
• first-class, monadic services
• language bridging
• introspection
• explicit namespaces
• services as operators
• dynamic scoping on demand
• agents &amp; channels
Styles
• primitive neutral object model
• meta-objects
• HO plugs &amp; connectors
• default arguments
• encapsulation
• component algebras
Glue
• generic wrappers
• component packaging
• generic adaptors
Coordination
• coordination abstractions
Scripts
• sandboxes
• composition expressions
• context-dependent policies
</listItem>
<figureCaption confidence="0.610608">
Fig. 1. How Piccola supports composition
</figureCaption>
<bodyText confidence="0.971918363636364">
that is, component-based applications are (ideally) made up of stable, off-the-
shelf components, and scripts that plug them together [6]. Scripts (ideally)
make use of high-level connectors that coordinate the services of various com-
ponents [3,36,52]. Furthermore, complex applications may need services of
components that depend on very different architectural assumptions [18]. In
these cases, glue code is needed to adapt components to different architectural
styles [50,51].
A foundation for modeling software components must therefore be suitable
for expressing compositional styles, scripts, coordination abstractions and glue
code. Figure 1 summarizes the requirements, and illustrates how Piccola and
the Piccola calculus support them.
</bodyText>
<subsectionHeader confidence="0.97633">
2.1 Compositional Styles
</subsectionHeader>
<bodyText confidence="0.98425875">
A compositional style allows us to express the structure of a software applica-
tion in terms of components, connectors and rules governing their composition
(cf. “architectural style” [52]). The following list summarizes the requirements
we identified for a composition language to support the expression of different
</bodyText>
<listItem confidence="0.6422085">
compositional styles:
• Neutral object model: There exists a wide variety of different object and com-
</listItem>
<bodyText confidence="0.93299">
ponent models. Components may also be bigger or smaller than objects.
As a consequence, a general foundation for modeling components should
make as few assumptions about objects, classes and inheritance as possi-
</bodyText>
<page confidence="0.981908">
3
</page>
<bodyText confidence="0.992122">
ble, namely, objects provide services, they may be instantiated, and their
internal structure is hidden.
</bodyText>
<listItem confidence="0.987334615384615">
• Meta-objects: On the other hand, many component models depend on run-
time reflection, so it must be possible to express dynamic generation of
meta-objects.
• Higher-order plugs and connectors: In general, connectors can be seen as
higher-order operators over components and other connectors.
• Default arguments: Flexibility in plugging together components is achieved
if interface dependencies are minimized. Keyword-based rather than posi-
tional arguments to services enable both flexibility and extensibility.
• Encapsulation: Components are black-box entities that provide services,
without exposing their structure. Sets of components and connectors should
be packaged together, while encapsulating the implementation details of the
connection mechanisms.
• Component algebras: Compositional styles are most expressive when com-
</listItem>
<bodyText confidence="0.956303933333333">
positions of components and connectors again yield components (or connec-
tors). (The composition of two filters is again a filter.)
Based on these requirements, we conclude that we need (at least) records
(to model components and their interfaces), higher-order functions, reflection,
and (at some level) overloading of operators. Services may be monadic, taking
records as arguments, rather than polyadic. To invoke a service, we just apply
it to a record which bundles together all the required arguments, and possibly
some optional ones.
These same records can serve as first-class namespaces which encapsulate the
plugs and connectors of a given style. (A namespace is simply a scope within
which certain definitions are visible.) For this reason we unify records and
namespaces, and call them “forms”, to emphasize their special role.
A “form” is essentially a nested record, which binds labels to values. Let us
consider the following script written in JPiccola, an implementation of Piccola
for Java components [38]:
</bodyText>
<equation confidence="0.857026571428571">
makeFrame
title = &amp;quot;AWT Demo&amp;quot;
x = 200
y = 100
hello = &amp;quot;hello world&amp;quot;
sayHello: println hello
component = Button.new(text=hello) ? ActionPerformed sayHello
</equation>
<bodyText confidence="0.997436">
This script invokes an abstraction makeFrame, passing it a form containing
bindings for the labels title, x, and so on. The script makes use of a com-
positional style in which GUI components (i.e., the Button) can be bound to
events (i.e., ActionPerformed) and actions (i.e., sayHello) by means of the
</bodyText>
<page confidence="0.986472">
4
</page>
<figureCaption confidence="0.973374">
Fig. 2. Evaluating the helloButton script
</figureCaption>
<bodyText confidence="0.88246">
? connector.
When we evaluate this code, it generates the button we see in Figure 2. When
we click on the button, hello world is printed on the Java console.
</bodyText>
<subsectionHeader confidence="0.975399">
2.2 Glue
</subsectionHeader>
<bodyText confidence="0.8714305">
Glue code is needed to package, wrap or adapt code to fit into a compositional
style.
</bodyText>
<listItem confidence="0.816296777777778">
• Generic wrappers: Wrappers are often needed to introduce specific policies
(such as thread-safe synchronization). Generic wrappers are hard to specify
for general, polyadic services, but are relatively straightforward if all services
are monadic.
• Component packaging: Glue code is sometimes needed to package existing
code to conform to a particular component model or style. For this purpose,
a language bridge is needed to map existing language constructs to the
formal component model.
• Generic adaptors: Adaptation of interfaces can also be specified generically
</listItem>
<bodyText confidence="0.988359875">
with the help of reflective or introspective features, which allow components
to be inspected before they are adapted.
The JPiccola helloButton script only works because Java GUI components
are wrapped to fit into our compositional style.
In addition to records and higher-order functions over records, we see that
some form of language bridging will be needed, perhaps not at the level of the
formal model, but certainly for a practical language or system based on the
model.
</bodyText>
<subsectionHeader confidence="0.996464">
2.3 Scripts
</subsectionHeader>
<bodyText confidence="0.993293">
Scripts configure and compose components using the connectors defined for a
style.
</bodyText>
<page confidence="0.985707">
5
</page>
<listItem confidence="0.961796444444444">
• Sandboxes: For various reasons we may wish to instantiate components only
in a controlled environment. We do not necessarily trust third-party com-
ponents. Sometimes we would like to adapt components only within a local
context. For these and other reasons it is convenient to be able to instantiate
and compose namespaces which serve as sandboxes for executing scripts.
• Composition expressions: Scripts instantiate and connect components. A
practical language might conveniently represent connectors as operators.
Pipes and filters are well-known, but this idea extends well to other domains.
• Context-dependent policies: Very often, components must be prepared to de-
</listItem>
<bodyText confidence="0.9773666">
ploy services of the dynamic context. Transaction services, synchronization
or communication primitives may depend on the context. For this reason,
pure static scoping may not be enough, and dynamic scoping on demand
will be needed for certain kinds of component models.
So, we see that explicit, manipulable namespaces become more important.
</bodyText>
<subsectionHeader confidence="0.991935">
2.4 Coordination
</subsectionHeader>
<bodyText confidence="0.929932666666667">
CBSD is especially relevant in concurrent and distributed contexts. For this
reason, a foundation for composition must be able to express coordination of
interdependent tasks.
</bodyText>
<listItem confidence="0.877453">
• Coordination abstractions: Both connectors and glue code may need to ex-
</listItem>
<bodyText confidence="0.9926808">
press coordination of concurrent activities. Consider a readers/writers syn-
chronization policy as a generic wrapper.
We conclude that we not only need higher-order functions over first-class
namespaces (with introspection), but also a way of expressing concurrency
and communication [50].
</bodyText>
<sectionHeader confidence="0.991184" genericHeader="method">
3 The Piccola calculus
</sectionHeader>
<bodyText confidence="0.999306777777778">
As a consequence of the requirements we have identified above, we propose
as a foundation a process calculus based on the higher-order asynchronous
π-calculus [32,45] in which tuple-based communication is replaced by commu-
nication of extensible records, or forms [5,37]. Furthermore, forms serve as
first-class namespaces and support a simple kind of introspection.
The design of the Piccola calculus strikes a balance between minimalism and
expressiveness. As a calculus it is rather large. In fact, it would be possible to
express everything we want with the π-calculus alone, but the semantic gap
between concepts we wish to model and the terms of the calculus would be
</bodyText>
<page confidence="0.990643">
6
</page>
<bodyText confidence="0.670132">
Table 1
Syntax of the Piccola calculus
</bodyText>
<equation confidence="0.984853">
A,B,C ::=  empty form  |R current root
 |A;B sandbox  |x variable
 |x7→ bind  |hidex hide
 |L inspect  |A ·B extension
 |λx.A abstraction  |AB application
 |νc.A restriction  |A  |B parallel
 |c? input  |c output
F,G,H ::=  empty form  |S service
 |x7→F binding  |F ·G extension
S ::= F ;λx.A closure  |L inspect
 |x7→ bind  |hidex hide
 |c output
</equation>
<bodyText confidence="0.9994845">
rather large. With the Piccola calculus we are aiming for the smallest calculus
with which we can conveniently express components, connectors and scripts.
</bodyText>
<subsectionHeader confidence="0.99817">
3.1 Syntax
</subsectionHeader>
<bodyText confidence="0.999336666666667">
The Piccola calculus is given by agents A,B,C that range over the set of agents
A in Table 1. There are two categories of identifiers: labels and channels. The
set of labels L is ranged over by x, y, z. (Labels also play the role of variables
in the calculus, so we use these two terms interchangeably.) Specific labels are
also written in the italic text font. Channels are denoted by a, b, c, d ∈ N .
Labels are bound with bindings and λ-abstractions, and channels are bound
by ν-restrictions.
The operators have the following precedence:
application &amp;gt; extension &amp;gt; restriction, abstraction &amp;gt; sandbox &amp;gt; parallel
Agent expressions normally reduce to static form values or simply forms.
Forms are ranged over by F,G,H. Notice that the set of forms is a subset of
all agents. Forms are the first-class citizens of the Piccola calculus, i.e., they
</bodyText>
<page confidence="0.997075">
7
</page>
<bodyText confidence="0.991346888888889">
are the values that get communicated between agents and are used to invoke
services.
The set of forms is denoted by F . Forms contain bindings and services. Services
are essentially functional abstractions that may be invoked with arguments,
and may possibly entail side-effects. We use S to range over services. User-
defined services are closures. Primitive services are inspect, the bind and hide
primitives, and the output service.
Before considering the formal reduction relation, we first give an informal
description of the different agent expressions and how they reduce.
</bodyText>
<listItem confidence="0.937734137931034">
• The empty form, , does not reduce further. It denotes a form without any
binding.
• The current root agent, R, denotes the current lexical scope.
• A sandbox A;B evaluates the agent B in the root context given by A. A
binds all free labels in B. If B is a label x, we say that A;x is a projection
on x in A.
• A label, x, denotes the value bound by x in the current root context.
• The primitive service bind creates bindings. If A reduces to F , then x 7→A
reduces to the binding x 7→F .
• The primitive service hidex removes bindings. So, hidex(x 7→ · y 7→) reduces
to y 7→.
• The inspect service, L, can be used to iterate over the bindings and services
of an arbitrary form F . The result of LF is a service that takes as its
argument a form that binds the labels isEmpty , isLabel and isService to
services. Depending on whether F is the empty form, contains bindings, or
is only a service, the appropriate one of these three services will be invoked.
• The values of two agents are concatenated by extension. In the value of A·B
the bindings of B override those for the same label in A.
• An abstraction λx.A abstracts x in A.
• The application AB denotes the result of applying A to B. The Piccola
calculus uses a call-by-value reduction order. In order to reduce AB, A
must reduce to a service and B to a form.
• The expression νc.A restricts the visibility of the channel name c to the
agent expression A, as in the π-calculus.
• A  |B spawns off the agent A asynchronously and yields the value of B.
Unlike in the π-calculus, the parallel composition operator is not commu-
tative, since we do not wish parallel agents to reduce to non-deterministic
values.
• The agent c? inputs a form from channel c and reduces to that value. The
</listItem>
<bodyText confidence="0.93166625">
reader familiar with the π-calculus will notice a difference with the input
prefix. Since we have explicit substitution in our calculus it is simpler to
specify the input by c? and use the context to bind the received value
instead of defining a prefix syntax c(X).A as in the π-calculus.
</bodyText>
<page confidence="0.957888">
8
</page>
<figure confidence="0.387025">
Table 2
Free channels
</figure>
<equation confidence="0.999661285714286">
fc() = ∅ fc(R) = ∅
fc(x) = ∅ fc(L) = ∅
fc(x7→) = ∅ fc(hidex) = ∅
fc(A;B) = fc(A) ∪ fc(B) fc(A ·B) = fc(A) ∪ fc(B)
fc(λx.A) = fc(A) fc(AB) = fc(A) ∪ fc(B)
fc(νc.A) = fc(A)\{c} fc(A  |B) = fc(A) ∪ fc(B)
fc(c?) = {c} fc(c) = {c}
</equation>
<listItem confidence="0.980909">
• The channel c is a primitive output service. If A reduces to F , then cA
</listItem>
<bodyText confidence="0.426976">
reduces to the message cF . The value of a message is the empty form .
(The value F is only obtained by a corresponding input c? in another agent.)
</bodyText>
<subsectionHeader confidence="0.855378">
3.2 Free Channels and Closed Agents
</subsectionHeader>
<bodyText confidence="0.9893705">
As in the π-calculus, forms may contain free channel names. An agent may
create a new channel, and communicate this new name to another agent in a
separate lexical scope.
The free channels fc(A) of an agent A are defined inductively in Table 2.
α-conversion (of channels) is defined in the usual way. We identify agent ex-
pressions up to α-conversion.
We omit a definition of free variables. Since the Piccola calculus is a calculus
with explicit environments, we cannot easily define α-conversion on variables.
Such a definition would have to include the special nature of R. Instead, we
define a closed agent where all variables, root expressions, and abstractions
occur beneath a sandbox:
Definition 1 The following agents A are closed:
</bodyText>
<listItem confidence="0.999957">
• , x 7→, hidex,L, c and c? are closed.
• If A and B are closed then also A ·B,AB,A  |B and νc.A are closed.
• If A is closed, then also A;B is also closed for any agent B.
</listItem>
<bodyText confidence="0.9928056">
Observe that any form F is closed by the above definition. An agent is open
if it is not closed. Open agents are R, variables x, abstractions λx.A and
compositions thereof. Any agent can be closed by putting it into a sandbox
with a closed context. Sandbox agents are closed if the root context is closed. In
lemma 1 we show that the property of being closed is preserved by reduction.
</bodyText>
<page confidence="0.876244">
9
</page>
<figure confidence="0.355256">
Table 3
Congruences I
≡ is the smallest congruence satisfying the axioms in tables 3, 4 and 5:
</figure>
<equation confidence="0.812579105263158">
F ·  ≡ F (ext empty right)
 · F ≡ F (ext empty left)
(F ·G) ·H ≡ F · (G ·H) (ext assoc)
S · (x7→F ) ≡ (x7→F ) · S (ext service commute)
x 6= y implies x7→F · y 7→G ≡ y 7→G · x7→F (ext bind commute)
x7→F · x7→G ≡ x7→G (single binding)
S · S′ ≡ S′ (single service)
Table 4
Congruences II
F ;A ·B ≡ (F ;A) · (F ;B) (sandbox ext)
F ;AB ≡ (F ;A)(F ;B) (sandbox app)
A; (B;C) ≡ (A;B);C (sandbox assoc)
F ;G ≡ G (sandbox value)
F ;R ≡ F (sandbox root)
hidex(F · x7→G) ≡ hidexF (hide select)
x 6= y implies hidey(F · x7→G) ≡ hideyF · x7→G (hide over)
hidex ≡  (hide empty)
hidexS ≡ S (hide service)
(F · S)G ≡ SG (use service)
</equation>
<subsectionHeader confidence="0.998529">
3.3 Congruence and Pre-forms
</subsectionHeader>
<bodyText confidence="0.990424333333333">
As in the π-calculus, we introduce structural congruence over agent expres-
sions to simplify the reduction relation. The congruence allows us to rewrite
agent expressions to bring communicating agents into juxtapositions, as in the
Chemical Abstract Machine of Berry and Boudol [9].
The congruence rules constitute three groups. The first group (Table 3) spec-
ifies that extension is idempotent and associative on forms.
The rules single service and single binding specify that extension overwrites
services and bindings with the same label.
We define labels(F ) as follows:
</bodyText>
<page confidence="0.870357">
10
</page>
<tableCaption confidence="0.430251">
Table 5
</tableCaption>
<sectionHeader confidence="0.23389" genericHeader="method">
Congruences III
</sectionHeader>
<equation confidence="0.655697636363636">
(A  |B)  |C ≡ A  |(B  |C) (par assoc)
(A  |B)  |C ≡ (B  |A)  |C (par left commute)
(A  |B) · C ≡ A  |B · C (par ext left)
F · (A  |B) ≡ A  |F ·B (par ext right)
(A  |B)C ≡ A  |BC (par app left)
F (A  |B) ≡ A  |FB (par app right)
(A  |B);C ≡ A  |B;C (par sandbox left)
F ; (A  |B) ≡ F ;A  |F ;B (par sandbox right)
F  |A ≡ A (discard zombie)
cF ≡ cF  | (emit)
νcd.A ≡ νdc.A (commute channels)
c /∈ fc(A) implies A  |νc.B ≡ νc.(A  |B) (scope par left)
c /∈ fc(A) implies (νc.B)  |A ≡ νc.(B  |A) (scope par right)
c /∈ fc(A) implies (νc.B) ·A ≡ νc.(B ·A) (scope ext left)
c /∈ fc(A) implies A · νc.B ≡ νc.(A ·B) (scope ext right)
c /∈ fc(A) implies A; νc.B ≡ νc.(A;B) (scope sandbox left)
c /∈ fc(A) implies (νc.B);A ≡ νc.(B;A) (scope sandbox right)
c /∈ fc(A) implies (νc.B)A ≡ νc.BA (scope app left)
c /∈ fc(A) implies A(νc.B) ≡ νc.AB (scope app right)
Definition 2 For each form F , the set of labels(F ) ⊂ L is given by:
labels() = ∅ labels(S) = ∅
labels(x 7→G) = {x} labels(F ·G) = labels(F ) ∪ labels(G)
</equation>
<bodyText confidence="0.454465">
Using the form congruences, we can rewrite any form F into one of the fol-
lowing three cases:
</bodyText>
<equation confidence="0.731679">
F ≡ 
F ≡ S
F ≡ F ′ · x 7→G where x 6∈ labels(F ′)
</equation>
<bodyText confidence="0.992371">
This is proved by structural induction over forms [2]. This formalizes our idea
that forms are extensible records unified with services. A form has at most
one binding for a given label.
The second group (Table 4) defines preforms. These are agent expressions that
are congruent to a form. For instance, the agent hidex is equivalent to the
empty form . The set of all preforms is defined by:
</bodyText>
<equation confidence="0.983741">
F≡ = {A|∃F ∈ F with F ≡ A}
</equation>
<page confidence="0.993975">
11
</page>
<bodyText confidence="0.9997055">
Clearly, all forms are preforms.
The last group (Table 5) defines the semantics of parallel composition and
communication for agents. Note how these rules always preserve the position
of the rightmost agent in a parallel composition, since this agent, when re-
duced to a form, will represent the value of the composition. In particular,
the rule discard zombie garbage-collects form values appearing to the left of
this position. The rule emit, on the other hand, spawns an empty form as the
value, thus enabling the message to move around freely. For instance in
</bodyText>
<equation confidence="0.998788">
x 7→c() ≡ x 7→(c()  |) by emit
≡ c()  |x 7→ by par ext right
</equation>
<bodyText confidence="0.964758">
the message c() escapes the binding x 7→.
</bodyText>
<subsectionHeader confidence="0.927764">
3.4 Reduction
</subsectionHeader>
<bodyText confidence="0.971136666666667">
We define the reduction relation → on agent expressions to reduce applica-
tions, communications and projections (see Table 6). ⇒ is the reflexive and
transitive closure of →.
Especially noteworthy is the rule reduce beta. This rule does not substitute
G for x in the agent A as in the classical λ-calculus. Instead, it extends the
environment in which A is evaluated. This is essentially the beta-reduction
rule found in calculi for explicit substitution [1,40]:
(F ;λx.A)G → F · x 7→G;A
The application of the closure F ;λx.A to the argument G reduces to a sandbox
expression in which the agent A is evaluated in the environment F ·x 7→G. Free
occurrences of x in A will therefore be bound to G.
The property of being closed is respected by reduction:
Lemma 1 If A is a closed agent and A → B or A ≡ B then B is closed as
well.
PROOF. Easily checked by induction over the formal proof for A→ B.
</bodyText>
<page confidence="0.909705">
12
</page>
<equation confidence="0.833885785714286">
Table 6
Reduction rules
(F ;λx.A) G→ F · x7→G;A (reduce beta)
cF  |c?→ F (reduce comm)
F · x7→G;x→ G (reduce project)
L→ ;λx.(x; isEmpty) (reduce inspect empty)
LS → ;λx.(x; isService) (reduce inspect service)
L(F · x7→G)→ ;λx.(x; isLabel)labelx (reduce inspect label)
A ≡ A′ A′ → B′ B′ ≡ B
A→ B
(reduce struct)
A→ B
E [A]→ E [B]
(reduce propagate)
</equation>
<bodyText confidence="0.988092">
where labelx = project 7→(;λx.(x;x))·hide 7→hidex ·bind 7→(x7→) and E is an evaluation
context defined by the grammar:
</bodyText>
<equation confidence="0.9541245">
E ::= [ ]
∣∣ E ·A ∣∣ F · E ∣∣ E ;A ∣∣ F ; E ∣∣ EA ∣∣ FE ∣∣ A|E ∣∣ E|A ∣∣ νc.E
</equation>
<subsectionHeader confidence="0.653981">
3.5 Encoding Booleans
</subsectionHeader>
<bodyText confidence="0.999661">
The following toy example actually illustrates many of the principles at stake
when we model components with the Piccola calculus.
We can encode booleans by services that either project on the labels true or
false depending on which boolean value they are supposed to model (cf. [15]).
(This same idea is used by the primitive service L to reflect over the bindings
and services of a form.)
</bodyText>
<equation confidence="0.596616833333333">
True
def
= ;λx.(x; true)
False
def
= ;λx.(x; false)
</equation>
<page confidence="0.859993">
13
</page>
<table confidence="0.447770142857143">
Consider now:
True(true 7→1 · false 7→2) = (;λx.(x; true))(true 7→1 · false 7→2)
→  · x 7→(true 7→1 · false 7→2); (x; true) by reduce beta
≡ ( · x 7→(true 7→1 · false 7→2); x); true
by sandbox assoc
→ (true 7→1 · false 7→2); true by reduce project
≡ (false 7→2 · true 7→1); true by ext bind commute
</table>
<bodyText confidence="0.931081714285714">
→ 1 by reduce project
Note how the bindings are swapped to project on true in the last step. A
similar reduction would show False(true 7→1 · false 7→2)⇒ 2.
A key point is that a form may provide additional bindings that a client may
ignore if it does not require them (cf. [15]). This same principle is applied to
good effect in various scripting languages, such as Python [29]. For instance
we can use True and provide an additional binding notused 7→F for arbitrary
</bodyText>
<table confidence="0.9251986">
form F :
True(true 7→1 · false 7→2 · notused 7→F )
⇒ (true 7→1 · false 7→2 · notused 7→F ); true
≡ (false 7→2 · true 7→1 · notused 7→F ); true by ext bind commute
≡ (false 7→2 · notused 7→F · true 7→1); true by ext bind commute
</table>
<bodyText confidence="0.731705333333334">
→ 1 by reduce project
Extending forms can also be used to overwrite existing bindings. For instance
instead of binding the variable notused a client may override true:
True(true 7→1 · false 7→2 · true 7→3)⇒ 3
A conditional expression is encoded as a curried service that takes a boolean
and a case form. When invoked, it selects and evaluates the appropriate service
in the case form:
if
def
= ;λuv.u(true 7→(v; then) · false 7→(v; else))
Now consider:
if True (then 7→(F ;λx.A) · else 7→(G;λx.B))
</bodyText>
<equation confidence="0.642613">
⇒ F · x 7→;A
</equation>
<page confidence="0.99251">
14
</page>
<bodyText confidence="0.984723714285714">
The expression if True has triggered the evaluation of agent A in the envi-
ronment F · x 7→.
The contract supported by if requires that the cases provided bind the labels
then and else. We can relax this contract and provide default services if those
bindings are not provided by the client. To do so, we replace in the definition
of if the sandbox expression v; else with a default service. This service gets
triggered when the case form does not contain an else binding:
</bodyText>
<equation confidence="0.693304">
ifd
def
= ;λuv.u(true 7→(v; then) · false 7→(else 7→(λx.) · v; else))
Now ifd False (then 7→(F ;λx.A))⇒ .
</equation>
<subsectionHeader confidence="0.862037">
3.6 Equivalence for Agents
</subsectionHeader>
<bodyText confidence="0.959687">
Two agents are equivalent if they exhibit the same behaviour, i.e., they en-
joy the same reductions. We adopt Milner and Sangiorgi’s notion of barbed
bisimulation [33]. The idea is that an agent A is barbed similar to B if A
can exhibit any reduction that B does and if B is a barb, then A is a barb,
too. If A and B are similar to each other they are bisimilar. The advantage of
this bisimulation is that it can readily be given for any calculus that contains
barbs or values.
For the asynchronous π-calculus, barbs are usually defined as having the ca-
pability of doing an output on a channel. A Piccola calculus agent reduces to
a barb, i.e., it returns a form. During evaluation the agent may spawn off new
subthreads which could be blocked or still be running. We consequently define
barbs as follows:
</bodyText>
<table confidence="0.864510666666667">
Definition 3 A barb V is an agent expression A that is congruent to an
agent generated by the following grammar:
V ::= F
∣∣∣ A|V ∣∣∣ νc.V
We write A↓ for the fact that A is a barb, and A⇓ when a barb V exists such
that A⇒ V .
The following lemma relates forms, barbs and agents:
Lemma 2 The following inclusion holds and is strict:
F ⊂ F≡ ⊂ {A|A↓} ⊂ A
</table>
<page confidence="0.98172">
15
</page>
<bodyText confidence="0.9429775">
PROOF. The inclusions hold by definition. To see that the inclusion are
strict, consider the empty form , the agent hidex, the barb 0  |hidex and
the agent 0 (where 0 = νc.c? is the deadlocked null agent).
The following lemma gives a syntactical characterization of barbs.
Lemma 3 For any form F , agent A, and label x, the following terms are
barbs, given V1 and V2 are barbs.
</bodyText>
<table confidence="0.8106945">
V1 · V2 νc.V1
V1;V2 A  |V1
x 7→V1
PROOF. By definition we have V ≡ νc̃.A  |F . The claim follows by induction
over F .
We now define barbed bisimulation and the induced congruence:
Definition 4 A relation R is a (weak) barbed bisimulation, if A R B, i.e.,
(A,B) ∈ R implies:
</table>
<listItem confidence="0.980686142857143">
• If A→ A′ then there exists an agent B′ with B ⇒ B′ and A′ R B′.
• If B → B′ then there exists an agent A′ with A⇒ A′ and A′ R B′.
• If A↓ then B⇓.
• If B ↓ then A⇓.
Two agents are (weakly) barbed bisimilar, written A ≈̇ B, if there is some
(weak) barbed bisimulation R with A R B. Two agents are (weakly) barbed
congruent, written A ≈ B, if for all contexts C we have C[A] ≈̇ C[B].
</listItem>
<bodyText confidence="0.998361">
We define behavioural equality using the notion of barbed congruence. As
usual we can define strong and weak versions of barbed bisimulation. The
strong versions are obtained in the standard way by replacing ⇒ with →
and ⇓ with ↓ in Definition 4. We only concentrate on the weak case since it
abstracts internal computation.
</bodyText>
<subsectionHeader confidence="0.978474">
3.7 Erroneous Reductions
</subsectionHeader>
<bodyText confidence="0.995254333333333">
Not all agents reduce to forms. Some agents enjoy an infinite reduction [2].
Other agents may be stuck. An agent is stuck if it is not a barb and can reduce
no further.
</bodyText>
<page confidence="0.991522">
16
</page>
<bodyText confidence="0.9869828">
Definition 5 An agent A is stuck, written A↑, if A is not a barb and there
is no agent B such that A→ B.
Clearly it holds that 0↑ and R↑. The property of being stuck is not compo-
sitional. For instance c?↑ but obviously, c()  |c? can reduce to . We can put
R into a context so that it becomes a barb, for instance F ;R ≡ F . Note that
if an agent is stuck it is not a preform: F≡ ∩ {A|A↑} = ∅ by definition.
Although 0 is arguably stuck by intention, in general a stuck agent can be
interpreted as an error. The two typical cases which may lead to errors are (i)
projection on an unbound label, e.g., ;x, and (ii) application of a non-service,
e.g., .
</bodyText>
<subsectionHeader confidence="0.976495">
3.8 π-Calculus Encoding
</subsectionHeader>
<bodyText confidence="0.983738666666667">
One may well ask what exactly the Piccola calculus adds over and above the
asynchronous π-calculus. We have previously shown that the Piccola calculus
can be faithfully embedded into the localized π-calculus Lπ of Merro and
Sangiorgi [30,45].
The mapping [[]]a encodes Piccola calculus agents as π-calculus processes. The
process [[A]]a evaluates A in the environment given by the empty form, and
sends the resulting value along the channel a. A form (value) is encoded as a 4-
tuple of channels representing projection, invocation, hiding and selection. The
main result is that the encoding is sound and preserves reductions. We do not
require a fully abstract encoding since that would mean that equivalent Piccola
calculus agents translated into the π-calculus could not be distinguished by any
π-processes. Our milder requirement means that we consider only π-processes
which are translations of Piccola calculus agents themselves and state that
they cannot distinguish similar agents:
Proposition 1 (Soundness) For closed agents A, B and channel a the con-
gruence [[A]]a ≈ [[B]]a implies A ≈ B.
Although it is comforting to learn that the π-calculus can serve as a foundation
for modeling components, it is also clear from the complexity of the encoding
that it is very distant from the kinds of abstractions we need to conveniently
model software composition. For this reason we find that a richer calculus is
more convenient to express components and connectors.
</bodyText>
<page confidence="0.995117">
17
</page>
<table confidence="0.979748571428572">
Applications: Components + Scripts
Composition styles: Streams, GUI composition, ...
Standard libraries: Coordination abstractions, control structures,
basic object model ...
Piccola language: Host components, user-defined operators, dynamic
namespaces
Piccola calculus: Forms, agents and channels
</table>
<figureCaption confidence="0.838116">
Fig. 3. Piccola layers
</figureCaption>
<sectionHeader confidence="0.891732" genericHeader="method">
4 From the Piccola calculus to Piccola
</sectionHeader>
<bodyText confidence="0.99709824">
Piccola is a small composition language that supports the requirements sum-
marized in Figure 1, and whose denotational semantics is defined in terms of
the Piccola calculus [2].
Piccola is designed in layered fashion (see Figure 3). At the lowest level we
have an abstract machine that implements the Piccola calculus.
At the second level, we have the Piccola language, which is implemented by
translation to the abstract machine, following the specification of the denota-
tional semantics.
Piccola provides a more convenient, Python-like syntax for programming than
does the calculus, including overloaded operators to support component com-
position. It also provides a bridge to the host language (currently Java or
Squeak). Piccola provides no basic data types other than forms and channels.
Booleans, integers, floating point numbers and strings, for example, must be
provided by the host language through the language bridge.
Curiously, the syntax of the Piccola calculus is actually larger than that of
Piccola itself. This is because we need to represent all semantic entities, includ-
ing agents and channels, as syntactic constructs in the calculus. In the Piccola
language, however, these are represented only by standard library services,
such as run and newChannel.
The third level provides a set of standard libraries to simplify the task of
programming with Piccola. Not only does the Piccola language provide no
built-in data types, it does not even offer any control structures of its own.
These, however, are provided as standard services implemented in Piccola.
Exceptions and try-catch clauses are implemented using agents, channels, and
dynamic namespaces [5].
</bodyText>
<page confidence="0.993118">
18
</page>
<bodyText confidence="0.946861363636364">
The first three layers constitute the standard Piccola distribution. The fourth
layer is provided by the component framework designer. At this level, a domain
expert encodes a compositional styles as a library of components, connectors,
adaptors, coordination abstractions, and so on. Finally, at the top level, an ap-
plication programmer may script together components using the abstractions
provided by the lower layers [3,36].
Piccola has been used to experiment with the implementation of various com-
positional styles, including styles for GUI composition [6], styles for actor
coordination [25], and styles for wrapping white-box frameworks as black-box
components [49]. Tutorial examples are described in the JPiccola user’s guide
[38]
</bodyText>
<sectionHeader confidence="0.598178" genericHeader="method">
5 Partial Evaluation
</sectionHeader>
<bodyText confidence="0.98384792">
Since Piccola is a pure composition language, evaluating scripts requires inten-
sive upping and downing [31] between the “down” level of the host language
and the “up” level of Piccola. If the language bridge were implemented näıvely,
it would be hopelessly inefficient.
Partial evaluation [8,24,13] is a program transformation technique which, given
a program and parts of its arguments, produces a specialized program with
respect to those arguments. In this section we present a partial evaluation
algorithm for Piccola [2,47,48]. This algorithm uses the fact that forms are
immutable. We replace references to forms by the forms referred to. We can
then specialize projections and replace applications of referentially transparent
services by their results. However, most services in Piccola are not referentially
transparent and cannot be inlined since that would change the order in which
side-effects are executed. We need to separate the referentially transparent
part from the non-transparent part in order to replace an application with its
result and to ensure that the order in which the side-effects are evaluated is
preserved.
The algorithm separates functional Piccola agents into side-effect terms and
lazy forms expressions. The former contain applications that may cause side-
effects and projections that may be undefined. For side-effect terms the order of
evaluation is important. In contrast, lazy forms are referentially transparent.
As subexpressions they contain deferred projections, bindings, and hidden
forms. Dropping unnecessary subexpressions does not change the semantics
of the lazy form. We call these expressions lazy since the bindings can be
evaluated on demand.
In section 5.1 we give an overview of the algorithm. We formally define it
</bodyText>
<page confidence="0.995834">
19
</page>
<bodyText confidence="0.9772825">
and illustrate its use with examples in section 5.2. In section 5.3 we prove
correctness and termination of the algorithm.
</bodyText>
<subsectionHeader confidence="0.933183">
5.1 Overview
</subsectionHeader>
<bodyText confidence="0.997376714285714">
Before presenting the algorithm in detail, we give an informal account of the
main idea. We separate each service s into two services sp and sr. The first
service, sp, is the side-effect part of the service. When we apply sp to a form
F , the side-effects of sF are evaluated. We refer to the result of spF as the
side-effect. The service sr is referentially transparent. It takes the side-effect
and the argument F and returns the value of sF . Thus the service s is split
into sp and sr such that the following holds:
</bodyText>
<equation confidence="0.84574">
sF = sr(spF )F
</equation>
<bodyText confidence="0.9787925">
As an example, consider the service wrapRec which wraps a value received
from the channel ch:
</bodyText>
<equation confidence="0.81421375">
wrapRec ch:
received = ch.receive() # side-effect
value = wrap received # wrap is referentially transparent
channel = ch # return ch as part of the result
</equation>
<bodyText confidence="0.9982896">
Here we assume that the (unspecified) wrap service is referentially transparent
— for example, it might simply provide new names for the labels bound in
the received form.
If we separate the side-effect from the referentially transparent part, we obtain
services wrapRecp and wrapRecs as follows:
</bodyText>
<equation confidence="0.9726118">
wrapRecp ch: ch.receive()
wrapRecr side ch:
received = side
value = wrap side
channel = ch
</equation>
<bodyText confidence="0.994338333333333">
We can now defer invocation of the referentially transparent service. Assume
we use the result of an invocation of wrapRec and project on the received
label. In that case, the invocation of wrap is not necessary anymore. The code
</bodyText>
<figure confidence="0.664737">
a = (wrapRec ch).received
is equivalent to “a = wrapRecr (wrapRecp ch) ch” which has the same effect
as
20
Table 7
Functional Piccola agents
A,B,C ::= L inspect  |new new Channel
 |run run  |hidex hide
 | empty form  |R (static) root
 |A;B sandbox  |A ·B extension
 |x variable  |x7→A binding
 |λx.A abstraction  |AB application
new = ;λx.νc.send 7→c · receive 7→(λy.c?) run = ;λx.(x()  |)
Table 8
Side-effect terms and lazy forms
</figure>
<equation confidence="0.931889">
P ::=  empty form  |x7→P nested side-effect
 |P · P extension  |x7→R.x projection
 |x7→RR side-effect application
R ::=  empty form  |x variable
 |R ·R extension  |x7→R binding
 |R.x projection  |λx.P ? R lazy abstraction
 |side(A) side-effect service
a = ch.receive()
</equation>
<bodyText confidence="0.998182142857143">
when we inline the referentially transparent service.
The algorithm not only splits services but also any functional agent : an agent
written using a functional subset of the Piccola calculus [2] (see Table 7). We
also do not represent the lazy part as curried services. Instead the root context
consists of the side-effects bound by unique labels.
For simplicity, we do not consider the hide primitive and treat it as a service
with a side-effect. The present approach can easily be extended to handle hide
more effectively [2].
The partial evaluation algorithm partial : A → A is expressed in two steps.
First an agent A is split into a side-effect term and a lazy form expression.
Then, the side-effect term and the lazy form are combined back into a spe-
cialized agent. The set of side-effect terms is denoted by P and ranged over
by P . The set of lazy forms R ranged over by R. Some helper predicates are
defined over lazy forms and side-effects. In that case we use Q to range over
</bodyText>
<page confidence="0.993375">
21
</page>
<bodyText confidence="0.988055">
P ∪R. The grammar for side-effect terms and lazy forms is given in Table 8.
We adopt the same precedence as for functional agents: projection is stronger
than binding which is stronger than application.
The two functions of the algorithm are split and combine:
</bodyText>
<listItem confidence="0.998913">
• The function split : (A ×R) → (P × R) separates a functional agent into
a side-effect and a lazy form. We split the agent A in the context given by
the lazy form R′ and get a side-effect term P and a lazy form R, written
split(A,R′) = (P,R).
• The function combine(P × R) → A combines the side-effect and the lazy
</listItem>
<bodyText confidence="0.9034155">
form back into a functional agent.
The partial evaluation algorithm partial : A → A is defined as:
</bodyText>
<equation confidence="0.754639">
partial(A) = combine(split(A, ))
</equation>
<bodyText confidence="0.989529625">
Observe that we assume the empty form as initial context for specializing an
agent A.
Lazy form expressions are referentially transparent. They contain unevaluated
projections that are guaranteed to succeed as we will see. Evaluating lazy forms
can be deferred. Lazy forms contain references to side-effects or to formal
parameters. Lazy abstractions λx.P ? R contain their side-effect P and the
referentially transparent result R.
Side-effect services are arbitrary agents A. Partial evaluation does not spe-
cialize them. The primitive services new, run, and L are side-effect services.
Side-effect terms contain applications and projections that may fail. Side-effect
terms have a specific structure. Atomic side-effects are bound by unique la-
bels. Side-effect terms can be nested and sequentially composed. In P1 ·P2 we
may refer to side-effects of P1 from P2.
This algorithm has been used extensively in the implementation of SPiccola
[47,48], an implementation of Piccola for components written in Squeak [23],
an open-source Smalltalk.
</bodyText>
<subsectionHeader confidence="0.996859">
5.2 The Algorithm
</subsectionHeader>
<bodyText confidence="0.9647542">
We now present and discuss the functions split and combine in detail. We as-
sume that · is associative and  is the neutral element. This allows us to reduce
the number of defining equations. For instance, when defining projection in
Table 11 we write project(R ·x 7→R1, x) = R1 assuming that we can rewrite any
form with several bindings into a form extended with a single binding.
</bodyText>
<page confidence="0.991904">
22
</page>
<tableCaption confidence="0.7344445">
Table 9
Free variables and defined labels
</tableCaption>
<equation confidence="0.99996275">
fv() = ∅ fv(x) = {x}
fv(R1R2) = fv(R1) ∪ fv(R2) fv(R.x) = fv(R)
fv(Q1 ·Q2) = fv(Q1) ∪ fv(Q2) fv(x7→Q) = fv(Q)
fv(λx.P ? R) = (fv(P ) ∪ fv(R))\(labels(P ) ∪ {x}) fv(side(A)) = ∅
labels() = ∅ labels(x) = ∅
labels(x7→Q) = {x} labels(R.x) = ∅
labels(Q1 ·Q2) = labels(Q1) ∪ labels(Q2) labels(side(A)) = ∅
labels(R1R2) = ∅ labels(λx.P ? R) = ∅
</equation>
<bodyText confidence="0.996355666666667">
We need some helper predicates for the free and bound variables and we define
substitution.
The set of free variables in a lazy or side-effect term, fv(Q) is defined in
</bodyText>
<tableCaption confidence="0.51594">
Table 9. Note that the definition of free labels of an ordinary Piccola agent
</tableCaption>
<bodyText confidence="0.991206304347826">
is meaningless as the free labels of R are undefined. For lazy forms and side-
effects, a recursive definition can be given since sandbox expression are inlined
and lazy forms do not contain R. The interesting case is the free variables for
abstractions λx.P ?R. They are constructed by taking the free variables of P
and R and removing x and the labels that are defined by P . This definition
reflects the fact that R will be evaluated in a context defined by P as we will
see.
The predicate labels(Q) denotes the set of labels that are bound by Q. The
label of a binding x 7→Q is the set {x}. The set of labels of an extension is the
union of the labels of the subexpressions. We are conservative when the set of
labels cannot be inferred in a straightforward manner. For instance, the set of
labels of any application or projection is empty.
The expression Q[x/R] denotes the expression Q where all free x are replaced
by R. Substitution is defined in Table 10. Note that there is no special defi-
nition for the side-effect y 7→R1R2. This case is defined by the binding and by
the application, thus (y 7→R1R2)[x/R] = y 7→(R1R2)[x/R] = R1[x/R] R2[x/R].
Note that R[x/R]′ ∈ R and P [x/R] ∈ P . This means that a substitution on a
lazy form denotes a lazy form, and a substitution on a side-effect term denotes
a side-effect term. As usual we replace bound variables to avoid name capture
[20].
The helper predicate project : (R × L) → Q denotes the value bound by a
label (Table 11). If the projection can be performed at specialize time, we
do the actual lookup. If the value of the projection is not known, an uneval-
</bodyText>
<page confidence="0.989698">
23
</page>
<tableCaption confidence="0.680276">
Table 10
</tableCaption>
<equation confidence="0.987747181818182">
Substitution
[x/R] = 
(P ·Q)[x/R] = P [x/R] ·Q[x/R]
x[x/R] = R
y[x/R] = y where x 6= y
(y 7→Q)[x/R] = y 7→Q[x/R]
(R1R2)[x/R] = R1[x/R] R2[x/R]
side(A)[x/R] = side(A)
(λx.P ? R1)[x/R] = λx.P ? R1
(λy.P ? R1)[x/R] = λy.P [x/R] ? R1[x/R] where x 6= y, and
y 6∈ fv(R) or x 6∈ fv(P,R1)
(λy.P ? R1)[x/R] = λz.P [x/z][x/R] ? R1[x/z][x/R] where x 6= y and
y ∈ fv(R) and x ∈ fv(P,R1)
(R1.y)[x/R] = project(R1[x/R], y)
Table 11
Projection
project(, x) = error ≡ .x
project(R · x7→R1, x) = R1
project(R · y 7→R1, x) = project(R, x) if x 6= y
project(R · (λy.P ? R1), x) = project(R, x)
project(R · side(A), x) = project(R, x)
project(R, x) = R.x otherwise
</equation>
<bodyText confidence="0.935683">
uated projection is returned. For instance project(R1 · x 7→R2, x) = R2 and
project(y, x) = y.x.
If the form is extended to its right with a binding x 7→R, projection on x returns
R. This is the important case that simplifies a projection expression. If the
form is an extension with a service or an extension with a binding with a
different label, projection proceeds recursively. In any other case, projection
cannot be determined at specialization time and project(R, x) denotes the
projection R.x. Note that R.x is a lazy form if x ∈ labels(R), for instance
</bodyText>
<equation confidence="0.405044">
(x 7→ · y).x ∈ R.
</equation>
<subsubsectionHeader confidence="0.849538">
5.2.1 Combining Side-effects and Lazy Forms
</subsubsectionHeader>
<bodyText confidence="0.99697">
The function combine gives a denotational semantics to pairs of side-effects
and lazy forms. It does so by translating them to Piccola agents. The function
</bodyText>
<page confidence="0.994416">
24
</page>
<tableCaption confidence="0.731816">
Table 12
Embedding side-effects and lazy terms
</tableCaption>
<equation confidence="0.984850583333333">
embed() = 
embed(x) = x
embed(R1 ·R2) = embed(R1) · embed(R2)
embed(side(A)) = A
embed(x7→R) = x7→embed(R)
embed(P.x) = embed(P );x
embed(λx.P ? R) = λx.combine(P,R)
combine ′() = R
combine ′(P1 · P2) = combine ′(P1); combine ′(P2)
combine ′(x7→R1R2) = R · x7→embed(R1)embed(R2)
combine ′(x7→R.x) = R · x7→embed(R.x)
combine ′(x7→P ) = R · x7→combine ′(P )
</equation>
<bodyText confidence="0.934122461538462">
combine is defined as:
combine(P,R) = combine ′(P ); embed(R)
A side-effect and a lazy form are combined into a sandbox expression where
the root context is the combined side-effect and the value is the embedded lazy
form. The functions embed and combine ′ are given in Table 12. The embedding
is compositional except for abstractions that respect the special nature of lazy
closures. Since an abstraction λx.P ? R itself contains a side-effect part and a
lazy form value, the embedding is λx.combine(P,R).
The function combine ′(P ) translates a side-effect into a functional agent. It
replaces the sequential composition operator of the side-effect with a sandbox.
Nested side-effects, applications and projections are combined into extensions
of R with the embedded expression. Recall from the introduction that the
root context R will contain the side-effects.
</bodyText>
<subsubsectionHeader confidence="0.980016">
5.2.2 Separating Side-effects
</subsubsectionHeader>
<bodyText confidence="0.999861">
We now discuss splitting of agents which is the heart of the specialization
algorithm. The function split(A,R) is defined in Table 13. The first few rules
of the definition are straightforward. In rules (1-3), for example, the side-effect
part is empty since the construction of a service has no side-effect. The lazy
forms are the primitive services marked as side-effect services.
</bodyText>
<page confidence="0.982748">
25
</page>
<tableCaption confidence="0.891986">
Table 13
</tableCaption>
<subsectionHeader confidence="0.506659">
Split Function
</subsectionHeader>
<equation confidence="0.996462375">
split(L, R′) = (, side(L)) (1)
split(new, R′) = (, side(new)) (2)
split(run, R′) = (, side(run)) (3)
split(hidex, R′) = (, side(hidex)) (4)
split(, R′) = (, ) (5)
split(R, R′) = (, R′) (6)
split(x7→A,R′) = (P, x7→R) where split(A,R′) = (P,R) (7)
split(A;B,R′) = (P1 · P2, R2) where split(A,R′) = (P1, R1)
and split(B,R1) = (P2, R2) (8)
split(A ·B,R′) = (P1 · P2, R1 ·R2) where split(A,R′) = (P1, R1)
and split(B,R′) = (P2, R2) (9)
split(λx.A,R′) = (, λx.P ? R) where split(A,R′ · x7→x) = (P,R) (10)
split(x,R′) =
{
(, project(R′, x)) if x ∈ labels(R′)
(y 7→project(R′, x), y) otherwise
(11)
split(AB,R′) =

(P1 · P2, R3[x/R2]) if service(R1) = λx. ? R3
(P1 · P2 · y 7→P3[x/R2], if service(R1) = λx.P3 ? R3
nest(R3, y, P3)[x/R2]) and P3 6= 
(P1 · P2 · y 7→service(R1)R2, y) otherwise
(12)
</equation>
<bodyText confidence="0.977702866666667">
where (P1, R1) = split(A,R′), (P2, R2) = split(B,R′) and y denotes a unique iden-
tifier.
The side-effect of evaluating the empty form (5) is the empty form and the
result is the empty form. The result of evaluating R (6) is the current context
R′ and the side-effect is empty. Splitting a binding (7) works as follows: we
first split A which yields a side-effect P and a result R. The side-effects are
propagated and the resulting lazy form is the lazy binding x 7→R.
Evaluation of x (11) is done by projecting x in the current root context R′.
The most interesting case is specializing an application (equation 12 on Table
13). First — as is the case with extension — we split the agents A and B in
the context of R′. This gives us two side-effects P1 and P2 and two lazy forms
R1 and R2, respectively. The side-effects are composed in the right order, first
P1 then P2. The predicate service : R→ R (see Table 14) extracts the service
bound in a term. For instance, service(y 7→R1 · λx.P ? R) is the abstraction
λx.P ? R.
</bodyText>
<page confidence="0.98205">
26
</page>
<tableCaption confidence="0.838295">
Table 14
Service selection and nesting
</tableCaption>
<equation confidence="0.980594857142857">
service() = error
service(R · λx.P ? R1) = λx.P ? R1
service(R · side(A)) = side(A)
service(R · x7→R1) = service(R)
service(R, x) = R otherwise
nest(R, x, ) = R
nest(R, x, P · y 7→Q) = nest(R[x/x.y], x, P )
</equation>
<bodyText confidence="0.829781">
Now, there are three possible ways to proceed, depending on the service of the
application:
</bodyText>
<listItem confidence="0.901808666666667">
(1) If the service is referentially transparent, i.e., its side-effect is empty, as
in λx. ? R3, then we inline the application.
(2) If the service contains side-effects, i.e., λx.P3 ?R3 where P3 6= , then we
</listItem>
<bodyText confidence="0.9958954">
introduce a new label y and bind it to the side effect term. We need to
ensure that we can refer to the result of this application even if we invoke
the same abstraction several times. Consequently, the lazy form has to
lookup the result in the nested form by using a projection.
The function nest does the nesting of side-effects (see Table 14). The
term nest(R, x, P ) is R where all y that are defined in P are replaced by
the projection x.y.
(3) When the service cannot be determined at specialization time, we simply
put the application into the side-effect and bind it to a unique label y.
This concludes the predicate split and the partial evaluation algorithm.
</bodyText>
<subsubsectionHeader confidence="0.634147">
5.2.3 Example
</subsubsectionHeader>
<bodyText confidence="0.991735625">
Let us consider an example of splitting an application with a side effect.
Assume the application f() appears within an abstraction where f is the
passed argument. We have:
split(λf.f(), ) = (, λf.y1 7→f() ? y1)
Now we apply this abstraction to a form F . In the side effect and the lazy
form we have to replace the variable f with the concrete argument F . The
substitution yields y1 7→F () and y1.
Using such a unique label y2, the side effect of the above application is
</bodyText>
<page confidence="0.974141">
27
</page>
<equation confidence="0.939294">
y2 7→(y1 7→F ()) and the lazy form y2.y1.
</equation>
<bodyText confidence="0.9806685">
Consider the following agent A. It defines a service f which calls a service g.
The service f is applied twice, once on the empty form and once on the form
</bodyText>
<equation confidence="0.873004714285714">
u.
A = R · f 7→λx.(c 7→(g(a 7→x)︸ ︷︷ ︸)
y1
); a7→f()︸︷︷︸
y2
· b 7→ fu︸︷︷︸
y3
</equation>
<bodyText confidence="0.97143375">
The agent A contains three static applications. We associate unique identifier
y1...3 with each invocation. Let r be the initial context that contains the bind-
ings for the unknown forms r = g 7→g · u 7→u. Splitting the three applications
yields:
</bodyText>
<equation confidence="0.7736275">
split(g(a 7→x), r · x 7→x) = (y1 7→g(a 7→x), c 7→y1)
split(f(), r · f 7→(...) = (y2 7→(y1 7→g(a 7→)), c 7→y2.y1)
split(fu, r · f 7→(...) = (y3 7→(y1 7→g(a 7→u)), c 7→y3.y1)
which gives
split(A, r) = (y2 7→(y1 7→g(a 7→)) · y3 7→(y1 7→g(a 7→u)),
a 7→(c 7→y2.y1) · b 7→(c 7→y3.y1))
</equation>
<bodyText confidence="0.9990659">
The partial evaluation has inlined f and bound the side-effects to y2 and y3,
respectively.
Observe that the nesting of side-effects ensures that we can access the side-
effects from within the lazy form expression. If we apply the partial evaluation
algorithm twice on the above expression, the nested side effects and projection
are specialized:
split(combine(split(A, r)), r) = (y1 7→g(a 7→) · y2 7→g(a 7→u), a7→(c 7→y1) · b 7→(c 7→y2))
However, applying split twice does not linearize all nested side-effects since
recursive service applications would introduce new nested side-effects at each
specialization step.
</bodyText>
<subsectionHeader confidence="0.99825">
5.3 Termination and Correctness
</subsectionHeader>
<bodyText confidence="0.99858225">
We now show that the partial evaluation algorithm is correct and terminates
for all expressions. While termination is straightforward to show, correctness
requires a bit of work. The important definition is that of referential trans-
parency.
</bodyText>
<page confidence="0.990256">
28
</page>
<subsubsectionHeader confidence="0.391681">
5.3.1 Termination
</subsubsectionHeader>
<bodyText confidence="0.983500636363636">
We can readily verify by structural induction on the domains for A,P and R
that the algorithm terminates. The important aspect for termination is the
definition of the substitution given in Table 10. Consider the application xR1
where we replace x with a user defined abstraction. For example
(xR1)[x/λz.P ? R] = (λz.P ? R)R1[x/λz.P ? R]
It might be tempting to define the result of such a substitution as the result
of splitting the application, as we have done for projection. However, this
may lead to an infinite loop during the specialization process. Consider the
term xx where we substitute the service λy.y1 7→yy ? y1 for x. When we split
the substitute term, the process loops since the substitute contains another
instance of the same expression.
</bodyText>
<subsectionHeader confidence="0.618838">
5.3.2 Correctness
</subsectionHeader>
<bodyText confidence="0.9883066">
This property specifies that any closed agent is behaviourally equivalent to its
specialized agent. This means:
partial(A) ≈ A for A closed (1)
In order to prove this equation, we show by induction over A that for all
functional agents A and lazy form expressions R, the following holds
</bodyText>
<equation confidence="0.840544">
combine(split(A,R)) ≈ embed(R);A (2)
</equation>
<bodyText confidence="0.948148">
Then, equation (1) is a special case of equation (2) where R is the empty
form. However, in order to prove the induction steps for this equation we need
a stronger property, namely that for all A and R, there are two agents A1 and
A2 such that:
combine(split(A,R)) ≈ A1;A2
and all free labels in A2 are defined by A1 and A2 does not contain any
applications which cause side-effects or undefined projections. Whenever A1
reduces to a barb with value F , there exists a form value G such that the
expression F ;A2 is equivalent to G. The formal definition of this property is
that A2 is referentially transparent in A1.
Definition 6 A Piccola agent B is referentially transparent in an agent A, if
for any agent C and vector of names c̃ with νc̃.C  |A⇓, written as canonical
</bodyText>
<page confidence="0.991836">
29
</page>
<bodyText confidence="0.622444">
agent:
</bodyText>
<equation confidence="0.83123">
νc̃.(C  |A) ⇒ νc̃′.(M1  |...  |Mn  |A1  |...  |Ak−1  |F )
</equation>
<bodyText confidence="0.976602352941176">
there exists a form G such that:
F ;B ≈ G
The fact that B is referentially transparent within A is written A ` B.  ` B
is written as ` B.
Referential transparency formalizes the idea behind lazy forms. Whenever A
is reduced to a barb with value F , the agent F ;B is equivalent to a form G.
In other words, when A reduces to F then A;B reduces to G. This notion
rules out the possibility of B containing a side-effect. It also guarantees that
all required labels of B are defined by A.
The word all in the above definition is important. It is not enough to find an
equivalent G just for some possible reductions. For instance
c(x 7→)  |c()  |c?; x→ c()  |x 7→();x ≈ c()  |
But c(x 7→)  |c()  |c? 6` x.
Obviously, all forms are referentially transparent, thus ` F for any form F .
We can prove by induction on A that split(A,R) generates tuples that are ref-
erentially transparent. If split(A,R) = (P,R) then combine ′(P ) ` embed(R)
[2].
</bodyText>
<sectionHeader confidence="0.999462" genericHeader="method">
6 Related Work
</sectionHeader>
<bodyText confidence="0.9714575">
The Piccola calculus extends the asynchronous π-calculus with higher-order
abstractions and first-class environments.
</bodyText>
<subsectionHeader confidence="0.996648">
6.1 π-calculus
</subsectionHeader>
<bodyText confidence="0.999534571428571">
The π-calculus [32] is a calculus of communicating systems in which one can
naturally express processes with a changing structure. Its theory has been
thoroughly studied and many results relate other formalisms or implementa-
tions to it. The affinity between objects and processes, for example, has been
treated by various authors in the context of the π-calculus [21,53]. The Pict
experiment has shown that the π-calculus is a suitable basis for programming
many high-level constructs by encodings [42].
</bodyText>
<page confidence="0.977181">
30
</page>
<bodyText confidence="0.991738875">
For programming and implementation purposes, synchronous communication
seems uncommon and can generally be encoded by using explicit acknowledg-
ments (cf. [21]). Moreover, asynchronous communication has a closer corre-
spondence to distributed computing [54]. Furthermore, in the π-calculus the
asynchronous variant has the pleasant property that equivalences are simpler
than for the synchronous case [16]. Input-guarded choice can be encoded and
is fully abstract [34]. For these reasons we adopt asynchronous channels in the
Piccola calculus.
</bodyText>
<subsectionHeader confidence="0.892434">
6.2 Higher-order abstractions
</subsectionHeader>
<bodyText confidence="0.9995002">
Programming directly in the π-calculus is often considered like programming
a concurrent assembler. When comparing programs written in the π-calculus
with the lambda-calculus it seems like lambda abstractions scale up, whereas
sending and receiving messages does not scale well. There are two possible
solutions proposed to this problem: we can change the metaphor of communi-
cation or we can introduce abstractions as first-class values.
The first approach is advocated by the Join-calculus [17]. Communication does
not happen between a sender and a receiver, instead a join pattern triggers
a process on consumption of several pending messages. The Blue calculus of
Boudol [10] changes the receive primitive into a definition which is defined for
a scope. By that change, the Blue calculus is more closely related to functions
and provides a better notion for higher-order abstraction. Boudol calls it a
continuation-passing calculus.
The other approach is adopted by Sangiorgi in the HOπ-calculus. Instead of
communicating channels or tuples of channels, processes can be communicated
as well. Surprisingly, the higher-order case has the same expressive power
as the first-order version [44,45]. In the Piccola calculus we take the second
approach and reuse existing encodings of functions into the π-calculus as in
Pict. The motivation for this comes from the fact that the HOπ-calculus itself
can be encoded in the first-order case.
</bodyText>
<subsectionHeader confidence="0.994382">
6.3 Asymmetric parallel composition
</subsectionHeader>
<bodyText confidence="0.9982264">
The semantics of asynchronous parallel composition is used in the concurrent
object calculus of Gordon and Hankin [19] or the (asymmetric) Blue calculus
studied by Dal-Zilio [14]. In the higher-order π-calculus the evaluation order is
orthogonal to the communication semantics [45]. In Piccola, evaluation strat-
egy interferes with communication, therefore we have to fix one for meaningful
</bodyText>
<page confidence="0.998349">
31
</page>
<bodyText confidence="0.9981795">
terms. For Piccola, we define strict evaluation which seems appropriate and
more common for concurrent computing.
</bodyText>
<subsectionHeader confidence="0.941466">
6.4 Record calculus
</subsectionHeader>
<bodyText confidence="0.9989039">
When modeling components and interfaces, a record-based approach is the ob-
vious choice. We use forms [27,28] as an explicit notion for extensible records.
Record calculi are studied in more detail for example in [12,43].
In the λ-calculus with names of Dami [15] arguments to functions are named.
The resulting system supports records as arguments instead of tuples as in
the classical calculus. The λN -calculus was one of the main inspiration for
our work on forms without introspection. An issue omitted in our approach
is record typing. It is not clear how far record types with subtyping and the
runtime acquisition can be combined. An overview of record typing and the
problems involved can be found for example in [12].
</bodyText>
<subsectionHeader confidence="0.964456">
6.5 Explicit environments
</subsectionHeader>
<bodyText confidence="0.999498214285714">
An explicit environment generalizes the concept of explicit substitution [1]
by using a record like structure for the environment. In the environment cal-
culus of Nishizaki, there is an operation to get the current environment as
a record and an operator to evaluate an expression using a record as envi-
ronment [40,46]. Projection of a label x in a record R then corresponds to
evaluating the script x in an environment denoted by R. The reader may note
that explicit environments subsume records. This is the reason why we call
them forms in Piccola instead of just records. Handling the environment as
a first-class entity allows us to define concepts like modules, interfaces and
implementation for programming in the large within the framework.
To our knowledge, the language Pebble of Burstall and Lampson was the
first to formally show how to build modules, interfaces and implementation,
abstract data types and generics on a typed lambda calculus with bindings,
declarations and types as first-class values [11].
</bodyText>
<subsectionHeader confidence="0.971545">
6.6 Other approaches
</subsectionHeader>
<bodyText confidence="0.998212333333333">
Zenger has developed a component calculus [55] that extends Featherweight
Java [22] with primitives to dynamically build, extend and compose software
components. The novelty of Zenger’s calculus is that components are composed
</bodyText>
<page confidence="0.991332">
32
</page>
<bodyText confidence="0.999734470588235">
implicitly on the basis of the type compatibility of component interfaces, rather
than by establishing explicit connections.
Pahl has developed composition and replacement calculus based on the π-
calculus [41]. In this approach, types are used to characterize values that may
be passed along ports, and contracts (pre- and post-conditions) are used to
determine whether provided and required services match. The calculus is used
to reason about when components can be replaced in dynamically evolving
systems.
A very different model is offered by ρω (AKA Reo) [7], a calculus of compo-
nent connectors. Reo is algebraic in flavour, and provides various connectors
that coordinate and compose streams of data. Primitive connectors can be
composed using the Reo operators to build higher-level connectors. In con-
trast to process calculi, Reo is well-suited to compositional reasoning, since
connectors can be composed to yield new connectors, and properties of con-
nectors can be shown to compose. Data communicated along streams are un-
interpreted in Reo, so it would be natural to explore the application of Reo
to streams of forms.
</bodyText>
<subsectionHeader confidence="0.736304">
6.7 Precursors to the Piccola calculus
</subsectionHeader>
<bodyText confidence="0.998363714285714">
In our earlier work on the foundations of Piccola, we specified the semantics
of Piccola in terms of translations to πL (the π calculus with labels) [27,28]
or to the form calculus [50]. The difference between πL and the form calculus
is that the latter allows hiding of labels and forms and it contains a testing
primitive for labels.
The Piccola calculus is better suited to give a direct semantics to the Piccola
language. The enhanced expressiveness of the Piccola calculus with respect to
</bodyText>
<listItem confidence="0.845782818181818">
the form- and the πL-calculus are as follows:
• Form extension. In πL and the form calculus we have separate primitives
to extend a form with either a single binding or a separate form. In the
Piccola calculus there is a single extension operator · for asymmetric form
concatenation.
• Label hiding. The Piccola calculus introduces label hiding as a primitive
service. It cannot be expressed in πL or the form calculus.
• Nested forms. The syntax for binding is simplified in the Piccola calculus
since nested forms are primitive. In the form calculus and πL nested forms
must be encoded as constant services.
• Label matching. The form calculus provides a matching construct that allows
</listItem>
<bodyText confidence="0.983508">
an agent to check whether a given form contains a label. In the Piccola
calculus we do not need this primitive since inspect is more expressive and
</bodyText>
<page confidence="0.995055">
33
</page>
<bodyText confidence="0.825433666666667">
allows us to build a checking predicate within the language. In contrast,
neither in the form calculus nor in πL can we iterate over all the labels in
a form.
</bodyText>
<listItem confidence="0.99585725">
• Higher-order abstractions. In Piccola, lambda abstractions are specified as
user services. In πL and the form calculus, such abstractions must be en-
coded using a replicated agent.
• Value semantics. In the Piccola calculus, agents that are not stuck reduce to
</listItem>
<bodyText confidence="0.9818665">
value. (“Everything is a form.”) In πL and in the form calculus, a (parallel)
process does not denote a value.
</bodyText>
<sectionHeader confidence="0.985623" genericHeader="conclusions">
7 Concluding Remarks
</sectionHeader>
<bodyText confidence="0.999842111111111">
We have presented the Piccola calculus, a high-level calculus for modeling
software components that extends the asynchronous π-calculus with explicit
namespaces, or forms. The calculus serves as the semantic target for Piccola,
a language for composing software components that conform to a particular
compositional style. JPiccola, the Java implementation of Piccola, is realized
by translation to an abstract machine that implements the Piccola calculus.
The Piccola calculus is not only helpful for modeling components and connec-
tors, but it also helps to reason about the Piccola language implementation
and about compositional styles. Efficient language bridging between Piccola
and the host language (Java or Squeak) is achieved by means of partial evalu-
ation of language wrappers. The partial evaluation algorithm is proved correct
with the help of the Piccola calculus.
Different compositional styles make different assumptions about software com-
ponents. Mixing incompatible components can lead to compositional mis-
matches. The Piccola calculus can help to bridge mismatches by supporting
reasoning about wrappers that adapt component contracts from one style to
another. We have studied two extended examples. The first concerns synchro-
nization wrappers that express the synchronization constraints assumed by a
component. The second study compares push- and pull-flow filters and demon-
strates how to adapt pull-filters so that they work correctly in a push-style
[2].
One shortcoming of our work so far is the lack of a type system. We have been
experimenting with a system of contractual types [35] that expresses both the
provided as well as the required services of a software component. Contractual
types are formalized in the context of the form calculus, which can be seen as
the Piccola calculus minus agents and channels. Contractual types have been
integrated into the most recent distribution of JPiccola [26].
</bodyText>
<page confidence="0.995959">
34
</page>
<sectionHeader confidence="0.990696" genericHeader="acknowledgments">
Acknowledgments
</sectionHeader>
<bodyText confidence="0.938456">
We gratefully acknowledge the financial support of the Swiss National Sci-
ence Foundation for projects No. 20-61655.00, “Meta-models and Tools for
</bodyText>
<reference confidence="0.665508">
Evolution Towards Component Systems”, and 2000-067855.02, “Tools and
Techniques for Decomposing and Composing Software”.
</reference>
<sectionHeader confidence="0.672014" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.9996657">
[1] Mart́ın Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Lévy.
Explicit substitutions. Journal of Functional Programming, 1(4):375–416,
October 1991.
[2] Franz Achermann. Forms, Agents and Channels — Defining Composition
Abstraction with Style. PhD thesis, University of Berne, January 2002.
[3] Franz Achermann, Stefan Kneubühl, and Oscar Nierstrasz. Scripting
coordination styles. In António Porto and Gruia-Catalin Roman, editors,
Coordination ’2000, volume 1906 of LNCS, pages 19–35, Limassol, Cyprus,
September 2000. Springer-Verlag.
[4] Franz Achermann, Markus Lumpe, Jean-Guy Schneider, and Oscar Nierstrasz.
Piccola — a small composition language. In Howard Bowman and John Derrick,
editors, Formal Methods for Distributed Processing — A Survey of Object-
Oriented Approaches, pages 403–426. Cambridge University Press, 2001.
[5] Franz Achermann and Oscar Nierstrasz. Explicit Namespaces. In Jürg
Gutknecht and Wolfgang Weck, editors, Modular Programming Languages,
volume 1897 of LNCS, pages 77–89, Zürich, Switzerland, September 2000.
Springer-Verlag.
[6] Franz Achermann and Oscar Nierstrasz. Applications = Components + Scripts
— A Tour of Piccola. In Mehmet Aksit, editor, Software Architectures and
Component Technology, pages 261–292. Kluwer, 2001.
[7] Farhad Arbab and Farhad Mavaddat. Coordination through channel
composition. In F. Arbab and C. Talcott, editors, Coordination Languages and
Models: Proc. Coordination 2002, volume 2315 of Lecture Notes in Computer
Science, pages 21–38. Springer-Verlag, April 2002.
[8] Kenichi Asai, Hidehiko Masuhara, and Akinori Yonezawa. Partial evaluation of
call-by-value λ-calculus with side-effects. In Proceedings of the ACM SIGPLAN
Symposium on Partial Evaluation and Semantics-Based Program Manipulation,
pages 12–21, Amsterdam, the Netherlands, June 1997.
[9] Gérard Berry and Gérard Boudol. The chemical abstract machine. Theoretical
Computer Science, 96:217–248, 1992.
</reference>
<page confidence="0.960398">
35
</page>
<reference confidence="0.999845948717949">
[10] Gérard Boudol. The pi-calculus in direct style. In Conference Record of
POPL ’97, pages 228–241, 1997.
[11] Rod Burstall and Butler Lampson. A kernel language for abstract data types
and modules. Information and Computation, 76(2/3), 1984. Also appeared
in Proceedings of the International Symposium on Semantics of Data Types,
Springer, LNCS (1984), and as SRC Research Report 1.
[12] Luca Cardelli and John C. Mitchell. Operations on records. In Carl A.
Gunter and John C. Mitchell, editors, Theoretical Aspects of Object-Oriented
Programming. Types, Semantics and Language Design, pages 295–350. MIT
Press, 1993.
[13] Charles Consel and Olivier Danvy. Tutorial notes on partial evaluation. In
Conference Record of POPL ’93, pages 493–501. ACM, January 1993.
[14] Silvano Dal-Zilio. Le calcul bleu: types et objects. Ph.D. thesis, Université de
Nice — Sophia Antipolis, July 1999. In french.
[15] Laurent Dami. Software Composition: Towards an Integration of Functional
and Object-Oriented Approaches. Ph.D. thesis, University of Geneva, 1994.
[16] Cédric Fournet and Georges Gonthier. A hierarchy of equivalences for
asynchronous calculi. In Proceedings of ICALP ’98, pages 844–855, 1998.
[17] Cédric Fournet, Georges Gonthier, Jean-Jacques Lévy, Luc Maranget, and
Didier Rémy. A calculus of mobile agents. In Proceedings of the 7th International
Conference on Concurrency Theory (CONCUR ’96), volume 1119 of LNCS,
pages 406–421. Springer-Verlag, August 1996.
[18] David Garlan, Robert Allen, and John Ockerbloom. Architectural mismatch:
Why reuse is so hard. IEEE Software, 12(6):17–26, November 1995.
[19] Andrew D. Gordon and Paul D. Hankin. A concurrent object calculus:
Reduction and typing. In Proceedings HLCL ’98. Elsevier ENTCS, 1998.
[20] J. Roger Hindley and Jonathan P. Seldin. Introduction to Combinatory Logic
and Lambda Calculus. Cambridge University Press, 1986.
[21] Kohei Honda and Mario Tokoro. An object calculus for asynchronous
communication. In Pierre America, editor, Proceedings ECOOP ’91, volume
512 of LNCS, pages 133–147, Geneva, Switzerland, July 1991. Springer-Verlag.
[22] Atsushi Igarashi, Benjamin C. Pierce, and Philip Wadler. Featherweight Java:
a minimal core calculus for Java and GJ. ACM TOPLAS, 23(3):396–450, May
2001.
[23] Dan Ingalls, Ted Kaehler, John Maloney, Scott Wallace, and Alan Kay. Back
to the future: The story of Squeak, A practical Smalltalk written in itself. In
Proceedings OOPSLA ’97, pages 318–326. ACM Press, November 1997.
[24] Neil J. Jones, Carsten K. Gomard, and Peter Sestoft. Partial Evaluation and
Automatic Program Generation. Prentice-Hall, 1993.
</reference>
<page confidence="0.946391">
36
</page>
<reference confidence="0.999180075">
[25] Stefan
Kneubühl. Implementing coordination styles in piccola. Informatikprojekt,
University of Bern, February 2001.
[26] Stefan Kneubühl. Typeful compositional styles. Diploma thesis, University of
Bern, April 2003.
[27] Markus Lumpe. A Pi-Calculus Based Approach to Software Composition.
Ph.D. thesis, University of Bern, Institute of Computer Science and Applied
Mathematics, January 1999.
[28] Markus Lumpe, Franz Achermann, and Oscar Nierstrasz. A Formal Language
for Composition. In Gary Leavens and Murali Sitaraman, editors, Foundations
of Component Based Systems, pages 69–90. Cambridge University Press, 2000.
[29] Mark Lutz. Programming Python. O’Reilly &amp; Associates, Inc., 1996.
[30] Massimo Merro and Davide Sangiorgi. On asynchrony in name-passing calculi.
In Kim G. Larsen, Sven Skyum, and GlynnWinskel, editors, 25th Colloquium on
Automata, Languages and Programming (ICALP) (Aalborg, Denmark), volume
1443 of LNCS, pages 856–867. Springer-Verlag, July 1998.
[31] Wolfgang De Meuter. Agora: The story of the simplest MOP in the world — or
— the scheme of object–orientation. In J. Noble, I. Moore, and A. Taivalsaari,
editors, Prototype-based Programming. Springer-Verlag, 1998.
[32] Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile
processes, part I/II. Information and Computation, 100:1–77, 1992.
[33] Robin Milner and Davide Sangiorgi. Barbed bisimulation. In Proceedings
ICALP ’92, volume 623 of LNCS, pages 685–695, Vienna, July 1992. Springer-
Verlag.
[34] Uwe Nestmann and Benjamin C. Pierce. Decoding choice encodings. In Ugo
Montanari and Vladimiro Sassone, editors, CONCUR ’96: Concurrency Theory,
7th International Conference, volume 1119 of LNCS, pages 179–194, Pisa, Italy,
August 1996. Springer-Verlag.
[35] Oscar Nierstrasz. Contractual types. Technical Report IAM-03-004, Institut
für Informatik, Universität Bern, Switzerland, 2003.
[36] Oscar Nierstrasz and Franz Achermann. Supporting Compositional Styles for
Software Evolution. In Proceedings International Symposium on Principles of
Software Evolution (ISPSE 2000), pages 11–19, Kanazawa, Japan, November
2000. IEEE.
[37] Oscar Nierstrasz and Franz Achermann. A calculus for modeling software
components. In FMCO 2002 Proceedings, volume 2852 of LNCS, pages 339–360.
Springer-Verlag, 2003.
[38] Oscar Nierstrasz, Franz Achermann, and Stefan Kneubühl. A guide to
JPiccola. Technical Report IAM-03-003, Institut für Informatik, Universität
Bern, Switzerland, June 2003.
</reference>
<page confidence="0.978475">
37
</page>
<reference confidence="0.999907184210526">
[39] Oscar Nierstrasz and Theo Dirk Meijler. Requirements for a composition
language. In Paolo Ciancarini, Oscar Nierstrasz, and Akinori Yonezawa, editors,
Object-Based Models and Langages for Concurrent Systems, volume 924 of
LNCS, pages 147–161. Springer-Verlag, 1995.
[40] Shin-ya Nishizaki. Programmable environment calculus as theory of dynamic
software evolution. In Proceedings ISPSE 2000. IEEE Computer Society Press,
2000.
[41] Claus Pahl. A pi-calculus based framework for the composition and replacement
of components. In Workshop on Specification and Verification of Component-
Based Systems (OOPSLA 2001), 2001.
[42] Benjamin C. Pierce and David N. Turner. Pict: A programming language based
on the pi-calculus. In G. Plotkin, C. Stirling, and M. Tofte, editors, Proof,
Language and Interaction: Essays in Honour of Robin Milner. MIT Press, May
2000.
[43] Didier Rémy. Typing Record Concatenation for Free, chapter 10, pages 351–372.
MIT Press, April 1994.
[44] Davide Sangiorgi. Expressing Mobility in Process Algebras: First-Order and
Higher-Order Paradigms. Ph.D. thesis, Computer Science Dept., University of
Edinburgh, May 1993.
[45] Davide Sangiorgi. Asynchronous process calculi: the first-order and higher-order
paradigms (tutorial). Theoretical Computer Science, 253, 2001.
[46] Masahiko Sato, Takafumi Sakurai, and Rod M. Burstall. Explicit environments.
In Jean-Yves Girard, editor, Typed Lambda Calculi and Applications, volume
1581 of LNCS, pages 340–354, L’Aquila, Italy, April 1999. Springer-Verlag.
[47] Nathanael Schärli. Supporting pure composition by inter-language bridging on
the meta-level. Diploma thesis, University of Bern, September 2001.
[48] Nathanael Schärli and Franz Achermann. Partial evaluation of inter-language
wrappers. InWorkshop on Composition Languages, WCL ’01, September 2001.
[49] Andreas Schlapbach. Enabling white-box reuse in a pure composition language.
Diploma thesis, University of Bern, January 2003.
[50] Jean-Guy Schneider. Components, Scripts, and Glue: A conceptual framework
for software composition. Ph.D. thesis, University of Bern, Institute of
Computer Science and Applied Mathematics, October 1999.
[51] Jean-Guy Schneider and Oscar Nierstrasz. Components, scripts and glue. In
Leonor Barroca, Jon Hall, and Patrick Hall, editors, Software Architectures —
Advances and Applications, pages 13–25. Springer-Verlag, 1999.
[52] Mary Shaw and David Garlan. Software Architecture: Perspectives on an
Emerging Discipline. Prentice-Hall, 1996.
</reference>
<page confidence="0.976084">
38
</page>
<reference confidence="0.99977125">
[53] David Walker. Objects in the π-calculus. Information and Computation,
116(2):253–271, February 1995.
[54] Pawel T. Wojciechowski. Nomadic Pict: Language and Infrastructure Design
for Mobile Computation. PhD thesis, Wolfson College, University of Cambridge,
March 2000.
[55] Matthias Zenger. Type-safe prototype-based component evolution. In
Proceedings ECOOP 2002, volume 2374 of LNCS, pages 470–497, Malaga,
Spain, June 2002. Springer Verlag.
</reference>
<page confidence="0.999132">
39
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.542276">
<title confidence="0.999505">A Calculus for Reasoning about Software Composition</title>
<author confidence="0.998635">Franz Achermann</author>
<author confidence="0.998635">Oscar Nierstrasz</author>
<affiliation confidence="0.872264">Software Composition Group University of Bern, Switzerland</affiliation>
<email confidence="0.988288">www.iam.unibe.ch/∼scg</email>
<abstract confidence="0.999963166666667">Although the term software component has become commonplace, there is no universally accepted definition of the term, nor does there exist a common foundation for specifying various kinds of components and their compositions. We propose such a foundation. The Piccola calculus is a process calculus, based on the asynchronous π-calculus, extended with explicit namespaces. The calculus is high-level, rather than minimal, and is consequently convenient for expressing and reasoning about software components, and different styles of composition. We motivate and present the calculus, and outline how it is used to specify the semantics of Piccola, a small composition language. We demonstrate how the calculus can be used to simplify compositions by partial evaluation, and we briefly outline some other applications of the calculus to reasoning about compositional styles.</abstract>
<keyword confidence="0.893984">Keywords: Software components, process calculi, software architecture</keyword>
<note confidence="0.877805666666667">Preprint submitted to Elsevier Science. Final version published as: Franz Achermann and Oscar Nierstrasz, “A Calculus for Reasoning about Software Components,” Theoretical Computer Science, vol. 331, no. 2-3, 2005, pp. 367-396.</note>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<title>Evolution Towards Component Systems”, and 2000-067855.02, “Tools and Techniques for Decomposing and Composing Software”.</title>
<marker></marker>
<rawString> Evolution Towards Component Systems”, and 2000-067855.02, “Tools and Techniques for Decomposing and Composing Software”.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Martın Abadi</author>
<author>Luca Cardelli</author>
<author>Pierre-Louis Curien</author>
<author>Jean-Jacques Levy</author>
</authors>
<title>Explicit substitutions.</title>
<date>1991</date>
<journal>Journal of Functional Programming,</journal>
<volume>1</volume>
<issue>4</issue>
<contexts>
<context position="22037" citStr="[1,40]" startWordPosition="3670" endWordPosition="3670">ound freely. For instance in x 7→c() ≡ x 7→(c() |) by emit ≡ c() |x 7→ by par ext right the message c() escapes the binding x 7→. 3.4 Reduction We define the reduction relation → on agent expressions to reduce applications, communications and projections (see Table 6). ⇒ is the reflexive and transitive closure of →. Especially noteworthy is the rule reduce beta. This rule does not substitute G for x in the agent A as in the classical λ-calculus. Instead, it extends the environment in which A is evaluated. This is essentially the beta-reduction rule found in calculi for explicit substitution [1,40]: (F ;λx.A)G → F · x 7→G;A The application of the closure F ;λx.A to the argument G reduces to a sandbox expression in which the agent A is evaluated in the environment F ·x 7→G. Free occurrences of x in A will therefore be bound to G. The property of being closed is respected by reduction: Lemma 1 If A is a closed agent and A → B or A ≡ B then B is closed as well. PROOF. Easily checked by induction over the formal proof for A→ B. 12 Table 6 Reduction rules (F ;λx.A) G→ F · x7→G;A (reduce beta) cF |c?→ F (reduce comm) F · x7→G;x→ G (reduce project) L→ ;λx.(x; isEmpty) (reduce inspect empty)</context>
<context position="58028" citStr="[1]" startWordPosition="9914" endWordPosition="9914">e λ-calculus with names of Dami [15] arguments to functions are named. The resulting system supports records as arguments instead of tuples as in the classical calculus. The λN -calculus was one of the main inspiration for our work on forms without introspection. An issue omitted in our approach is record typing. It is not clear how far record types with subtyping and the runtime acquisition can be combined. An overview of record typing and the problems involved can be found for example in [12]. 6.5 Explicit environments An explicit environment generalizes the concept of explicit substitution [1] by using a record like structure for the environment. In the environment calculus of Nishizaki, there is an operation to get the current environment as a record and an operator to evaluate an expression using a record as environment [40,46]. Projection of a label x in a record R then corresponds to evaluating the script x in an environment denoted by R. The reader may note that explicit environments subsume records. This is the reason why we call them forms in Piccola instead of just records. Handling the environment as a first-class entity allows us to define concepts like modules, interface</context>
</contexts>
<marker>[1]</marker>
<rawString>Mart́ın Abadi, Luca Cardelli, Pierre-Louis Curien, and Jean-Jacques Lévy. Explicit substitutions. Journal of Functional Programming, 1(4):375–416, October 1991.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Achermann</author>
</authors>
<title>Forms, Agents and Channels — Defining Composition Abstraction with Style.</title>
<date>2002</date>
<tech>PhD thesis,</tech>
<institution>University of Berne,</institution>
<contexts>
<context position="20525" citStr="[2]" startWordPosition="3406" endWordPosition="3406">(A ·B) (scope ext right) c /∈ fc(A) implies A; νc.B ≡ νc.(A;B) (scope sandbox left) c /∈ fc(A) implies (νc.B);A ≡ νc.(B;A) (scope sandbox right) c /∈ fc(A) implies (νc.B)A ≡ νc.BA (scope app left) c /∈ fc(A) implies A(νc.B) ≡ νc.AB (scope app right) Definition 2 For each form F , the set of labels(F ) ⊂ L is given by: labels() = ∅ labels(S) = ∅ labels(x 7→G) = {x} labels(F ·G) = labels(F ) ∪ labels(G) Using the form congruences, we can rewrite any form F into one of the following three cases: F ≡  F ≡ S F ≡ F ′ · x 7→G where x 6∈ labels(F ′) This is proved by structural induction over forms [2]. This formalizes our idea that forms are extensible records unified with services. A form has at most one binding for a given label. The second group (Table 4) defines preforms. These are agent expressions that are congruent to a form. For instance, the agent hidex is equivalent to the empty form . The set of all preforms is defined by: F≡ = {A|∃F ∈ F with F ≡ A} 11 Clearly, all forms are preforms. The last group (Table 5) defines the semantics of parallel composition and communication for agents. Note how these rules always preserve the position of the rightmost agent in a parallel composi</context>
<context position="28244" citStr="[2]" startWordPosition="4866" endWordPosition="4866">r, written A ≈ B, if there is some (weak) barbed bisimulation R with A R B. Two agents are (weakly) barbed congruent, written A ≈ B, if for all contexts C we have C[A] ≈ C[B]. We define behavioural equality using the notion of barbed congruence. As usual we can define strong and weak versions of barbed bisimulation. The strong versions are obtained in the standard way by replacing ⇒ with → and ⇓ with ↓ in Definition 4. We only concentrate on the weak case since it abstracts internal computation. 3.7 Erroneous Reductions Not all agents reduce to forms. Some agents enjoy an infinite reduction [2]. Other agents may be stuck. An agent is stuck if it is not a barb and can reduce no further. 16 Definition 5 An agent A is stuck, written A↑, if A is not a barb and there is no agent B such that A→ B. Clearly it holds that 0↑ and R↑. The property of being stuck is not compositional. For instance c?↑ but obviously, c() |c? can reduce to . We can put R into a context so that it becomes a barb, for instance F ;R ≡ F . Note that if an agent is stuck it is not a preform: F≡ ∩ {A|A↑} = ∅ by definition. Although 0 is arguably stuck by intention, in general a stuck agent can be interpreted as an err</context>
<context position="31026" citStr="[2]" startWordPosition="5333" endWordPosition="5333">alculus is more convenient to express components and connectors. 17 Applications: Components + Scripts Composition styles: Streams, GUI composition, ... Standard libraries: Coordination abstractions, control structures, basic object model ... Piccola language: Host components, user-defined operators, dynamic namespaces Piccola calculus: Forms, agents and channels Fig. 3. Piccola layers 4 From the Piccola calculus to Piccola Piccola is a small composition language that supports the requirements summarized in Figure 1, and whose denotational semantics is defined in terms of the Piccola calculus [2]. Piccola is designed in layered fashion (see Figure 3). At the lowest level we have an abstract machine that implements the Piccola calculus. At the second level, we have the Piccola language, which is implemented by translation to the abstract machine, following the specification of the denotational semantics. Piccola provides a more convenient, Python-like syntax for programming than does the calculus, including overloaded operators to support component composition. It also provides a bridge to the host language (currently Java or Squeak). Piccola provides no basic data types other than for</context>
<context position="33824" citStr="[2,47,48]" startWordPosition="5755" endWordPosition="5755">xamples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to those arguments. In this section we present a partial evaluation algorithm for Piccola [2,47,48]. This algorithm uses the fact that forms are immutable. We replace references to forms by the forms referred to. We can then specialize projections and replace applications of referentially transparent services by their results. However, most services in Piccola are not referentially transparent and cannot be inlined since that would change the order in which side-effects are executed. We need to separate the referentially transparent part from the non-transparent part in order to replace an application with its result and to ensure that the order in which the side-effects are evaluated is pr</context>
<context position="37485" citStr="[2]" startWordPosition="6356" endWordPosition="6356"> binding |λx.A abstraction |AB application new = ;λx.νc.send 7→c · receive 7→(λy.c?) run = ;λx.(x() |) Table 8 Side-effect terms and lazy forms P ::=  empty form |x7→P nested side-effect |P · P extension |x7→R.x projection |x7→RR side-effect application R ::=  empty form |x variable |R ·R extension |x7→R binding |R.x projection |λx.P ? R lazy abstraction |side(A) side-effect service a = ch.receive() when we inline the referentially transparent service. The algorithm not only splits services but also any functional agent : an agent written using a functional subset of the Piccola calculus [2] (see Table 7). We also do not represent the lazy part as curried services. Instead the root context consists of the side-effects bound by unique labels. For simplicity, we do not consider the hide primitive and treat it as a service with a side-effect. The present approach can easily be extended to handle hide more effectively [2]. The partial evaluation algorithm partial : A → A is expressed in two steps. First an agent A is split into a side-effect term and a lazy form expression. Then, the side-effect term and the lazy form are combined back into a specialized agent. The set of side-effect</context>
<context position="53969" citStr="[2]" startWordPosition="9305" endWordPosition="9305">en A;B reduces to G. This notion rules out the possibility of B containing a side-effect. It also guarantees that all required labels of B are defined by A. The word all in the above definition is important. It is not enough to find an equivalent G just for some possible reductions. For instance c(x 7→) |c() |c?; x→ c() |x 7→();x ≈ c() | But c(x 7→) |c() |c? 6` x. Obviously, all forms are referentially transparent, thus ` F for any form F . We can prove by induction on A that split(A,R) generates tuples that are referentially transparent. If split(A,R) = (P,R) then combine ′(P ) ` embed(R) [2]. 6 Related Work The Piccola calculus extends the asynchronous π-calculus with higher-order abstractions and first-class environments. 6.1 π-calculus The π-calculus [32] is a calculus of communicating systems in which one can naturally express processes with a changing structure. Its theory has been thoroughly studied and many results relate other formalisms or implementations to it. The affinity between objects and processes, for example, has been treated by various authors in the context of the π-calculus [21,53]. The Pict experiment has shown that the π-calculus is a suitable basis for prog</context>
<context position="63755" citStr="[2]" startWordPosition="10826" endWordPosition="10826">lus. Different compositional styles make different assumptions about software components. Mixing incompatible components can lead to compositional mismatches. The Piccola calculus can help to bridge mismatches by supporting reasoning about wrappers that adapt component contracts from one style to another. We have studied two extended examples. The first concerns synchronization wrappers that express the synchronization constraints assumed by a component. The second study compares push- and pull-flow filters and demonstrates how to adapt pull-filters so that they work correctly in a push-style [2]. One shortcoming of our work so far is the lack of a type system. We have been experimenting with a system of contractual types [35] that expresses both the provided as well as the required services of a software component. Contractual types are formalized in the context of the form calculus, which can be seen as the Piccola calculus minus agents and channels. Contractual types have been integrated into the most recent distribution of JPiccola [26]. 34 Acknowledgments We gratefully acknowledge the financial support of the Swiss National Science Foundation for projects No. 20-61655.00, “Meta-m</context>
</contexts>
<marker>[2]</marker>
<rawString>Franz Achermann. Forms, Agents and Channels — Defining Composition Abstraction with Style. PhD thesis, University of Berne, January 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Achermann</author>
<author>Stefan Kneubuhl</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Scripting coordination styles.</title>
<date></date>
<booktitle>In Antonio Porto and Gruia-Catalin Roman, editors, Coordination ’2000, volume 1906 of LNCS,</booktitle>
<pages>pages</pages>
<publisher>Springer-Verlag.</publisher>
<location>Limassol, Cyprus,</location>
<contexts>
<context position="4919" citStr="[3,36,52]" startWordPosition="723" endWordPosition="723">s Styles • primitive neutral object model • meta-objects • HO plugs &amp; connectors • default arguments • encapsulation • component algebras Glue • generic wrappers • component packaging • generic adaptors Coordination • coordination abstractions Scripts • sandboxes • composition expressions • context-dependent policies Fig. 1. How Piccola supports composition that is, component-based applications are (ideally) made up of stable, off-theshelf components, and scripts that plug them together [6]. Scripts (ideally) make use of high-level connectors that coordinate the services of various components [3,36,52]. Furthermore, complex applications may need services of components that depend on very different architectural assumptions [18]. In these cases, glue code is needed to adapt components to different architectural styles [50,51]. A foundation for modeling software components must therefore be suitable for expressing compositional styles, scripts, coordination abstractions and glue code. Figure 1 summarizes the requirements, and illustrates how Piccola and the Piccola calculus support them. 2.1 Compositional Styles A compositional style allows us to express the structure of a software applicatio</context>
<context position="32957" citStr="[3,36]" startWordPosition="5627" endWordPosition="5627"> These, however, are provided as standard services implemented in Piccola. Exceptions and try-catch clauses are implemented using agents, channels, and dynamic namespaces [5]. 18 The first three layers constitute the standard Piccola distribution. The fourth layer is provided by the component framework designer. At this level, a domain expert encodes a compositional styles as a library of components, connectors, adaptors, coordination abstractions, and so on. Finally, at the top level, an application programmer may script together components using the abstractions provided by the lower layers [3,36]. Piccola has been used to experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly ineffic</context>
</contexts>
<marker>[3]</marker>
<rawString>Franz Achermann, Stefan Kneubühl, and Oscar Nierstrasz. Scripting coordination styles. In António Porto and Gruia-Catalin Roman, editors, Coordination ’2000, volume 1906 of LNCS, pages 19–35, Limassol, Cyprus, September 2000. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Achermann</author>
<author>Markus Lumpe</author>
<author>Jean-Guy Schneider</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Piccola — a small composition language. In Howard Bowman and</title>
<date>2001</date>
<booktitle>Formal Methods for Distributed Processing — A Survey of ObjectOriented Approaches,</booktitle>
<pages>403--426</pages>
<editor>John Derrick, editors,</editor>
<publisher>Cambridge University Press,</publisher>
<contexts>
<context position="2023" citStr="[4,6]" startWordPosition="282" endWordPosition="282">s the promise of flexible applications being constructed from stable, robust software components. But how are components plugged into an application? How do we specify the way in which components are configured and composed? Preprint submitted to Elsevier Science 31 March 2005 In addition to components, we clearly need some means to specify compositions of components. A composition language [39] is a language for specifying operators for connecting components (i.e., “connectors”), glue abstractions for adapting component interfaces, and scripts that instantiate and connect components. Piccola [4,6] is a prototype for such a composition language, and JPiccola is an implementation which targets the composition of Java software components [38]. A key challenge for a composition language is to offer a means to answer the question, What, precisely, do we mean by composition? There are many different notions of component composition and interconnection in practice, so a composition language must offer a neutral foundation in which different forms of composition can be expressed. We therefore need a semantic foundation for specifying compositional abstractions. Components may be configured and</context>
</contexts>
<marker>[4]</marker>
<rawString>Franz Achermann, Markus Lumpe, Jean-Guy Schneider, and Oscar Nierstrasz. Piccola — a small composition language. In Howard Bowman and John Derrick, editors, Formal Methods for Distributed Processing — A Survey of ObjectOriented Approaches, pages 403–426. Cambridge University Press, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Achermann</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Explicit Namespaces.</title>
<date>2000</date>
<booktitle>Modular Programming Languages,</booktitle>
<volume>1897</volume>
<pages>77--89</pages>
<editor>In Jurg Gutknecht and Wolfgang Weck, editors,</editor>
<publisher>Springer-Verlag.</publisher>
<location>Zurich, Switzerland,</location>
<contexts>
<context position="3144" citStr="[5]" startWordPosition="449" endWordPosition="449">dation for specifying compositional abstractions. Components may be configured and adapted in many different ways, which may or may not have an impact on the resulting composition. We therefore also need to reason about equivalence of different expressions of composition. Drawing from our experience modeling various component models, we have developed the Piccola calculus as a tool for expressing the semantics of software composition and for reasoning about equivalence of compositions. The Piccola calculus extends the asychronous π-calculus [32,45] with forms—firstclass, extensible namespaces [5]. Forms are not only convenient for expressing components, but play other important roles as well. This calculus serves both as the semantic target and as an executable abstract machine for Piccola. In this paper we first motivate the calculus by establishing a set of requirements for modeling composition of software components in section 2. Next, we address these requirements by presenting the syntax and semantics of the Piccola calculus in section 3. In section 4 we provide a brief overview of the Piccola language, and summarize how the calculus helps us to define its semantics. In section 5</context>
<context position="11788" citStr="[5,37]" startWordPosition="1752" endWordPosition="1752"> glue code may need to express coordination of concurrent activities. Consider a readers/writers synchronization policy as a generic wrapper. We conclude that we not only need higher-order functions over first-class namespaces (with introspection), but also a way of expressing concurrency and communication [50]. 3 The Piccola calculus As a consequence of the requirements we have identified above, we propose as a foundation a process calculus based on the higher-order asynchronous π-calculus [32,45] in which tuple-based communication is replaced by communication of extensible records, or forms [5,37]. Furthermore, forms serve as first-class namespaces and support a simple kind of introspection. The design of the Piccola calculus strikes a balance between minimalism and expressiveness. As a calculus it is rather large. In fact, it would be possible to express everything we want with the π-calculus alone, but the semantic gap between concepts we wish to model and the terms of the calculus would be 6 Table 1 Syntax of the Piccola calculus A,B,C ::=  empty form |R current root |A;B sandbox |x variable |x7→ bind |hidex hide |L inspect |A ·B extension |λx.A abstraction |AB application |νc.A re</context>
<context position="32525" citStr="[5]" startWordPosition="5563" endWordPosition="5563"> entities, including agents and channels, as syntactic constructs in the calculus. In the Piccola language, however, these are represented only by standard library services, such as run and newChannel. The third level provides a set of standard libraries to simplify the task of programming with Piccola. Not only does the Piccola language provide no built-in data types, it does not even offer any control structures of its own. These, however, are provided as standard services implemented in Piccola. Exceptions and try-catch clauses are implemented using agents, channels, and dynamic namespaces [5]. 18 The first three layers constitute the standard Piccola distribution. The fourth layer is provided by the component framework designer. At this level, a domain expert encodes a compositional styles as a library of components, connectors, adaptors, coordination abstractions, and so on. Finally, at the top level, an application programmer may script together components using the abstractions provided by the lower layers [3,36]. Piccola has been used to experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [</context>
</contexts>
<marker>[5]</marker>
<rawString>Franz Achermann and Oscar Nierstrasz. Explicit Namespaces. In Jürg Gutknecht and Wolfgang Weck, editors, Modular Programming Languages, volume 1897 of LNCS, pages 77–89, Zürich, Switzerland, September 2000. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Franz Achermann</author>
<author>Oscar Nierstrasz</author>
</authors>
<date>2001</date>
<booktitle>Applications = Components + Scripts — A Tour of Piccola. In Mehmet Aksit, editor, Software Architectures and Component Technology,</booktitle>
<pages>261--292</pages>
<publisher>Kluwer,</publisher>
<contexts>
<context position="2023" citStr="[4,6]" startWordPosition="282" endWordPosition="282">s the promise of flexible applications being constructed from stable, robust software components. But how are components plugged into an application? How do we specify the way in which components are configured and composed? Preprint submitted to Elsevier Science 31 March 2005 In addition to components, we clearly need some means to specify compositions of components. A composition language [39] is a language for specifying operators for connecting components (i.e., “connectors”), glue abstractions for adapting component interfaces, and scripts that instantiate and connect components. Piccola [4,6] is a prototype for such a composition language, and JPiccola is an implementation which targets the composition of Java software components [38]. A key challenge for a composition language is to offer a means to answer the question, What, precisely, do we mean by composition? There are many different notions of component composition and interconnection in practice, so a composition language must offer a neutral foundation in which different forms of composition can be expressed. We therefore need a semantic foundation for specifying compositional abstractions. Components may be configured and</context>
<context position="4805" citStr="[6]" startWordPosition="707" endWordPosition="707">• introspection • explicit namespaces • services as operators • dynamic scoping on demand • agents &amp; channels Styles • primitive neutral object model • meta-objects • HO plugs &amp; connectors • default arguments • encapsulation • component algebras Glue • generic wrappers • component packaging • generic adaptors Coordination • coordination abstractions Scripts • sandboxes • composition expressions • context-dependent policies Fig. 1. How Piccola supports composition that is, component-based applications are (ideally) made up of stable, off-theshelf components, and scripts that plug them together [6]. Scripts (ideally) make use of high-level connectors that coordinate the services of various components [3,36,52]. Furthermore, complex applications may need services of components that depend on very different architectural assumptions [18]. In these cases, glue code is needed to adapt components to different architectural styles [50,51]. A foundation for modeling software components must therefore be suitable for expressing compositional styles, scripts, coordination abstractions and glue code. Figure 1 summarizes the requirements, and illustrates how Piccola and the Piccola calculus suppor</context>
<context position="33092" citStr="[6]" startWordPosition="5647" endWordPosition="5647">channels, and dynamic namespaces [5]. 18 The first three layers constitute the standard Piccola distribution. The fourth layer is provided by the component framework designer. At this level, a domain expert encodes a compositional styles as a library of components, connectors, adaptors, coordination abstractions, and so on. Finally, at the top level, an application programmer may script together components using the abstractions provided by the lower layers [3,36]. Piccola has been used to experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a </context>
</contexts>
<marker>[6]</marker>
<rawString>Franz Achermann and Oscar Nierstrasz. Applications = Components + Scripts — A Tour of Piccola. In Mehmet Aksit, editor, Software Architectures and Component Technology, pages 261–292. Kluwer, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Farhad Arbab</author>
<author>Farhad Mavaddat</author>
</authors>
<title>Coordination through channel composition.</title>
<date>2002</date>
<booktitle>Coordination Languages and Models: Proc. Coordination</booktitle>
<volume>2315</volume>
<pages>21--38</pages>
<editor>In F. Arbab and C. Talcott, editors,</editor>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="59788" citStr="[7]" startWordPosition="10192" endWordPosition="10192">us is that components are composed 32 implicitly on the basis of the type compatibility of component interfaces, rather than by establishing explicit connections. Pahl has developed composition and replacement calculus based on the π- calculus [41]. In this approach, types are used to characterize values that may be passed along ports, and contracts (pre- and post-conditions) are used to determine whether provided and required services match. The calculus is used to reason about when components can be replaced in dynamically evolving systems. A very different model is offered by ρω (AKA Reo) [7], a calculus of component connectors. Reo is algebraic in flavour, and provides various connectors that coordinate and compose streams of data. Primitive connectors can be composed using the Reo operators to build higher-level connectors. In contrast to process calculi, Reo is well-suited to compositional reasoning, since connectors can be composed to yield new connectors, and properties of connectors can be shown to compose. Data communicated along streams are uninterpreted in Reo, so it would be natural to explore the application of Reo to streams of forms. 6.7 Precursors to the Piccola calc</context>
</contexts>
<marker>[7]</marker>
<rawString>Farhad Arbab and Farhad Mavaddat. Coordination through channel composition. In F. Arbab and C. Talcott, editors, Coordination Languages and Models: Proc. Coordination 2002, volume 2315 of Lecture Notes in Computer Science, pages 21–38. Springer-Verlag, April 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kenichi Asai</author>
</authors>
<title>Hidehiko Masuhara, and Akinori Yonezawa. Partial evaluation of call-by-value λ-calculus with side-effects.</title>
<date>1997</date>
<booktitle>In Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation,</booktitle>
<pages>12--21</pages>
<location>Amsterdam, the Netherlands,</location>
<contexts>
<context position="33591" citStr="[8,24,13]" startWordPosition="5720" endWordPosition="5720">o experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to those arguments. In this section we present a partial evaluation algorithm for Piccola [2,47,48]. This algorithm uses the fact that forms are immutable. We replace references to forms by the forms referred to. We can then specialize projections and replace applications of referentially transparent services by their results. However, most services in Piccola are not referentially transparent and cannot be inlined since that would change the order in which side</context>
</contexts>
<marker>[8]</marker>
<rawString>Kenichi Asai, Hidehiko Masuhara, and Akinori Yonezawa. Partial evaluation of call-by-value λ-calculus with side-effects. In Proceedings of the ACM SIGPLAN Symposium on Partial Evaluation and Semantics-Based Program Manipulation, pages 12–21, Amsterdam, the Netherlands, June 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerard Berry</author>
<author>Gerard Boudol</author>
</authors>
<title>The chemical abstract machine.</title>
<date>1992</date>
<journal>Theoretical Computer Science,</journal>
<volume>96</volume>
<contexts>
<context position="19025" citStr="[9]" startWordPosition="3092" endWordPosition="3092"> ;AB ≡ (F ;A)(F ;B) (sandbox app) A; (B;C) ≡ (A;B);C (sandbox assoc) F ;G ≡ G (sandbox value) F ;R ≡ F (sandbox root) hidex(F · x7→G) ≡ hidexF (hide select) x 6= y implies hidey(F · x7→G) ≡ hideyF · x7→G (hide over) hidex ≡  (hide empty) hidexS ≡ S (hide service) (F · S)G ≡ SG (use service) 3.3 Congruence and Pre-forms As in the π-calculus, we introduce structural congruence over agent expressions to simplify the reduction relation. The congruence allows us to rewrite agent expressions to bring communicating agents into juxtapositions, as in the Chemical Abstract Machine of Berry and Boudol [9]. The congruence rules constitute three groups. The first group (Table 3) specifies that extension is idempotent and associative on forms. The rules single service and single binding specify that extension overwrites services and bindings with the same label. We define labels(F ) as follows: 10 Table 5 Congruences III (A |B) |C ≡ A |(B |C) (par assoc) (A |B) |C ≡ (B |A) |C (par left commute) (A |B) · C ≡ A |B · C (par ext left) F · (A |B) ≡ A |F ·B (par ext right) (A |B)C ≡ A |BC (par app left) F (A |B) ≡ A |FB (par app right) (A |B);C ≡ A |B;C (par sandbox left) F ; (A |B) ≡ F ;A |F ;B (par s</context>
</contexts>
<marker>[9]</marker>
<rawString>Gérard Berry and Gérard Boudol. The chemical abstract machine. Theoretical Computer Science, 96:217–248, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gerard Boudol</author>
</authors>
<title>The pi-calculus in direct style.</title>
<date>1997</date>
<booktitle>In Conference Record of POPL ’97,</booktitle>
<pages>228--241</pages>
<contexts>
<context position="55877" citStr="[10]" startWordPosition="9582" endWordPosition="9582">g a concurrent assembler. When comparing programs written in the π-calculus with the lambda-calculus it seems like lambda abstractions scale up, whereas sending and receiving messages does not scale well. There are two possible solutions proposed to this problem: we can change the metaphor of communication or we can introduce abstractions as first-class values. The first approach is advocated by the Join-calculus [17]. Communication does not happen between a sender and a receiver, instead a join pattern triggers a process on consumption of several pending messages. The Blue calculus of Boudol [10] changes the receive primitive into a definition which is defined for a scope. By that change, the Blue calculus is more closely related to functions and provides a better notion for higher-order abstraction. Boudol calls it a continuation-passing calculus. The other approach is adopted by Sangiorgi in the HOπ-calculus. Instead of communicating channels or tuples of channels, processes can be communicated as well. Surprisingly, the higher-order case has the same expressive power as the first-order version [44,45]. In the Piccola calculus we take the second approach and reuse existing encodings</context>
</contexts>
<marker>[10]</marker>
<rawString>Gérard Boudol. The pi-calculus in direct style. In Conference Record of POPL ’97, pages 228–241, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rod Burstall</author>
<author>Butler Lampson</author>
</authors>
<title>A kernel language for abstract data types and modules.</title>
<date>1984</date>
<journal>Information and Computation,</journal>
<booktitle>in Proceedings of the International Symposium on Semantics of Data Types, Springer, LNCS</booktitle>
<volume>76</volume>
<issue>2</issue>
<contexts>
<context position="58970" citStr="[11]" startWordPosition="10069" endWordPosition="10069">ment denoted by R. The reader may note that explicit environments subsume records. This is the reason why we call them forms in Piccola instead of just records. Handling the environment as a first-class entity allows us to define concepts like modules, interfaces and implementation for programming in the large within the framework. To our knowledge, the language Pebble of Burstall and Lampson was the first to formally show how to build modules, interfaces and implementation, abstract data types and generics on a typed lambda calculus with bindings, declarations and types as first-class values [11]. 6.6 Other approaches Zenger has developed a component calculus [55] that extends Featherweight Java [22] with primitives to dynamically build, extend and compose software components. The novelty of Zenger’s calculus is that components are composed 32 implicitly on the basis of the type compatibility of component interfaces, rather than by establishing explicit connections. Pahl has developed composition and replacement calculus based on the π- calculus [41]. In this approach, types are used to characterize values that may be passed along ports, and contracts (pre- and post-conditions) are us</context>
</contexts>
<marker>[11]</marker>
<rawString>Rod Burstall and Butler Lampson. A kernel language for abstract data types and modules. Information and Computation, 76(2/3), 1984. Also appeared in Proceedings of the International Symposium on Semantics of Data Types, Springer, LNCS (1984), and as SRC Research Report 1.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Luca Cardelli</author>
<author>John C Mitchell</author>
</authors>
<title>Operations on records.</title>
<date>1993</date>
<booktitle>Theoretical Aspects of Object-Oriented Programming. Types, Semantics and Language Design,</booktitle>
<pages>295--350</pages>
<editor>In Carl A. Gunter and John C. Mitchell, editors,</editor>
<publisher>MIT Press,</publisher>
<contexts>
<context position="57418" citStr="[12,43]" startWordPosition="9815" endWordPosition="9815">Blue calculus studied by Dal-Zilio [14]. In the higher-order π-calculus the evaluation order is orthogonal to the communication semantics [45]. In Piccola, evaluation strategy interferes with communication, therefore we have to fix one for meaningful 31 terms. For Piccola, we define strict evaluation which seems appropriate and more common for concurrent computing. 6.4 Record calculus When modeling components and interfaces, a record-based approach is the obvious choice. We use forms [27,28] as an explicit notion for extensible records. Record calculi are studied in more detail for example in [12,43]. In the λ-calculus with names of Dami [15] arguments to functions are named. The resulting system supports records as arguments instead of tuples as in the classical calculus. The λN -calculus was one of the main inspiration for our work on forms without introspection. An issue omitted in our approach is record typing. It is not clear how far record types with subtyping and the runtime acquisition can be combined. An overview of record typing and the problems involved can be found for example in [12]. 6.5 Explicit environments An explicit environment generalizes the concept of explicit substi</context>
</contexts>
<marker>[12]</marker>
<rawString>Luca Cardelli and John C. Mitchell. Operations on records. In Carl A. Gunter and John C. Mitchell, editors, Theoretical Aspects of Object-Oriented Programming. Types, Semantics and Language Design, pages 295–350. MIT Press, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Charles Consel</author>
<author>Olivier Danvy</author>
</authors>
<title>Tutorial notes on partial evaluation.</title>
<date>1993</date>
<booktitle>In Conference Record of POPL ’93,</booktitle>
<pages>493--501</pages>
<publisher>ACM,</publisher>
<contexts>
<context position="33591" citStr="[8,24,13]" startWordPosition="5720" endWordPosition="5720">o experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to those arguments. In this section we present a partial evaluation algorithm for Piccola [2,47,48]. This algorithm uses the fact that forms are immutable. We replace references to forms by the forms referred to. We can then specialize projections and replace applications of referentially transparent services by their results. However, most services in Piccola are not referentially transparent and cannot be inlined since that would change the order in which side</context>
</contexts>
<marker>[13]</marker>
<rawString>Charles Consel and Olivier Danvy. Tutorial notes on partial evaluation. In Conference Record of POPL ’93, pages 493–501. ACM, January 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Silvano Dal-Zilio</author>
</authors>
<title>Le calcul bleu: types et objects.</title>
<date>1999</date>
<booktitle>Ph.D. thesis, Universite de Nice — Sophia Antipolis,</booktitle>
<note>In french.</note>
<contexts>
<context position="56850" citStr="[14]" startWordPosition="9730" endWordPosition="9730">channels, processes can be communicated as well. Surprisingly, the higher-order case has the same expressive power as the first-order version [44,45]. In the Piccola calculus we take the second approach and reuse existing encodings of functions into the π-calculus as in Pict. The motivation for this comes from the fact that the HOπ-calculus itself can be encoded in the first-order case. 6.3 Asymmetric parallel composition The semantics of asynchronous parallel composition is used in the concurrent object calculus of Gordon and Hankin [19] or the (asymmetric) Blue calculus studied by Dal-Zilio [14]. In the higher-order π-calculus the evaluation order is orthogonal to the communication semantics [45]. In Piccola, evaluation strategy interferes with communication, therefore we have to fix one for meaningful 31 terms. For Piccola, we define strict evaluation which seems appropriate and more common for concurrent computing. 6.4 Record calculus When modeling components and interfaces, a record-based approach is the obvious choice. We use forms [27,28] as an explicit notion for extensible records. Record calculi are studied in more detail for example in [12,43]. In the λ-calculus with names o</context>
</contexts>
<marker>[14]</marker>
<rawString>Silvano Dal-Zilio. Le calcul bleu: types et objects. Ph.D. thesis, Université de Nice — Sophia Antipolis, July 1999. In french.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Laurent Dami</author>
</authors>
<title>Software Composition: Towards an Integration of Functional and Object-Oriented Approaches.</title>
<date>1994</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Geneva,</institution>
<contexts>
<context position="23332" citStr="[15]" startWordPosition="3923" endWordPosition="3923">educe inspect label) A ≡ A′ A′ → B′ B′ ≡ B A→ B (reduce struct) A→ B E [A]→ E [B] (reduce propagate) where labelx = project 7→(;λx.(x;x))·hide 7→hidex ·bind 7→(x7→) and E is an evaluation context defined by the grammar: E ::= [ ] ∣∣ E ·A ∣∣ F · E ∣∣ E ;A ∣∣ F ; E ∣∣ EA ∣∣ FE ∣∣ A|E ∣∣ E|A ∣∣ νc.E 3.5 Encoding Booleans The following toy example actually illustrates many of the principles at stake when we model components with the Piccola calculus. We can encode booleans by services that either project on the labels true or false depending on which boolean value they are supposed to model (cf. [15]). (This same idea is used by the primitive service L to reflect over the bindings and services of a form.) True def = ;λx.(x; true) False def = ;λx.(x; false) 13 Consider now: True(true 7→1 · false 7→2) = (;λx.(x; true))(true 7→1 · false 7→2) →  · x 7→(true 7→1 · false 7→2); (x; true) by reduce beta ≡ ( · x 7→(true 7→1 · false 7→2); x); true by sandbox assoc → (true 7→1 · false 7→2); true by reduce project ≡ (false 7→2 · true 7→1); true by ext bind commute → 1 by reduce project Note how the bindings are swapped to project on true in the last step. A similar reduction would show False(tru</context>
<context position="57461" citStr="[15]" startWordPosition="9823" endWordPosition="9823">e higher-order π-calculus the evaluation order is orthogonal to the communication semantics [45]. In Piccola, evaluation strategy interferes with communication, therefore we have to fix one for meaningful 31 terms. For Piccola, we define strict evaluation which seems appropriate and more common for concurrent computing. 6.4 Record calculus When modeling components and interfaces, a record-based approach is the obvious choice. We use forms [27,28] as an explicit notion for extensible records. Record calculi are studied in more detail for example in [12,43]. In the λ-calculus with names of Dami [15] arguments to functions are named. The resulting system supports records as arguments instead of tuples as in the classical calculus. The λN -calculus was one of the main inspiration for our work on forms without introspection. An issue omitted in our approach is record typing. It is not clear how far record types with subtyping and the runtime acquisition can be combined. An overview of record typing and the problems involved can be found for example in [12]. 6.5 Explicit environments An explicit environment generalizes the concept of explicit substitution [1] by using a record like structure</context>
</contexts>
<marker>[15]</marker>
<rawString>Laurent Dami. Software Composition: Towards an Integration of Functional and Object-Oriented Approaches. Ph.D. thesis, University of Geneva, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Cedric Fournet</author>
<author>Georges Gonthier</author>
</authors>
<title>A hierarchy of equivalences for asynchronous calculi.</title>
<date>1998</date>
<booktitle>In Proceedings of ICALP ’98,</booktitle>
<pages>844--855</pages>
<contexts>
<context position="55029" citStr="[16]" startWordPosition="9456" endWordPosition="9456">ated by various authors in the context of the π-calculus [21,53]. The Pict experiment has shown that the π-calculus is a suitable basis for programming many high-level constructs by encodings [42]. 30 For programming and implementation purposes, synchronous communication seems uncommon and can generally be encoded by using explicit acknowledgments (cf. [21]). Moreover, asynchronous communication has a closer correspondence to distributed computing [54]. Furthermore, in the π-calculus the asynchronous variant has the pleasant property that equivalences are simpler than for the synchronous case [16]. Input-guarded choice can be encoded and is fully abstract [34]. For these reasons we adopt asynchronous channels in the Piccola calculus. 6.2 Higher-order abstractions Programming directly in the π-calculus is often considered like programming a concurrent assembler. When comparing programs written in the π-calculus with the lambda-calculus it seems like lambda abstractions scale up, whereas sending and receiving messages does not scale well. There are two possible solutions proposed to this problem: we can change the metaphor of communication or we can introduce abstractions as first-class </context>
</contexts>
<marker>[16]</marker>
<rawString>Cédric Fournet and Georges Gonthier. A hierarchy of equivalences for asynchronous calculi. In Proceedings of ICALP ’98, pages 844–855, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Cedric Fournet</author>
<author>Georges Gonthier</author>
<author>Jean-Jacques Levy</author>
<author>Luc Maranget</author>
<author>Didier Remy</author>
</authors>
<title>A calculus of mobile agents.</title>
<date>1996</date>
<booktitle>In Proceedings of the 7th International Conference on Concurrency Theory (CONCUR ’96),</booktitle>
<volume>1119</volume>
<pages>406--421</pages>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="55694" citStr="[17]" startWordPosition="9553" endWordPosition="9553">34]. For these reasons we adopt asynchronous channels in the Piccola calculus. 6.2 Higher-order abstractions Programming directly in the π-calculus is often considered like programming a concurrent assembler. When comparing programs written in the π-calculus with the lambda-calculus it seems like lambda abstractions scale up, whereas sending and receiving messages does not scale well. There are two possible solutions proposed to this problem: we can change the metaphor of communication or we can introduce abstractions as first-class values. The first approach is advocated by the Join-calculus [17]. Communication does not happen between a sender and a receiver, instead a join pattern triggers a process on consumption of several pending messages. The Blue calculus of Boudol [10] changes the receive primitive into a definition which is defined for a scope. By that change, the Blue calculus is more closely related to functions and provides a better notion for higher-order abstraction. Boudol calls it a continuation-passing calculus. The other approach is adopted by Sangiorgi in the HOπ-calculus. Instead of communicating channels or tuples of channels, processes can be communicated as well.</context>
</contexts>
<marker>[17]</marker>
<rawString>Cédric Fournet, Georges Gonthier, Jean-Jacques Lévy, Luc Maranget, and Didier Rémy. A calculus of mobile agents. In Proceedings of the 7th International Conference on Concurrency Theory (CONCUR ’96), volume 1119 of LNCS, pages 406–421. Springer-Verlag, August 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Garlan</author>
<author>Robert Allen</author>
<author>John Ockerbloom</author>
</authors>
<title>Architectural mismatch: Why reuse is so hard.</title>
<date>1995</date>
<journal>IEEE Software,</journal>
<volume>12</volume>
<issue>6</issue>
<contexts>
<context position="5047" citStr="[18]" startWordPosition="739" endWordPosition="739">bras Glue • generic wrappers • component packaging • generic adaptors Coordination • coordination abstractions Scripts • sandboxes • composition expressions • context-dependent policies Fig. 1. How Piccola supports composition that is, component-based applications are (ideally) made up of stable, off-theshelf components, and scripts that plug them together [6]. Scripts (ideally) make use of high-level connectors that coordinate the services of various components [3,36,52]. Furthermore, complex applications may need services of components that depend on very different architectural assumptions [18]. In these cases, glue code is needed to adapt components to different architectural styles [50,51]. A foundation for modeling software components must therefore be suitable for expressing compositional styles, scripts, coordination abstractions and glue code. Figure 1 summarizes the requirements, and illustrates how Piccola and the Piccola calculus support them. 2.1 Compositional Styles A compositional style allows us to express the structure of a software application in terms of components, connectors and rules governing their composition (cf. “architectural style” [52]). The following list </context>
</contexts>
<marker>[18]</marker>
<rawString>David Garlan, Robert Allen, and John Ockerbloom. Architectural mismatch: Why reuse is so hard. IEEE Software, 12(6):17–26, November 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andrew D Gordon</author>
<author>Paul D Hankin</author>
</authors>
<title>A concurrent object calculus: Reduction and typing.</title>
<date>1998</date>
<booktitle>In Proceedings HLCL ’98. Elsevier ENTCS,</booktitle>
<contexts>
<context position="56790" citStr="[19]" startWordPosition="9721" endWordPosition="9721">Oπ-calculus. Instead of communicating channels or tuples of channels, processes can be communicated as well. Surprisingly, the higher-order case has the same expressive power as the first-order version [44,45]. In the Piccola calculus we take the second approach and reuse existing encodings of functions into the π-calculus as in Pict. The motivation for this comes from the fact that the HOπ-calculus itself can be encoded in the first-order case. 6.3 Asymmetric parallel composition The semantics of asynchronous parallel composition is used in the concurrent object calculus of Gordon and Hankin [19] or the (asymmetric) Blue calculus studied by Dal-Zilio [14]. In the higher-order π-calculus the evaluation order is orthogonal to the communication semantics [45]. In Piccola, evaluation strategy interferes with communication, therefore we have to fix one for meaningful 31 terms. For Piccola, we define strict evaluation which seems appropriate and more common for concurrent computing. 6.4 Record calculus When modeling components and interfaces, a record-based approach is the obvious choice. We use forms [27,28] as an explicit notion for extensible records. Record calculi are studied in more d</context>
</contexts>
<marker>[19]</marker>
<rawString>Andrew D. Gordon and Paul D. Hankin. A concurrent object calculus: Reduction and typing. In Proceedings HLCL ’98. Elsevier ENTCS, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Roger Hindley</author>
<author>Jonathan P Seldin</author>
</authors>
<title>Introduction to Combinatory Logic and Lambda Calculus.</title>
<date>1986</date>
<publisher>Cambridge University Press,</publisher>
<contexts>
<context position="42454" citStr="[20]" startWordPosition="7237" endWordPosition="7237">set of labels of any application or projection is empty. The expression Q[x/R] denotes the expression Q where all free x are replaced by R. Substitution is defined in Table 10. Note that there is no special definition for the side-effect y 7→R1R2. This case is defined by the binding and by the application, thus (y 7→R1R2)[x/R] = y 7→(R1R2)[x/R] = R1[x/R] R2[x/R]. Note that R[x/R]′ ∈ R and P [x/R] ∈ P . This means that a substitution on a lazy form denotes a lazy form, and a substitution on a side-effect term denotes a side-effect term. As usual we replace bound variables to avoid name capture [20]. The helper predicate project : (R × L) → Q denotes the value bound by a label (Table 11). If the projection can be performed at specialize time, we do the actual lookup. If the value of the projection is not known, an uneval23 Table 10 Substitution [x/R] =  (P ·Q)[x/R] = P [x/R] ·Q[x/R] x[x/R] = R y[x/R] = y where x 6= y (y 7→Q)[x/R] = y 7→Q[x/R] (R1R2)[x/R] = R1[x/R] R2[x/R] side(A)[x/R] = side(A) (λx.P ? R1)[x/R] = λx.P ? R1 (λy.P ? R1)[x/R] = λy.P [x/R] ? R1[x/R] where x 6= y, and y 6∈ fv(R) or x 6∈ fv(P,R1) (λy.P ? R1)[x/R] = λz.P [x/z][x/R] ? R1[x/z][x/R] where x 6= y and y ∈ fv(R) an</context>
</contexts>
<marker>[20]</marker>
<rawString>J. Roger Hindley and Jonathan P. Seldin. Introduction to Combinatory Logic and Lambda Calculus. Cambridge University Press, 1986.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kohei Honda</author>
<author>Mario Tokoro</author>
</authors>
<title>An object calculus for asynchronous communication.</title>
<date>1991</date>
<booktitle>Proceedings ECOOP ’91,</booktitle>
<volume>512</volume>
<pages>133--147</pages>
<editor>In Pierre America, editor,</editor>
<publisher>Springer-Verlag.</publisher>
<location>Geneva, Switzerland,</location>
<contexts>
<context position="54489" citStr="[21,53]" startWordPosition="9381" endWordPosition="9381"> are referentially transparent. If split(A,R) = (P,R) then combine ′(P ) ` embed(R) [2]. 6 Related Work The Piccola calculus extends the asynchronous π-calculus with higher-order abstractions and first-class environments. 6.1 π-calculus The π-calculus [32] is a calculus of communicating systems in which one can naturally express processes with a changing structure. Its theory has been thoroughly studied and many results relate other formalisms or implementations to it. The affinity between objects and processes, for example, has been treated by various authors in the context of the π-calculus [21,53]. The Pict experiment has shown that the π-calculus is a suitable basis for programming many high-level constructs by encodings [42]. 30 For programming and implementation purposes, synchronous communication seems uncommon and can generally be encoded by using explicit acknowledgments (cf. [21]). Moreover, asynchronous communication has a closer correspondence to distributed computing [54]. Furthermore, in the π-calculus the asynchronous variant has the pleasant property that equivalences are simpler than for the synchronous case [16]. Input-guarded choice can be encoded and is fully abstract </context>
</contexts>
<marker>[21]</marker>
<rawString>Kohei Honda and Mario Tokoro. An object calculus for asynchronous communication. In Pierre America, editor, Proceedings ECOOP ’91, volume 512 of LNCS, pages 133–147, Geneva, Switzerland, July 1991. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Atsushi Igarashi</author>
<author>Benjamin C Pierce</author>
<author>Philip Wadler</author>
</authors>
<title>Featherweight Java: a minimal core calculus for Java and GJ.</title>
<date>2001</date>
<journal>ACM TOPLAS,</journal>
<volume>23</volume>
<issue>3</issue>
<contexts>
<context position="59076" citStr="[22]" startWordPosition="10084" endWordPosition="10084">we call them forms in Piccola instead of just records. Handling the environment as a first-class entity allows us to define concepts like modules, interfaces and implementation for programming in the large within the framework. To our knowledge, the language Pebble of Burstall and Lampson was the first to formally show how to build modules, interfaces and implementation, abstract data types and generics on a typed lambda calculus with bindings, declarations and types as first-class values [11]. 6.6 Other approaches Zenger has developed a component calculus [55] that extends Featherweight Java [22] with primitives to dynamically build, extend and compose software components. The novelty of Zenger’s calculus is that components are composed 32 implicitly on the basis of the type compatibility of component interfaces, rather than by establishing explicit connections. Pahl has developed composition and replacement calculus based on the π- calculus [41]. In this approach, types are used to characterize values that may be passed along ports, and contracts (pre- and post-conditions) are used to determine whether provided and required services match. The calculus is used to reason about when co</context>
</contexts>
<marker>[22]</marker>
<rawString>Atsushi Igarashi, Benjamin C. Pierce, and Philip Wadler. Featherweight Java: a minimal core calculus for Java and GJ. ACM TOPLAS, 23(3):396–450, May 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dan Ingalls</author>
<author>Ted Kaehler</author>
<author>John Maloney</author>
<author>Scott Wallace</author>
<author>Alan Kay</author>
</authors>
<title>Back to the future: The story of Squeak, A practical Smalltalk written in itself.</title>
<date>1997</date>
<booktitle>In Proceedings OOPSLA ’97,</booktitle>
<pages>318--326</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="40004" citStr="[23]" startWordPosition="6787" endWordPosition="6787"> transparent result R. Side-effect services are arbitrary agents A. Partial evaluation does not specialize them. The primitive services new, run, and L are side-effect services. Side-effect terms contain applications and projections that may fail. Side-effect terms have a specific structure. Atomic side-effects are bound by unique labels. Side-effect terms can be nested and sequentially composed. In P1 ·P2 we may refer to side-effects of P1 from P2. This algorithm has been used extensively in the implementation of SPiccola [47,48], an implementation of Piccola for components written in Squeak [23], an open-source Smalltalk. 5.2 The Algorithm We now present and discuss the functions split and combine in detail. We assume that · is associative and  is the neutral element. This allows us to reduce the number of defining equations. For instance, when defining projection in Table 11 we write project(R ·x 7→R1, x) = R1 assuming that we can rewrite any form with several bindings into a form extended with a single binding. 22 Table 9 Free variables and defined labels fv() = ∅ fv(x) = {x} fv(R1R2) = fv(R1) ∪ fv(R2) fv(R.x) = fv(R) fv(Q1 ·Q2) = fv(Q1) ∪ fv(Q2) fv(x7→Q) = fv(Q) fv(λx.P ? R) = (</context>
</contexts>
<marker>[23]</marker>
<rawString>Dan Ingalls, Ted Kaehler, John Maloney, Scott Wallace, and Alan Kay. Back to the future: The story of Squeak, A practical Smalltalk written in itself. In Proceedings OOPSLA ’97, pages 318–326. ACM Press, November 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Neil J Jones</author>
<author>Carsten K Gomard</author>
<author>Peter Sestoft</author>
</authors>
<title>Partial Evaluation and Automatic Program Generation.</title>
<date>1993</date>
<publisher>Prentice-Hall,</publisher>
<contexts>
<context position="33591" citStr="[8,24,13]" startWordPosition="5720" endWordPosition="5720">o experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to those arguments. In this section we present a partial evaluation algorithm for Piccola [2,47,48]. This algorithm uses the fact that forms are immutable. We replace references to forms by the forms referred to. We can then specialize projections and replace applications of referentially transparent services by their results. However, most services in Piccola are not referentially transparent and cannot be inlined since that would change the order in which side</context>
</contexts>
<marker>[24]</marker>
<rawString>Neil J. Jones, Carsten K. Gomard, and Peter Sestoft. Partial Evaluation and Automatic Program Generation. Prentice-Hall, 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan Kneubuhl</author>
</authors>
<title>Implementing coordination styles in piccola.</title>
<date>2001</date>
<institution>Informatikprojekt, University of Bern,</institution>
<contexts>
<context position="33128" citStr="[25]" startWordPosition="5652" endWordPosition="5652">]. 18 The first three layers constitute the standard Piccola distribution. The fourth layer is provided by the component framework designer. At this level, a domain expert encodes a compositional styles as a library of components, connectors, adaptors, coordination abstractions, and so on. Finally, at the top level, an application programmer may script together components using the abstractions provided by the lower layers [3,36]. Piccola has been used to experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to </context>
</contexts>
<marker>[25]</marker>
<rawString>Stefan Kneubühl. Implementing coordination styles in piccola. Informatikprojekt, University of Bern, February 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stefan Kneubuhl</author>
</authors>
<title>Typeful compositional styles. Diploma thesis,</title>
<date>2003</date>
<institution>University of Bern,</institution>
<marker>[26]</marker>
<rawString>Stefan Kneubühl. Typeful compositional styles. Diploma thesis, University of Bern, April 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Markus Lumpe</author>
</authors>
<title>A Pi-Calculus Based Approach to Software Composition.</title>
<date>1999</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Bern, Institute of Computer Science and Applied Mathematics,</institution>
<contexts>
<context position="57307" citStr="[27,28]" startWordPosition="9797" endWordPosition="9797">s parallel composition is used in the concurrent object calculus of Gordon and Hankin [19] or the (asymmetric) Blue calculus studied by Dal-Zilio [14]. In the higher-order π-calculus the evaluation order is orthogonal to the communication semantics [45]. In Piccola, evaluation strategy interferes with communication, therefore we have to fix one for meaningful 31 terms. For Piccola, we define strict evaluation which seems appropriate and more common for concurrent computing. 6.4 Record calculus When modeling components and interfaces, a record-based approach is the obvious choice. We use forms [27,28] as an explicit notion for extensible records. Record calculi are studied in more detail for example in [12,43]. In the λ-calculus with names of Dami [15] arguments to functions are named. The resulting system supports records as arguments instead of tuples as in the classical calculus. The λN -calculus was one of the main inspiration for our work on forms without introspection. An issue omitted in our approach is record typing. It is not clear how far record types with subtyping and the runtime acquisition can be combined. An overview of record typing and the problems involved can be found fo</context>
<context position="60549" citStr="[27,28]" startWordPosition="10315" endWordPosition="10315">connectors can be composed using the Reo operators to build higher-level connectors. In contrast to process calculi, Reo is well-suited to compositional reasoning, since connectors can be composed to yield new connectors, and properties of connectors can be shown to compose. Data communicated along streams are uninterpreted in Reo, so it would be natural to explore the application of Reo to streams of forms. 6.7 Precursors to the Piccola calculus In our earlier work on the foundations of Piccola, we specified the semantics of Piccola in terms of translations to πL (the π calculus with labels) [27,28] or to the form calculus [50]. The difference between πL and the form calculus is that the latter allows hiding of labels and forms and it contains a testing primitive for labels. The Piccola calculus is better suited to give a direct semantics to the Piccola language. The enhanced expressiveness of the Piccola calculus with respect to the form- and the πL-calculus are as follows: • Form extension. In πL and the form calculus we have separate primitives to extend a form with either a single binding or a separate form. In the Piccola calculus there is a single extension operator · for asymmetri</context>
</contexts>
<marker>[27]</marker>
<rawString>Markus Lumpe. A Pi-Calculus Based Approach to Software Composition. Ph.D. thesis, University of Bern, Institute of Computer Science and Applied Mathematics, January 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Markus Lumpe</author>
</authors>
<title>Franz Achermann, and Oscar Nierstrasz. A Formal Language for Composition.</title>
<date>2000</date>
<booktitle>In Gary Leavens and Murali Sitaraman, editors, Foundations of Component Based Systems,</booktitle>
<pages>69--90</pages>
<publisher>Cambridge University Press,</publisher>
<contexts>
<context position="57307" citStr="[27,28]" startWordPosition="9797" endWordPosition="9797">s parallel composition is used in the concurrent object calculus of Gordon and Hankin [19] or the (asymmetric) Blue calculus studied by Dal-Zilio [14]. In the higher-order π-calculus the evaluation order is orthogonal to the communication semantics [45]. In Piccola, evaluation strategy interferes with communication, therefore we have to fix one for meaningful 31 terms. For Piccola, we define strict evaluation which seems appropriate and more common for concurrent computing. 6.4 Record calculus When modeling components and interfaces, a record-based approach is the obvious choice. We use forms [27,28] as an explicit notion for extensible records. Record calculi are studied in more detail for example in [12,43]. In the λ-calculus with names of Dami [15] arguments to functions are named. The resulting system supports records as arguments instead of tuples as in the classical calculus. The λN -calculus was one of the main inspiration for our work on forms without introspection. An issue omitted in our approach is record typing. It is not clear how far record types with subtyping and the runtime acquisition can be combined. An overview of record typing and the problems involved can be found fo</context>
<context position="60549" citStr="[27,28]" startWordPosition="10315" endWordPosition="10315">connectors can be composed using the Reo operators to build higher-level connectors. In contrast to process calculi, Reo is well-suited to compositional reasoning, since connectors can be composed to yield new connectors, and properties of connectors can be shown to compose. Data communicated along streams are uninterpreted in Reo, so it would be natural to explore the application of Reo to streams of forms. 6.7 Precursors to the Piccola calculus In our earlier work on the foundations of Piccola, we specified the semantics of Piccola in terms of translations to πL (the π calculus with labels) [27,28] or to the form calculus [50]. The difference between πL and the form calculus is that the latter allows hiding of labels and forms and it contains a testing primitive for labels. The Piccola calculus is better suited to give a direct semantics to the Piccola language. The enhanced expressiveness of the Piccola calculus with respect to the form- and the πL-calculus are as follows: • Form extension. In πL and the form calculus we have separate primitives to extend a form with either a single binding or a separate form. In the Piccola calculus there is a single extension operator · for asymmetri</context>
</contexts>
<marker>[28]</marker>
<rawString>Markus Lumpe, Franz Achermann, and Oscar Nierstrasz. A Formal Language for Composition. In Gary Leavens and Murali Sitaraman, editors, Foundations of Component Based Systems, pages 69–90. Cambridge University Press, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mark Lutz</author>
</authors>
<title>Programming Python. O’Reilly &amp;</title>
<date>1996</date>
<publisher>Associates, Inc.,</publisher>
<contexts>
<context position="24176" citStr="[29]" startWordPosition="4087" endWordPosition="4087">e 7→2) →  · x 7→(true 7→1 · false 7→2); (x; true) by reduce beta ≡ ( · x 7→(true 7→1 · false 7→2); x); true by sandbox assoc → (true 7→1 · false 7→2); true by reduce project ≡ (false 7→2 · true 7→1); true by ext bind commute → 1 by reduce project Note how the bindings are swapped to project on true in the last step. A similar reduction would show False(true 7→1 · false 7→2)⇒ 2. A key point is that a form may provide additional bindings that a client may ignore if it does not require them (cf. [15]). This same principle is applied to good effect in various scripting languages, such as Python [29]. For instance we can use True and provide an additional binding notused 7→F for arbitrary form F : True(true 7→1 · false 7→2 · notused 7→F ) ⇒ (true 7→1 · false 7→2 · notused 7→F ); true ≡ (false 7→2 · true 7→1 · notused 7→F ); true by ext bind commute ≡ (false 7→2 · notused 7→F · true 7→1); true by ext bind commute → 1 by reduce project Extending forms can also be used to overwrite existing bindings. For instance instead of binding the variable notused a client may override true: True(true 7→1 · false 7→2 · true 7→3)⇒ 3 A conditional expression is encoded as a curried service that takes a bo</context>
</contexts>
<marker>[29]</marker>
<rawString>Mark Lutz. Programming Python. O’Reilly &amp; Associates, Inc., 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Massimo Merro</author>
<author>Davide Sangiorgi</author>
</authors>
<title>On asynchrony in name-passing calculi.</title>
<date></date>
<booktitle>25th Colloquium on Automata, Languages and Programming (ICALP)</booktitle>
<volume>1443</volume>
<pages>856--867</pages>
<editor>In Kim G. Larsen, Sven Skyum, and GlynnWinskel, editors,</editor>
<publisher>Springer-Verlag,</publisher>
<location>Aalborg,</location>
<contexts>
<context position="29260" citStr="[30,45]" startWordPosition="5063" endWordPosition="5063"> F ;R ≡ F . Note that if an agent is stuck it is not a preform: F≡ ∩ {A|A↑} = ∅ by definition. Although 0 is arguably stuck by intention, in general a stuck agent can be interpreted as an error. The two typical cases which may lead to errors are (i) projection on an unbound label, e.g., ;x, and (ii) application of a non-service, e.g., . 3.8 π-Calculus Encoding One may well ask what exactly the Piccola calculus adds over and above the asynchronous π-calculus. We have previously shown that the Piccola calculus can be faithfully embedded into the localized π-calculus Lπ of Merro and Sangiorgi [30,45]. The mapping [[]]a encodes Piccola calculus agents as π-calculus processes. The process [[A]]a evaluates A in the environment given by the empty form, and sends the resulting value along the channel a. A form (value) is encoded as a 4- tuple of channels representing projection, invocation, hiding and selection. The main result is that the encoding is sound and preserves reductions. We do not require a fully abstract encoding since that would mean that equivalent Piccola calculus agents translated into the π-calculus could not be distinguished by any π-processes. Our milder requirement means t</context>
</contexts>
<marker>[30]</marker>
<rawString>Massimo Merro and Davide Sangiorgi. On asynchrony in name-passing calculi. In Kim G. Larsen, Sven Skyum, and GlynnWinskel, editors, 25th Colloquium on Automata, Languages and Programming (ICALP) (Aalborg, Denmark), volume 1443 of LNCS, pages 856–867. Springer-Verlag, July 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wolfgang De Meuter</author>
</authors>
<title>Agora: The story of the simplest MOP in the world — or — the scheme of object–orientation.</title>
<date>1998</date>
<editor>In J. Noble, I. Moore, and A. Taivalsaari, editors, Prototype-based Programming.</editor>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="33399" citStr="[31]" startWordPosition="5691" endWordPosition="5691">actions, and so on. Finally, at the top level, an application programmer may script together components using the abstractions provided by the lower layers [3,36]. Piccola has been used to experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to those arguments. In this section we present a partial evaluation algorithm for Piccola [2,47,48]. This algorithm uses the fact that forms are immutable. We replace references to forms by the forms referred to. We can then specialize projections and replace applications o</context>
</contexts>
<marker>[31]</marker>
<rawString>Wolfgang De Meuter. Agora: The story of the simplest MOP in the world — or — the scheme of object–orientation. In J. Noble, I. Moore, and A. Taivalsaari, editors, Prototype-based Programming. Springer-Verlag, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robin Milner</author>
<author>Joachim Parrow</author>
<author>David Walker</author>
</authors>
<title>A calculus of mobile processes, part I/II.</title>
<date>1992</date>
<journal>Information and Computation,</journal>
<volume>100</volume>
<contexts>
<context position="3095" citStr="[32,45]" startWordPosition="443" endWordPosition="443">n can be expressed. We therefore need a semantic foundation for specifying compositional abstractions. Components may be configured and adapted in many different ways, which may or may not have an impact on the resulting composition. We therefore also need to reason about equivalence of different expressions of composition. Drawing from our experience modeling various component models, we have developed the Piccola calculus as a tool for expressing the semantics of software composition and for reasoning about equivalence of compositions. The Piccola calculus extends the asychronous π-calculus [32,45] with forms—firstclass, extensible namespaces [5]. Forms are not only convenient for expressing components, but play other important roles as well. This calculus serves both as the semantic target and as an executable abstract machine for Piccola. In this paper we first motivate the calculus by establishing a set of requirements for modeling composition of software components in section 2. Next, we address these requirements by presenting the syntax and semantics of the Piccola calculus in section 3. In section 4 we provide a brief overview of the Piccola language, and summarize how the calcul</context>
<context position="11685" citStr="[32,45]" startWordPosition="1737" endWordPosition="1737">e able to express coordination of interdependent tasks. • Coordination abstractions: Both connectors and glue code may need to express coordination of concurrent activities. Consider a readers/writers synchronization policy as a generic wrapper. We conclude that we not only need higher-order functions over first-class namespaces (with introspection), but also a way of expressing concurrency and communication [50]. 3 The Piccola calculus As a consequence of the requirements we have identified above, we propose as a foundation a process calculus based on the higher-order asynchronous π-calculus [32,45] in which tuple-based communication is replaced by communication of extensible records, or forms [5,37]. Furthermore, forms serve as first-class namespaces and support a simple kind of introspection. The design of the Piccola calculus strikes a balance between minimalism and expressiveness. As a calculus it is rather large. In fact, it would be possible to express everything we want with the π-calculus alone, but the semantic gap between concepts we wish to model and the terms of the calculus would be 6 Table 1 Syntax of the Piccola calculus A,B,C ::=  empty form |R current root |A;B sandbox </context>
<context position="54138" citStr="[32]" startWordPosition="9326" endWordPosition="9326">l in the above definition is important. It is not enough to find an equivalent G just for some possible reductions. For instance c(x 7→) |c() |c?; x→ c() |x 7→();x ≈ c() | But c(x 7→) |c() |c? 6` x. Obviously, all forms are referentially transparent, thus ` F for any form F . We can prove by induction on A that split(A,R) generates tuples that are referentially transparent. If split(A,R) = (P,R) then combine ′(P ) ` embed(R) [2]. 6 Related Work The Piccola calculus extends the asynchronous π-calculus with higher-order abstractions and first-class environments. 6.1 π-calculus The π-calculus [32] is a calculus of communicating systems in which one can naturally express processes with a changing structure. Its theory has been thoroughly studied and many results relate other formalisms or implementations to it. The affinity between objects and processes, for example, has been treated by various authors in the context of the π-calculus [21,53]. The Pict experiment has shown that the π-calculus is a suitable basis for programming many high-level constructs by encodings [42]. 30 For programming and implementation purposes, synchronous communication seems uncommon and can generally be encod</context>
</contexts>
<marker>[32]</marker>
<rawString>Robin Milner, Joachim Parrow, and David Walker. A calculus of mobile processes, part I/II. Information and Computation, 100:1–77, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robin Milner</author>
<author>Davide Sangiorgi</author>
</authors>
<title>Barbed bisimulation.</title>
<date>1992</date>
<booktitle>In Proceedings ICALP ’92,</booktitle>
<volume>623</volume>
<pages>685--695</pages>
<publisher>SpringerVerlag.</publisher>
<location>Vienna,</location>
<contexts>
<context position="25788" citStr="[33]" startWordPosition="4384" endWordPosition="4384">hen and else. We can relax this contract and provide default services if those bindings are not provided by the client. To do so, we replace in the definition of if the sandbox expression v; else with a default service. This service gets triggered when the case form does not contain an else binding: ifd def = ;λuv.u(true 7→(v; then) · false 7→(else 7→(λx.) · v; else)) Now ifd False (then 7→(F ;λx.A))⇒ . 3.6 Equivalence for Agents Two agents are equivalent if they exhibit the same behaviour, i.e., they enjoy the same reductions. We adopt Milner and Sangiorgi’s notion of barbed bisimulation [33]. The idea is that an agent A is barbed similar to B if A can exhibit any reduction that B does and if B is a barb, then A is a barb, too. If A and B are similar to each other they are bisimilar. The advantage of this bisimulation is that it can readily be given for any calculus that contains barbs or values. For the asynchronous π-calculus, barbs are usually defined as having the capability of doing an output on a channel. A Piccola calculus agent reduces to a barb, i.e., it returns a form. During evaluation the agent may spawn off new subthreads which could be blocked or still be running. We</context>
</contexts>
<marker>[33]</marker>
<rawString>Robin Milner and Davide Sangiorgi. Barbed bisimulation. In Proceedings ICALP ’92, volume 623 of LNCS, pages 685–695, Vienna, July 1992. SpringerVerlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Uwe Nestmann</author>
<author>Benjamin C Pierce</author>
</authors>
<title>Decoding choice encodings.</title>
<date>1996</date>
<booktitle>CONCUR ’96: Concurrency Theory, 7th International Conference,</booktitle>
<volume>1119</volume>
<pages>179--194</pages>
<editor>In Ugo Montanari and Vladimiro Sassone, editors,</editor>
<publisher>Springer-Verlag.</publisher>
<location>Pisa, Italy,</location>
<contexts>
<context position="55093" citStr="[34]" startWordPosition="9466" endWordPosition="9466">. The Pict experiment has shown that the π-calculus is a suitable basis for programming many high-level constructs by encodings [42]. 30 For programming and implementation purposes, synchronous communication seems uncommon and can generally be encoded by using explicit acknowledgments (cf. [21]). Moreover, asynchronous communication has a closer correspondence to distributed computing [54]. Furthermore, in the π-calculus the asynchronous variant has the pleasant property that equivalences are simpler than for the synchronous case [16]. Input-guarded choice can be encoded and is fully abstract [34]. For these reasons we adopt asynchronous channels in the Piccola calculus. 6.2 Higher-order abstractions Programming directly in the π-calculus is often considered like programming a concurrent assembler. When comparing programs written in the π-calculus with the lambda-calculus it seems like lambda abstractions scale up, whereas sending and receiving messages does not scale well. There are two possible solutions proposed to this problem: we can change the metaphor of communication or we can introduce abstractions as first-class values. The first approach is advocated by the Join-calculus [17</context>
</contexts>
<marker>[34]</marker>
<rawString>Uwe Nestmann and Benjamin C. Pierce. Decoding choice encodings. In Ugo Montanari and Vladimiro Sassone, editors, CONCUR ’96: Concurrency Theory, 7th International Conference, volume 1119 of LNCS, pages 179–194, Pisa, Italy, August 1996. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oscar Nierstrasz</author>
</authors>
<title>Contractual types.</title>
<date>2003</date>
<tech>Technical Report IAM-03-004,</tech>
<institution>Institut fur Informatik, Universitat Bern,</institution>
<marker>[35]</marker>
<rawString>Oscar Nierstrasz. Contractual types. Technical Report IAM-03-004, Institut für Informatik, Universität Bern, Switzerland, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oscar Nierstrasz</author>
<author>Franz Achermann</author>
</authors>
<title>Supporting Compositional Styles for Software Evolution.</title>
<date>2000</date>
<booktitle>In Proceedings International Symposium on Principles of Software Evolution (ISPSE</booktitle>
<pages>11--19</pages>
<publisher>IEEE.</publisher>
<location>Kanazawa, Japan,</location>
<contexts>
<context position="4919" citStr="[3,36,52]" startWordPosition="723" endWordPosition="723">s Styles • primitive neutral object model • meta-objects • HO plugs &amp; connectors • default arguments • encapsulation • component algebras Glue • generic wrappers • component packaging • generic adaptors Coordination • coordination abstractions Scripts • sandboxes • composition expressions • context-dependent policies Fig. 1. How Piccola supports composition that is, component-based applications are (ideally) made up of stable, off-theshelf components, and scripts that plug them together [6]. Scripts (ideally) make use of high-level connectors that coordinate the services of various components [3,36,52]. Furthermore, complex applications may need services of components that depend on very different architectural assumptions [18]. In these cases, glue code is needed to adapt components to different architectural styles [50,51]. A foundation for modeling software components must therefore be suitable for expressing compositional styles, scripts, coordination abstractions and glue code. Figure 1 summarizes the requirements, and illustrates how Piccola and the Piccola calculus support them. 2.1 Compositional Styles A compositional style allows us to express the structure of a software applicatio</context>
<context position="32957" citStr="[3,36]" startWordPosition="5627" endWordPosition="5627"> These, however, are provided as standard services implemented in Piccola. Exceptions and try-catch clauses are implemented using agents, channels, and dynamic namespaces [5]. 18 The first three layers constitute the standard Piccola distribution. The fourth layer is provided by the component framework designer. At this level, a domain expert encodes a compositional styles as a library of components, connectors, adaptors, coordination abstractions, and so on. Finally, at the top level, an application programmer may script together components using the abstractions provided by the lower layers [3,36]. Piccola has been used to experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly ineffic</context>
</contexts>
<marker>[36]</marker>
<rawString>Oscar Nierstrasz and Franz Achermann. Supporting Compositional Styles for Software Evolution. In Proceedings International Symposium on Principles of Software Evolution (ISPSE 2000), pages 11–19, Kanazawa, Japan, November 2000. IEEE.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oscar Nierstrasz</author>
<author>Franz Achermann</author>
</authors>
<title>A calculus for modeling software components.</title>
<date>2003</date>
<booktitle>In FMCO 2002 Proceedings,</booktitle>
<volume>2852</volume>
<pages>339--360</pages>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="11788" citStr="[5,37]" startWordPosition="1752" endWordPosition="1752"> glue code may need to express coordination of concurrent activities. Consider a readers/writers synchronization policy as a generic wrapper. We conclude that we not only need higher-order functions over first-class namespaces (with introspection), but also a way of expressing concurrency and communication [50]. 3 The Piccola calculus As a consequence of the requirements we have identified above, we propose as a foundation a process calculus based on the higher-order asynchronous π-calculus [32,45] in which tuple-based communication is replaced by communication of extensible records, or forms [5,37]. Furthermore, forms serve as first-class namespaces and support a simple kind of introspection. The design of the Piccola calculus strikes a balance between minimalism and expressiveness. As a calculus it is rather large. In fact, it would be possible to express everything we want with the π-calculus alone, but the semantic gap between concepts we wish to model and the terms of the calculus would be 6 Table 1 Syntax of the Piccola calculus A,B,C ::=  empty form |R current root |A;B sandbox |x variable |x7→ bind |hidex hide |L inspect |A ·B extension |λx.A abstraction |AB application |νc.A re</context>
</contexts>
<marker>[37]</marker>
<rawString>Oscar Nierstrasz and Franz Achermann. A calculus for modeling software components. In FMCO 2002 Proceedings, volume 2852 of LNCS, pages 339–360. Springer-Verlag, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oscar Nierstrasz</author>
<author>Franz Achermann</author>
<author>Stefan Kneubuhl</author>
</authors>
<title>A guide to JPiccola.</title>
<date>2003</date>
<tech>Technical Report IAM-03-003,</tech>
<institution>Institut fur Informatik, Universitat Bern, Switzerland,</institution>
<contexts>
<context position="2168" citStr="[38]" startWordPosition="304" endWordPosition="304">on? How do we specify the way in which components are configured and composed? Preprint submitted to Elsevier Science 31 March 2005 In addition to components, we clearly need some means to specify compositions of components. A composition language [39] is a language for specifying operators for connecting components (i.e., “connectors”), glue abstractions for adapting component interfaces, and scripts that instantiate and connect components. Piccola [4,6] is a prototype for such a composition language, and JPiccola is an implementation which targets the composition of Java software components [38]. A key challenge for a composition language is to offer a means to answer the question, What, precisely, do we mean by composition? There are many different notions of component composition and interconnection in practice, so a composition language must offer a neutral foundation in which different forms of composition can be expressed. We therefore need a semantic foundation for specifying compositional abstractions. Components may be configured and adapted in many different ways, which may or may not have an impact on the resulting composition. We therefore also need to reason about equival</context>
<context position="8027" citStr="[38]" startWordPosition="1173" endWordPosition="1173"> service, we just apply it to a record which bundles together all the required arguments, and possibly some optional ones. These same records can serve as first-class namespaces which encapsulate the plugs and connectors of a given style. (A namespace is simply a scope within which certain definitions are visible.) For this reason we unify records and namespaces, and call them “forms”, to emphasize their special role. A “form” is essentially a nested record, which binds labels to values. Let us consider the following script written in JPiccola, an implementation of Piccola for Java components [38]: makeFrame title = &amp;quot;AWT Demo&amp;quot; x = 200 y = 100 hello = &amp;quot;hello world&amp;quot; sayHello: println hello component = Button.new(text=hello) ? ActionPerformed sayHello This script invokes an abstraction makeFrame, passing it a form containing bindings for the labels title, x, and so on. The script makes use of a compositional style in which GUI components (i.e., the Button) can be bound to events (i.e., ActionPerformed) and actions (i.e., sayHello) by means of the 4 Fig. 2. Evaluating the helloButton script ? connector. When we evaluate this code, it generates the button we see in Figure 2. When we click o</context>
<context position="33270" citStr="[38]" startWordPosition="5672" endWordPosition="5672">t this level, a domain expert encodes a compositional styles as a library of components, connectors, adaptors, coordination abstractions, and so on. Finally, at the top level, an application programmer may script together components using the abstractions provided by the lower layers [3,36]. Piccola has been used to experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to those arguments. In this section we present a partial evaluation algorithm for Piccola [2,47,48]. This algorithm uses the fact that forms are </context>
</contexts>
<marker>[38]</marker>
<rawString>Oscar Nierstrasz, Franz Achermann, and Stefan Kneubühl. A guide to JPiccola. Technical Report IAM-03-003, Institut für Informatik, Universität Bern, Switzerland, June 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oscar Nierstrasz</author>
<author>Theo Dirk Meijler</author>
</authors>
<title>Requirements for a composition language.</title>
<date>1995</date>
<booktitle>Object-Based Models and Langages for Concurrent Systems,</booktitle>
<volume>924</volume>
<pages>147--161</pages>
<editor>In Paolo Ciancarini, Oscar Nierstrasz, and Akinori Yonezawa, editors,</editor>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="1816" citStr="[39]" startWordPosition="256" endWordPosition="256">scar Nierstrasz, “A Calculus for Reasoning about Software Components,” Theoretical Computer Science, vol. 331, no. 2-3, 2005, pp. 367-396. 1 Introduction Component-Based Software Development (CBSD) offers us the promise of flexible applications being constructed from stable, robust software components. But how are components plugged into an application? How do we specify the way in which components are configured and composed? Preprint submitted to Elsevier Science 31 March 2005 In addition to components, we clearly need some means to specify compositions of components. A composition language [39] is a language for specifying operators for connecting components (i.e., “connectors”), glue abstractions for adapting component interfaces, and scripts that instantiate and connect components. Piccola [4,6] is a prototype for such a composition language, and JPiccola is an implementation which targets the composition of Java software components [38]. A key challenge for a composition language is to offer a means to answer the question, What, precisely, do we mean by composition? There are many different notions of component composition and interconnection in practice, so a composition languag</context>
</contexts>
<marker>[39]</marker>
<rawString>Oscar Nierstrasz and Theo Dirk Meijler. Requirements for a composition language. In Paolo Ciancarini, Oscar Nierstrasz, and Akinori Yonezawa, editors, Object-Based Models and Langages for Concurrent Systems, volume 924 of LNCS, pages 147–161. Springer-Verlag, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shin-ya Nishizaki</author>
</authors>
<title>Programmable environment calculus as theory of dynamic software evolution.</title>
<date>2000</date>
<booktitle>In Proceedings ISPSE</booktitle>
<publisher>IEEE Computer Society Press,</publisher>
<contexts>
<context position="22037" citStr="[1,40]" startWordPosition="3670" endWordPosition="3670">ound freely. For instance in x 7→c() ≡ x 7→(c() |) by emit ≡ c() |x 7→ by par ext right the message c() escapes the binding x 7→. 3.4 Reduction We define the reduction relation → on agent expressions to reduce applications, communications and projections (see Table 6). ⇒ is the reflexive and transitive closure of →. Especially noteworthy is the rule reduce beta. This rule does not substitute G for x in the agent A as in the classical λ-calculus. Instead, it extends the environment in which A is evaluated. This is essentially the beta-reduction rule found in calculi for explicit substitution [1,40]: (F ;λx.A)G → F · x 7→G;A The application of the closure F ;λx.A to the argument G reduces to a sandbox expression in which the agent A is evaluated in the environment F ·x 7→G. Free occurrences of x in A will therefore be bound to G. The property of being closed is respected by reduction: Lemma 1 If A is a closed agent and A → B or A ≡ B then B is closed as well. PROOF. Easily checked by induction over the formal proof for A→ B. 12 Table 6 Reduction rules (F ;λx.A) G→ F · x7→G;A (reduce beta) cF |c?→ F (reduce comm) F · x7→G;x→ G (reduce project) L→ ;λx.(x; isEmpty) (reduce inspect empty)</context>
<context position="58269" citStr="[40,46]" startWordPosition="9956" endWordPosition="9956">rms without introspection. An issue omitted in our approach is record typing. It is not clear how far record types with subtyping and the runtime acquisition can be combined. An overview of record typing and the problems involved can be found for example in [12]. 6.5 Explicit environments An explicit environment generalizes the concept of explicit substitution [1] by using a record like structure for the environment. In the environment calculus of Nishizaki, there is an operation to get the current environment as a record and an operator to evaluate an expression using a record as environment [40,46]. Projection of a label x in a record R then corresponds to evaluating the script x in an environment denoted by R. The reader may note that explicit environments subsume records. This is the reason why we call them forms in Piccola instead of just records. Handling the environment as a first-class entity allows us to define concepts like modules, interfaces and implementation for programming in the large within the framework. To our knowledge, the language Pebble of Burstall and Lampson was the first to formally show how to build modules, interfaces and implementation, abstract data types and</context>
</contexts>
<marker>[40]</marker>
<rawString>Shin-ya Nishizaki. Programmable environment calculus as theory of dynamic software evolution. In Proceedings ISPSE 2000. IEEE Computer Society Press, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Claus Pahl</author>
</authors>
<title>A pi-calculus based framework for the composition and replacement of components.</title>
<date>2001</date>
<booktitle>In Workshop on Specification and Verification of ComponentBased Systems (OOPSLA</booktitle>
<contexts>
<context position="59433" citStr="[41]" startWordPosition="10135" endWordPosition="10135"> implementation, abstract data types and generics on a typed lambda calculus with bindings, declarations and types as first-class values [11]. 6.6 Other approaches Zenger has developed a component calculus [55] that extends Featherweight Java [22] with primitives to dynamically build, extend and compose software components. The novelty of Zenger’s calculus is that components are composed 32 implicitly on the basis of the type compatibility of component interfaces, rather than by establishing explicit connections. Pahl has developed composition and replacement calculus based on the π- calculus [41]. In this approach, types are used to characterize values that may be passed along ports, and contracts (pre- and post-conditions) are used to determine whether provided and required services match. The calculus is used to reason about when components can be replaced in dynamically evolving systems. A very different model is offered by ρω (AKA Reo) [7], a calculus of component connectors. Reo is algebraic in flavour, and provides various connectors that coordinate and compose streams of data. Primitive connectors can be composed using the Reo operators to build higher-level connectors. In con</context>
</contexts>
<marker>[41]</marker>
<rawString>Claus Pahl. A pi-calculus based framework for the composition and replacement of components. In Workshop on Specification and Verification of ComponentBased Systems (OOPSLA 2001), 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Benjamin C Pierce</author>
<author>David N Turner</author>
</authors>
<title>Pict: A programming language based on the pi-calculus.</title>
<date>2000</date>
<booktitle>Proof, Language and Interaction: Essays in Honour of Robin Milner.</booktitle>
<editor>In G. Plotkin, C. Stirling, and M. Tofte, editors,</editor>
<publisher>MIT Press,</publisher>
<contexts>
<context position="54621" citStr="[42]" startWordPosition="9401" endWordPosition="9401">e asynchronous π-calculus with higher-order abstractions and first-class environments. 6.1 π-calculus The π-calculus [32] is a calculus of communicating systems in which one can naturally express processes with a changing structure. Its theory has been thoroughly studied and many results relate other formalisms or implementations to it. The affinity between objects and processes, for example, has been treated by various authors in the context of the π-calculus [21,53]. The Pict experiment has shown that the π-calculus is a suitable basis for programming many high-level constructs by encodings [42]. 30 For programming and implementation purposes, synchronous communication seems uncommon and can generally be encoded by using explicit acknowledgments (cf. [21]). Moreover, asynchronous communication has a closer correspondence to distributed computing [54]. Furthermore, in the π-calculus the asynchronous variant has the pleasant property that equivalences are simpler than for the synchronous case [16]. Input-guarded choice can be encoded and is fully abstract [34]. For these reasons we adopt asynchronous channels in the Piccola calculus. 6.2 Higher-order abstractions Programming directly i</context>
</contexts>
<marker>[42]</marker>
<rawString>Benjamin C. Pierce and David N. Turner. Pict: A programming language based on the pi-calculus. In G. Plotkin, C. Stirling, and M. Tofte, editors, Proof, Language and Interaction: Essays in Honour of Robin Milner. MIT Press, May 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Didier Remy</author>
</authors>
<title>Typing Record Concatenation for Free, chapter 10,</title>
<date>1994</date>
<pages>351--372</pages>
<publisher>MIT Press,</publisher>
<contexts>
<context position="57418" citStr="[12,43]" startWordPosition="9815" endWordPosition="9815">Blue calculus studied by Dal-Zilio [14]. In the higher-order π-calculus the evaluation order is orthogonal to the communication semantics [45]. In Piccola, evaluation strategy interferes with communication, therefore we have to fix one for meaningful 31 terms. For Piccola, we define strict evaluation which seems appropriate and more common for concurrent computing. 6.4 Record calculus When modeling components and interfaces, a record-based approach is the obvious choice. We use forms [27,28] as an explicit notion for extensible records. Record calculi are studied in more detail for example in [12,43]. In the λ-calculus with names of Dami [15] arguments to functions are named. The resulting system supports records as arguments instead of tuples as in the classical calculus. The λN -calculus was one of the main inspiration for our work on forms without introspection. An issue omitted in our approach is record typing. It is not clear how far record types with subtyping and the runtime acquisition can be combined. An overview of record typing and the problems involved can be found for example in [12]. 6.5 Explicit environments An explicit environment generalizes the concept of explicit substi</context>
</contexts>
<marker>[43]</marker>
<rawString>Didier Rémy. Typing Record Concatenation for Free, chapter 10, pages 351–372. MIT Press, April 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Davide Sangiorgi</author>
</authors>
<title>Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms.</title>
<date>1993</date>
<tech>Ph.D. thesis,</tech>
<institution>Computer Science Dept., University of Edinburgh,</institution>
<contexts>
<context position="56395" citStr="[44,45]" startWordPosition="9659" endWordPosition="9659">rs a process on consumption of several pending messages. The Blue calculus of Boudol [10] changes the receive primitive into a definition which is defined for a scope. By that change, the Blue calculus is more closely related to functions and provides a better notion for higher-order abstraction. Boudol calls it a continuation-passing calculus. The other approach is adopted by Sangiorgi in the HOπ-calculus. Instead of communicating channels or tuples of channels, processes can be communicated as well. Surprisingly, the higher-order case has the same expressive power as the first-order version [44,45]. In the Piccola calculus we take the second approach and reuse existing encodings of functions into the π-calculus as in Pict. The motivation for this comes from the fact that the HOπ-calculus itself can be encoded in the first-order case. 6.3 Asymmetric parallel composition The semantics of asynchronous parallel composition is used in the concurrent object calculus of Gordon and Hankin [19] or the (asymmetric) Blue calculus studied by Dal-Zilio [14]. In the higher-order π-calculus the evaluation order is orthogonal to the communication semantics [45]. In Piccola, evaluation strategy interfer</context>
</contexts>
<marker>[44]</marker>
<rawString>Davide Sangiorgi. Expressing Mobility in Process Algebras: First-Order and Higher-Order Paradigms. Ph.D. thesis, Computer Science Dept., University of Edinburgh, May 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Davide Sangiorgi</author>
</authors>
<title>Asynchronous process calculi: the first-order and higher-order paradigms (tutorial).</title>
<date>2001</date>
<journal>Theoretical Computer Science,</journal>
<volume>253</volume>
<contexts>
<context position="3095" citStr="[32,45]" startWordPosition="443" endWordPosition="443">n can be expressed. We therefore need a semantic foundation for specifying compositional abstractions. Components may be configured and adapted in many different ways, which may or may not have an impact on the resulting composition. We therefore also need to reason about equivalence of different expressions of composition. Drawing from our experience modeling various component models, we have developed the Piccola calculus as a tool for expressing the semantics of software composition and for reasoning about equivalence of compositions. The Piccola calculus extends the asychronous π-calculus [32,45] with forms—firstclass, extensible namespaces [5]. Forms are not only convenient for expressing components, but play other important roles as well. This calculus serves both as the semantic target and as an executable abstract machine for Piccola. In this paper we first motivate the calculus by establishing a set of requirements for modeling composition of software components in section 2. Next, we address these requirements by presenting the syntax and semantics of the Piccola calculus in section 3. In section 4 we provide a brief overview of the Piccola language, and summarize how the calcul</context>
<context position="11685" citStr="[32,45]" startWordPosition="1737" endWordPosition="1737">e able to express coordination of interdependent tasks. • Coordination abstractions: Both connectors and glue code may need to express coordination of concurrent activities. Consider a readers/writers synchronization policy as a generic wrapper. We conclude that we not only need higher-order functions over first-class namespaces (with introspection), but also a way of expressing concurrency and communication [50]. 3 The Piccola calculus As a consequence of the requirements we have identified above, we propose as a foundation a process calculus based on the higher-order asynchronous π-calculus [32,45] in which tuple-based communication is replaced by communication of extensible records, or forms [5,37]. Furthermore, forms serve as first-class namespaces and support a simple kind of introspection. The design of the Piccola calculus strikes a balance between minimalism and expressiveness. As a calculus it is rather large. In fact, it would be possible to express everything we want with the π-calculus alone, but the semantic gap between concepts we wish to model and the terms of the calculus would be 6 Table 1 Syntax of the Piccola calculus A,B,C ::=  empty form |R current root |A;B sandbox </context>
<context position="29260" citStr="[30,45]" startWordPosition="5063" endWordPosition="5063"> F ;R ≡ F . Note that if an agent is stuck it is not a preform: F≡ ∩ {A|A↑} = ∅ by definition. Although 0 is arguably stuck by intention, in general a stuck agent can be interpreted as an error. The two typical cases which may lead to errors are (i) projection on an unbound label, e.g., ;x, and (ii) application of a non-service, e.g., . 3.8 π-Calculus Encoding One may well ask what exactly the Piccola calculus adds over and above the asynchronous π-calculus. We have previously shown that the Piccola calculus can be faithfully embedded into the localized π-calculus Lπ of Merro and Sangiorgi [30,45]. The mapping [[]]a encodes Piccola calculus agents as π-calculus processes. The process [[A]]a evaluates A in the environment given by the empty form, and sends the resulting value along the channel a. A form (value) is encoded as a 4- tuple of channels representing projection, invocation, hiding and selection. The main result is that the encoding is sound and preserves reductions. We do not require a fully abstract encoding since that would mean that equivalent Piccola calculus agents translated into the π-calculus could not be distinguished by any π-processes. Our milder requirement means t</context>
<context position="56395" citStr="[44,45]" startWordPosition="9659" endWordPosition="9659">rs a process on consumption of several pending messages. The Blue calculus of Boudol [10] changes the receive primitive into a definition which is defined for a scope. By that change, the Blue calculus is more closely related to functions and provides a better notion for higher-order abstraction. Boudol calls it a continuation-passing calculus. The other approach is adopted by Sangiorgi in the HOπ-calculus. Instead of communicating channels or tuples of channels, processes can be communicated as well. Surprisingly, the higher-order case has the same expressive power as the first-order version [44,45]. In the Piccola calculus we take the second approach and reuse existing encodings of functions into the π-calculus as in Pict. The motivation for this comes from the fact that the HOπ-calculus itself can be encoded in the first-order case. 6.3 Asymmetric parallel composition The semantics of asynchronous parallel composition is used in the concurrent object calculus of Gordon and Hankin [19] or the (asymmetric) Blue calculus studied by Dal-Zilio [14]. In the higher-order π-calculus the evaluation order is orthogonal to the communication semantics [45]. In Piccola, evaluation strategy interfer</context>
</contexts>
<marker>[45]</marker>
<rawString>Davide Sangiorgi. Asynchronous process calculi: the first-order and higher-order paradigms (tutorial). Theoretical Computer Science, 253, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Masahiko Sato</author>
<author>Takafumi Sakurai</author>
<author>Rod M Burstall</author>
</authors>
<title>Explicit environments.</title>
<date>1999</date>
<booktitle>Typed Lambda Calculi and Applications,</booktitle>
<volume>1581</volume>
<pages>340--354</pages>
<editor>In Jean-Yves Girard, editor,</editor>
<publisher>Springer-Verlag.</publisher>
<location>L’Aquila, Italy,</location>
<contexts>
<context position="58269" citStr="[40,46]" startWordPosition="9956" endWordPosition="9956">rms without introspection. An issue omitted in our approach is record typing. It is not clear how far record types with subtyping and the runtime acquisition can be combined. An overview of record typing and the problems involved can be found for example in [12]. 6.5 Explicit environments An explicit environment generalizes the concept of explicit substitution [1] by using a record like structure for the environment. In the environment calculus of Nishizaki, there is an operation to get the current environment as a record and an operator to evaluate an expression using a record as environment [40,46]. Projection of a label x in a record R then corresponds to evaluating the script x in an environment denoted by R. The reader may note that explicit environments subsume records. This is the reason why we call them forms in Piccola instead of just records. Handling the environment as a first-class entity allows us to define concepts like modules, interfaces and implementation for programming in the large within the framework. To our knowledge, the language Pebble of Burstall and Lampson was the first to formally show how to build modules, interfaces and implementation, abstract data types and</context>
</contexts>
<marker>[46]</marker>
<rawString>Masahiko Sato, Takafumi Sakurai, and Rod M. Burstall. Explicit environments. In Jean-Yves Girard, editor, Typed Lambda Calculi and Applications, volume 1581 of LNCS, pages 340–354, L’Aquila, Italy, April 1999. Springer-Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nathanael Scharli</author>
</authors>
<title>Supporting pure composition by inter-language bridging on the meta-level. Diploma thesis,</title>
<date>2001</date>
<institution>University of Bern,</institution>
<contexts>
<context position="33824" citStr="[2,47,48]" startWordPosition="5755" endWordPosition="5755">xamples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to those arguments. In this section we present a partial evaluation algorithm for Piccola [2,47,48]. This algorithm uses the fact that forms are immutable. We replace references to forms by the forms referred to. We can then specialize projections and replace applications of referentially transparent services by their results. However, most services in Piccola are not referentially transparent and cannot be inlined since that would change the order in which side-effects are executed. We need to separate the referentially transparent part from the non-transparent part in order to replace an application with its result and to ensure that the order in which the side-effects are evaluated is pr</context>
<context position="39936" citStr="[47,48]" startWordPosition="6777" endWordPosition="6777">abstractions λx.P ? R contain their side-effect P and the referentially transparent result R. Side-effect services are arbitrary agents A. Partial evaluation does not specialize them. The primitive services new, run, and L are side-effect services. Side-effect terms contain applications and projections that may fail. Side-effect terms have a specific structure. Atomic side-effects are bound by unique labels. Side-effect terms can be nested and sequentially composed. In P1 ·P2 we may refer to side-effects of P1 from P2. This algorithm has been used extensively in the implementation of SPiccola [47,48], an implementation of Piccola for components written in Squeak [23], an open-source Smalltalk. 5.2 The Algorithm We now present and discuss the functions split and combine in detail. We assume that · is associative and  is the neutral element. This allows us to reduce the number of defining equations. For instance, when defining projection in Table 11 we write project(R ·x 7→R1, x) = R1 assuming that we can rewrite any form with several bindings into a form extended with a single binding. 22 Table 9 Free variables and defined labels fv() = ∅ fv(x) = {x} fv(R1R2) = fv(R1) ∪ fv(R2) fv(R.x) = </context>
</contexts>
<marker>[47]</marker>
<rawString>Nathanael Schärli. Supporting pure composition by inter-language bridging on the meta-level. Diploma thesis, University of Bern, September 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nathanael Scharli</author>
<author>Franz Achermann</author>
</authors>
<title>Partial evaluation of inter-language wrappers.</title>
<date>2001</date>
<booktitle>InWorkshop on Composition Languages, WCL ’01,</booktitle>
<contexts>
<context position="33824" citStr="[2,47,48]" startWordPosition="5755" endWordPosition="5755">xamples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to those arguments. In this section we present a partial evaluation algorithm for Piccola [2,47,48]. This algorithm uses the fact that forms are immutable. We replace references to forms by the forms referred to. We can then specialize projections and replace applications of referentially transparent services by their results. However, most services in Piccola are not referentially transparent and cannot be inlined since that would change the order in which side-effects are executed. We need to separate the referentially transparent part from the non-transparent part in order to replace an application with its result and to ensure that the order in which the side-effects are evaluated is pr</context>
<context position="39936" citStr="[47,48]" startWordPosition="6777" endWordPosition="6777">abstractions λx.P ? R contain their side-effect P and the referentially transparent result R. Side-effect services are arbitrary agents A. Partial evaluation does not specialize them. The primitive services new, run, and L are side-effect services. Side-effect terms contain applications and projections that may fail. Side-effect terms have a specific structure. Atomic side-effects are bound by unique labels. Side-effect terms can be nested and sequentially composed. In P1 ·P2 we may refer to side-effects of P1 from P2. This algorithm has been used extensively in the implementation of SPiccola [47,48], an implementation of Piccola for components written in Squeak [23], an open-source Smalltalk. 5.2 The Algorithm We now present and discuss the functions split and combine in detail. We assume that · is associative and  is the neutral element. This allows us to reduce the number of defining equations. For instance, when defining projection in Table 11 we write project(R ·x 7→R1, x) = R1 assuming that we can rewrite any form with several bindings into a form extended with a single binding. 22 Table 9 Free variables and defined labels fv() = ∅ fv(x) = {x} fv(R1R2) = fv(R1) ∪ fv(R2) fv(R.x) = </context>
</contexts>
<marker>[48]</marker>
<rawString>Nathanael Schärli and Franz Achermann. Partial evaluation of inter-language wrappers. InWorkshop on Composition Languages, WCL ’01, September 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Andreas Schlapbach</author>
</authors>
<title>Enabling white-box reuse in a pure composition language. Diploma thesis,</title>
<date>2003</date>
<institution>University of Bern,</institution>
<contexts>
<context position="33203" citStr="[49]" startWordPosition="5662" endWordPosition="5662">The fourth layer is provided by the component framework designer. At this level, a domain expert encodes a compositional styles as a library of components, connectors, adaptors, coordination abstractions, and so on. Finally, at the top level, an application programmer may script together components using the abstractions provided by the lower layers [3,36]. Piccola has been used to experiment with the implementation of various compositional styles, including styles for GUI composition [6], styles for actor coordination [25], and styles for wrapping white-box frameworks as black-box components [49]. Tutorial examples are described in the JPiccola user’s guide [38] 5 Partial Evaluation Since Piccola is a pure composition language, evaluating scripts requires intensive upping and downing [31] between the “down” level of the host language and the “up” level of Piccola. If the language bridge were implemented naıvely, it would be hopelessly inefficient. Partial evaluation [8,24,13] is a program transformation technique which, given a program and parts of its arguments, produces a specialized program with respect to those arguments. In this section we present a partial evaluation algorithm </context>
</contexts>
<marker>[49]</marker>
<rawString>Andreas Schlapbach. Enabling white-box reuse in a pure composition language. Diploma thesis, University of Bern, January 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jean-Guy Schneider</author>
</authors>
<title>Components, Scripts, and Glue: A conceptual framework for software composition.</title>
<date>1999</date>
<tech>Ph.D. thesis,</tech>
<institution>University of Bern, Institute of Computer Science and Applied Mathematics,</institution>
<contexts>
<context position="5146" citStr="[50,51]" startWordPosition="754" endWordPosition="754">n abstractions Scripts • sandboxes • composition expressions • context-dependent policies Fig. 1. How Piccola supports composition that is, component-based applications are (ideally) made up of stable, off-theshelf components, and scripts that plug them together [6]. Scripts (ideally) make use of high-level connectors that coordinate the services of various components [3,36,52]. Furthermore, complex applications may need services of components that depend on very different architectural assumptions [18]. In these cases, glue code is needed to adapt components to different architectural styles [50,51]. A foundation for modeling software components must therefore be suitable for expressing compositional styles, scripts, coordination abstractions and glue code. Figure 1 summarizes the requirements, and illustrates how Piccola and the Piccola calculus support them. 2.1 Compositional Styles A compositional style allows us to express the structure of a software application in terms of components, connectors and rules governing their composition (cf. “architectural style” [52]). The following list summarizes the requirements we identified for a composition language to support the expression of d</context>
<context position="11494" citStr="[50]" startWordPosition="1708" endWordPosition="1708">cit, manipulable namespaces become more important. 2.4 Coordination CBSD is especially relevant in concurrent and distributed contexts. For this reason, a foundation for composition must be able to express coordination of interdependent tasks. • Coordination abstractions: Both connectors and glue code may need to express coordination of concurrent activities. Consider a readers/writers synchronization policy as a generic wrapper. We conclude that we not only need higher-order functions over first-class namespaces (with introspection), but also a way of expressing concurrency and communication [50]. 3 The Piccola calculus As a consequence of the requirements we have identified above, we propose as a foundation a process calculus based on the higher-order asynchronous π-calculus [32,45] in which tuple-based communication is replaced by communication of extensible records, or forms [5,37]. Furthermore, forms serve as first-class namespaces and support a simple kind of introspection. The design of the Piccola calculus strikes a balance between minimalism and expressiveness. As a calculus it is rather large. In fact, it would be possible to express everything we want with the π-calculus alo</context>
<context position="60578" citStr="[50]" startWordPosition="10321" endWordPosition="10321"> the Reo operators to build higher-level connectors. In contrast to process calculi, Reo is well-suited to compositional reasoning, since connectors can be composed to yield new connectors, and properties of connectors can be shown to compose. Data communicated along streams are uninterpreted in Reo, so it would be natural to explore the application of Reo to streams of forms. 6.7 Precursors to the Piccola calculus In our earlier work on the foundations of Piccola, we specified the semantics of Piccola in terms of translations to πL (the π calculus with labels) [27,28] or to the form calculus [50]. The difference between πL and the form calculus is that the latter allows hiding of labels and forms and it contains a testing primitive for labels. The Piccola calculus is better suited to give a direct semantics to the Piccola language. The enhanced expressiveness of the Piccola calculus with respect to the form- and the πL-calculus are as follows: • Form extension. In πL and the form calculus we have separate primitives to extend a form with either a single binding or a separate form. In the Piccola calculus there is a single extension operator · for asymmetric form concatenation. • Label</context>
</contexts>
<marker>[50]</marker>
<rawString>Jean-Guy Schneider. Components, Scripts, and Glue: A conceptual framework for software composition. Ph.D. thesis, University of Bern, Institute of Computer Science and Applied Mathematics, October 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jean-Guy Schneider</author>
<author>Oscar Nierstrasz</author>
</authors>
<title>Components, scripts and glue.</title>
<date>1999</date>
<booktitle>Software Architectures — Advances and Applications,</booktitle>
<pages>13--25</pages>
<editor>In Leonor Barroca, Jon Hall, and Patrick Hall, editors,</editor>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="5146" citStr="[50,51]" startWordPosition="754" endWordPosition="754">n abstractions Scripts • sandboxes • composition expressions • context-dependent policies Fig. 1. How Piccola supports composition that is, component-based applications are (ideally) made up of stable, off-theshelf components, and scripts that plug them together [6]. Scripts (ideally) make use of high-level connectors that coordinate the services of various components [3,36,52]. Furthermore, complex applications may need services of components that depend on very different architectural assumptions [18]. In these cases, glue code is needed to adapt components to different architectural styles [50,51]. A foundation for modeling software components must therefore be suitable for expressing compositional styles, scripts, coordination abstractions and glue code. Figure 1 summarizes the requirements, and illustrates how Piccola and the Piccola calculus support them. 2.1 Compositional Styles A compositional style allows us to express the structure of a software application in terms of components, connectors and rules governing their composition (cf. “architectural style” [52]). The following list summarizes the requirements we identified for a composition language to support the expression of d</context>
</contexts>
<marker>[51]</marker>
<rawString>Jean-Guy Schneider and Oscar Nierstrasz. Components, scripts and glue. In Leonor Barroca, Jon Hall, and Patrick Hall, editors, Software Architectures — Advances and Applications, pages 13–25. Springer-Verlag, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mary Shaw</author>
<author>David Garlan</author>
</authors>
<title>Software Architecture: Perspectives on an Emerging Discipline.</title>
<date>1996</date>
<publisher>Prentice-Hall,</publisher>
<contexts>
<context position="4919" citStr="[3,36,52]" startWordPosition="723" endWordPosition="723">s Styles • primitive neutral object model • meta-objects • HO plugs &amp; connectors • default arguments • encapsulation • component algebras Glue • generic wrappers • component packaging • generic adaptors Coordination • coordination abstractions Scripts • sandboxes • composition expressions • context-dependent policies Fig. 1. How Piccola supports composition that is, component-based applications are (ideally) made up of stable, off-theshelf components, and scripts that plug them together [6]. Scripts (ideally) make use of high-level connectors that coordinate the services of various components [3,36,52]. Furthermore, complex applications may need services of components that depend on very different architectural assumptions [18]. In these cases, glue code is needed to adapt components to different architectural styles [50,51]. A foundation for modeling software components must therefore be suitable for expressing compositional styles, scripts, coordination abstractions and glue code. Figure 1 summarizes the requirements, and illustrates how Piccola and the Piccola calculus support them. 2.1 Compositional Styles A compositional style allows us to express the structure of a software applicatio</context>
</contexts>
<marker>[52]</marker>
<rawString>Mary Shaw and David Garlan. Software Architecture: Perspectives on an Emerging Discipline. Prentice-Hall, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>David Walker</author>
</authors>
<title>Objects in the π-calculus.</title>
<date>1995</date>
<journal>Information and Computation,</journal>
<volume>116</volume>
<issue>2</issue>
<contexts>
<context position="54489" citStr="[21,53]" startWordPosition="9381" endWordPosition="9381"> are referentially transparent. If split(A,R) = (P,R) then combine ′(P ) ` embed(R) [2]. 6 Related Work The Piccola calculus extends the asynchronous π-calculus with higher-order abstractions and first-class environments. 6.1 π-calculus The π-calculus [32] is a calculus of communicating systems in which one can naturally express processes with a changing structure. Its theory has been thoroughly studied and many results relate other formalisms or implementations to it. The affinity between objects and processes, for example, has been treated by various authors in the context of the π-calculus [21,53]. The Pict experiment has shown that the π-calculus is a suitable basis for programming many high-level constructs by encodings [42]. 30 For programming and implementation purposes, synchronous communication seems uncommon and can generally be encoded by using explicit acknowledgments (cf. [21]). Moreover, asynchronous communication has a closer correspondence to distributed computing [54]. Furthermore, in the π-calculus the asynchronous variant has the pleasant property that equivalences are simpler than for the synchronous case [16]. Input-guarded choice can be encoded and is fully abstract </context>
</contexts>
<marker>[53]</marker>
<rawString>David Walker. Objects in the π-calculus. Information and Computation, 116(2):253–271, February 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pawel T Wojciechowski</author>
</authors>
<title>Nomadic Pict: Language and Infrastructure Design for Mobile Computation.</title>
<date>2000</date>
<tech>PhD thesis,</tech>
<institution>Wolfson College, University of Cambridge,</institution>
<contexts>
<context position="54881" citStr="[54]" startWordPosition="9435" endWordPosition="9435">hly studied and many results relate other formalisms or implementations to it. The affinity between objects and processes, for example, has been treated by various authors in the context of the π-calculus [21,53]. The Pict experiment has shown that the π-calculus is a suitable basis for programming many high-level constructs by encodings [42]. 30 For programming and implementation purposes, synchronous communication seems uncommon and can generally be encoded by using explicit acknowledgments (cf. [21]). Moreover, asynchronous communication has a closer correspondence to distributed computing [54]. Furthermore, in the π-calculus the asynchronous variant has the pleasant property that equivalences are simpler than for the synchronous case [16]. Input-guarded choice can be encoded and is fully abstract [34]. For these reasons we adopt asynchronous channels in the Piccola calculus. 6.2 Higher-order abstractions Programming directly in the π-calculus is often considered like programming a concurrent assembler. When comparing programs written in the π-calculus with the lambda-calculus it seems like lambda abstractions scale up, whereas sending and receiving messages does not scale well. The</context>
</contexts>
<marker>[54]</marker>
<rawString>Pawel T. Wojciechowski. Nomadic Pict: Language and Infrastructure Design for Mobile Computation. PhD thesis, Wolfson College, University of Cambridge, March 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Matthias Zenger</author>
</authors>
<title>Type-safe prototype-based component evolution.</title>
<date>2002</date>
<booktitle>In Proceedings ECOOP 2002,</booktitle>
<volume>2374</volume>
<pages>470--497</pages>
<publisher>Springer Verlag.</publisher>
<location>Malaga, Spain,</location>
<contexts>
<context position="59039" citStr="[55]" startWordPosition="10079" endWordPosition="10079">sume records. This is the reason why we call them forms in Piccola instead of just records. Handling the environment as a first-class entity allows us to define concepts like modules, interfaces and implementation for programming in the large within the framework. To our knowledge, the language Pebble of Burstall and Lampson was the first to formally show how to build modules, interfaces and implementation, abstract data types and generics on a typed lambda calculus with bindings, declarations and types as first-class values [11]. 6.6 Other approaches Zenger has developed a component calculus [55] that extends Featherweight Java [22] with primitives to dynamically build, extend and compose software components. The novelty of Zenger’s calculus is that components are composed 32 implicitly on the basis of the type compatibility of component interfaces, rather than by establishing explicit connections. Pahl has developed composition and replacement calculus based on the π- calculus [41]. In this approach, types are used to characterize values that may be passed along ports, and contracts (pre- and post-conditions) are used to determine whether provided and required services match. The cal</context>
</contexts>
<marker>[55]</marker>
<rawString>Matthias Zenger. Type-safe prototype-based component evolution. In Proceedings ECOOP 2002, volume 2374 of LNCS, pages 470–497, Malaga, Spain, June 2002. Springer Verlag.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>