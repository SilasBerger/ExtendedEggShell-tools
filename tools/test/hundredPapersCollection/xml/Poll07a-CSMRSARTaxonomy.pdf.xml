<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.953722">
A Process-Oriented Software Architecture Reconstruction Taxonomy
</title>
<author confidence="0.810314">
Stéphane Ducasse Damien Pollet Loı̈c Poyet
</author>
<table confidence="0.258793">
LISTIC - Language and Software Evolution Group
Université de Savoie, France
Accepted to CSMR 2007
</table>
<sectionHeader confidence="0.97138" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.999478846153846">
To maintain and understand large applications, it is cru-
cial to know their architecture. The first problem is that
architectures are not explicitly represented in the code as
classes and packages are. The second problem is that suc-
cessful applications evolve over time so their architecture
inevitably drifts. Reconstructing and checking whether the
architecture is still valid is thus an important aid. While
there is a plethora of approaches and techniques support-
ing architecture reconstruction, there is no comprehensive
state of the art and it is often difficult to compare the ap-
proaches. This article presents a first state of the art in soft-
ware architecture reconstruction, with the desire to support
the understanding of the field.
</bodyText>
<sectionHeader confidence="0.993602" genericHeader="keywords">
1. Introduction
</sectionHeader>
<bodyText confidence="0.99736206122449">
Software architecture acts as a shared mental model of
a system expressed at a high-level of abstraction [49]. By
leaving details aside, this model plays a key role as a bridge
between requirements and implementation [32]. It allows
one to reason architecturally about a software application
during the various steps of the software life cycle. Accord-
ing to Garlan [32], software architecture plays an important
role in at least six aspects of software development: under-
standing, reuse, construction, evolution, analysis and man-
agement.
Software architecture is thus crucial for software devel-
opment. The first problem is that architectures are not ex-
plicitly represented in the code as classes and packages are.
The second problem is that successful software applications
are doomed to continually evolve and grow [67]; and as a
software application evolves and grows, so does its archi-
tecture. The conceptual architecture often becomes inaccu-
rate with respect to the concrete architecture; this results in
architectural erosion [75, 88], drift [88], mismatch [33], or
chasm [96].
Software architecture reconstruction (SAR) is the re-
verse engineering process that aims at reconstructing vi-
able architectural views of a software application. Krikhaar
specified five SAR maturity levels [62]. While SAR is ra-
rely an end in itself, it improves software development by
providing high-level views of the investigated software ap-
plication [43]. For example, these views help identify prod-
uct line commonalities and variabilities [109] or check their
conformance to the source code [82].
Several approaches and techniques have been proposed
in the literature to support SAR. Mendonça et al. presented
a first raw classification of SAR environments based on a
few typical scenarios [78]. O’Brien et al. surveyed SAR
practice needs and approaches [85]. Still, there is no com-
prehensive state of the art and it is often difficult to com-
pare the approaches. This article presents a first state of
the art in SAR, with the desire to help understand the field
and to identify the current approaches, techniques and tools.
The presented taxonomy takes the perspective of a reverse-
engineer who would like to reconstruct the architecture of
an existing application and would like to know which tools
or approach to take. The taxonomy takes into account the
goals, the process, the inputs, the techniques and the outputs
of SAR.
Section 2 first stresses some key vocabulary definitions
and the challenges addressed in the field. Section 3 de-
scribes the criteria that we adopted in our taxonomy; sec-
tions 4 to 8 then cover each of these criteria, and we con-
clude.
</bodyText>
<sectionHeader confidence="0.83486" genericHeader="introduction">
2. SAR Challenges
</sectionHeader>
<bodyText confidence="0.433272">
Before going in more depth into the challenges of SAR,
we feel the need to clarify the vocabulary.
</bodyText>
<subsectionHeader confidence="0.208566">
2.1. Vocabulary
</subsectionHeader>
<bodyText confidence="0.45212125">
Software architecture. IEEE defines software architec-
ture as “the fundamental organization of a system embodied
in its components, their relationships to each other, and to
the environment, and the principles guiding its design and
</bodyText>
<page confidence="0.468239">
1
</page>
<bodyText confidence="0.967929942857143">
evolution”[52]; this is closely related to the definition of
Shaw, Perry and Garlan [102, 35].
Architectural style. A software architecture often con-
forms to an architectural style that is a class of architec-
tures, or a pattern of structural organization: “a vocabulary
of components and connector types, and a set of constraints
on how they can be combined” [102].
Architectural views and viewpoints. We can view a soft-
ware architecture from several viewpoints since the different
system stakeholders have different expectations or concerns
about the system [64, 52]:
View: “a representation of a whole system from the per-
spective of a related set of concerns.”
Viewpoint: “a specification of the conventions for con-
structing and using a view. A pattern or a template
from which to develop individual views by establishing
the purposes and audience for a view and the tech-
niques for its creation and analysis.”
Conceptual architecture. It refers to the architecture
that exists in human minds or in the software documenta-
tion [120, 96]. In the literature, this kind of architecture
is also qualified as idealized [43], intended [132, 96], as-
designed [57, 120] or logical [76].
Concrete architecture. It refers to the architecture that
can be derived from source code [120, 96]. It is also known
as the as-implemented [57, 96], as-built [120, 43], real-
ized [132] or physical [76] architecture.
Software architecture reconstruction (SAR). SAR is
the reverse engineering approach that aims at reconstruct-
ing viable architectural views of a software application. The
literature uses several other terms to refer to SAR: reverse
architecting, or architecture extraction, mining, recovery or
discovery. The last two terms are more specific than the
others [75]: recovery refers to a bottom-up process while
discovery refers to a top-down process (see Section 5).
</bodyText>
<subsectionHeader confidence="0.736824">
2.2. Challenges
</subsectionHeader>
<bodyText confidence="0.953875777777778">
SAR is a multidisciplinary activity which covers several
research areas dealing with information processing: extrac-
tion, abstraction, modeling and presentation of the results.
On the one hand, human expertise is primordial to treat
architectural concepts. Knowledge of business goals, re-
quirements, product family reference architectures, or de-
sign constraints is useful to assist SAR. However, when we
take human knowledge into consideration, several problems
appear:
</bodyText>
<listItem confidence="0.895798">
• Because of the experts turnover and the lack of com-
</listItem>
<bodyText confidence="0.8198925">
plete, up-to-date documentation, the conceptual archi-
tecture in human minds is often obsolete, inaccurate,
incomplete, or at an irrelevant abstraction level. SAR
should take into account the quality of the information.
</bodyText>
<listItem confidence="0.9991186">
• When reconstructing an architecture, system stake-
holders have various concerns such as performance, re-
liability, portability or reusability; SAR should support
multiple architectural viewpoints.
• Reverse engineers are sometimes lost in the increas-
</listItem>
<bodyText confidence="0.768106571428571">
ing software complexity. SAR needs to be interactive,
iterative and parametrized.
On the other hand, source code is one of the few trust-
worthy reliable sources of information about the software
application which contains its actual architecture. However,
reconstructing the architecture from the source code raises
several problems:
</bodyText>
<listItem confidence="0.991868923076923">
• The large amount of data held by the source code raises
scalability issues.
• Since the considered systems are typically large, com-
plex and long-living, SAR should handle development
methods, languages and technologies that are often
heterogeneous and sometimes interleaved.
• Architecture is not explicitly represented at the source
code level. In addition, language concepts such as
polymorphism, late-binding, delegation, or inheritance
make it harder to analyze the code [130, 14]. How to
identify the relevant information to reach an architec-
tural level?
• The nature of software raises the questions of whether
</listItem>
<bodyText confidence="0.979395166666667">
dynamic information should be extracted as the sys-
tem is running, and then how do the behavioral aspects
appear in the architecture.
To summarize this section, the major challenge of SAR is
in abstracting, identifying and displaying higher-level views
from lower-level and often heterogeneous information.
</bodyText>
<sectionHeader confidence="0.784709" genericHeader="method">
3. SAR Taxonomy Axes
</sectionHeader>
<bodyText confidence="0.992131">
Mendonça et al. [78] classified SAR environments and
distinguished five families: filtering and clustering, com-
pliance checking, analysers generators, program under-
standing and architecture recognition. O’Brien et al. sur-
veyed SAR practice needs and approaches [85]. Gallagher
et al. [30] proposed a framework to assess architectural vi-
sualization tools. Guéhéneuc et al. [38] proposed a compar-
ative framework for design recovery tools. We propose a
more elaborated classification based on the life-time of SAR
presented in Figures 1 and 2): intended goals, followed pro-
cesses, required inputs, used techniques and expected out-
puts.
</bodyText>
<page confidence="0.574204">
2
</page>
<figure confidence="0.998991021276595">
Goals
Processes
Techniques
Outputs
InputsSAR
Hybrid
Bottom-Up
Top-Down
Semi-Automatic
Quasi-Manual
Quasi-Automatic
Abstraction
Investigation
Construction
Exploration
Architecture
Conformance
Analysis
Redocumentation
Reuse
Conformance
Analysis
Co-Evolution
Evolution
Related Artifacts
Non-Architectural
Architectural
Styles
Viewpoints
Graph Pattern Matching
Recognizers
State Engine
Maps
Horizontal
Vertical
Source Code
Dynamic Information
Historical Information
Physical Organization
Human Expertise
Human Organization
Textual Information
Graph Queries
Logic Queries
Programs
Lexical Queries
Relational Queries
</figure>
<figureCaption confidence="0.924634">
Figure 2. A process-oriented taxonomy
</figureCaption>
<figure confidence="0.92742525">
Goals
Inputs Techniques
Processes
Outputs
</figure>
<figureCaption confidence="0.7680115">
Figure 1. A process-oriented taxonomy flow
Goals. SAR is considered by the community as a proac-
</figureCaption>
<bodyText confidence="0.996418809523809">
tive approach realized to answer stakeholder business goals.
The reconstructed architecture is the basis for redocumen-
tation, reuse investigation and product line migration, or
implementation and architecture co-evolution. Some ap-
proaches do not extract the architecture itself but related and
orthogonal artifacts that provide valuable extra information
to engineers such as design patterns, roles or features.
Processes. We distinguish three kinds of SAR processes:
bottom-up, top-down or hybrid.
Inputs. Most SAR approaches are based on source code
information and human expertise. However, other kinds of
information can be exploited: dynamic information or his-
torical information. In addition, not all approaches support
the specification and use of architectural styles and view-
points which are the paramount of architecture.
Techniques. The research community has explored var-
ious techniques to reconstruct architecture that can be
roughly classified according to their automation level.
Outputs. While all SAR approaches intend to provide
architectural views, some of them however produce other
valuable outputs like conformance data.
</bodyText>
<sectionHeader confidence="0.97626" genericHeader="method">
4. SAR Goals
</sectionHeader>
<bodyText confidence="0.9911225">
We discuss now the goals of SAR as well as related arti-
facts.
</bodyText>
<subsectionHeader confidence="0.776534">
4.1. Goals
</subsectionHeader>
<bodyText confidence="0.968822">
Several authors categorized architecture roles in software
development [32]; in particular, Kazman et al. have a prag-
matic categorization of business goals [55]. In the context
</bodyText>
<page confidence="0.990886">
3
</page>
<bodyText confidence="0.989147096774194">
of maintenance, a SAR process answers stakeholder busi-
ness objectives. It must be considered as a proactive pro-
cess realized for future forward engineering tasks. SAR ap-
proaches match various often interleaved intentions:
Redocumentation and understanding: The primary goal
of SAR is to re-establish software abstractions. Re-
covered architectural views document software appli-
cations and help reverse engineers understand them.
For instance, the software bookshelf introduced by
Finningan et al. illustrates this goal [28]. Svetinovic
et al. state that not only the recovered architecture
is important, but also its rationale, i.e. why it is as
it is [114]. They focus on the architecture rationale
forces to recover the decisions made, their alternatives,
and why each one was or was not chosen.
Reuse investigation and product line migration:
Systematic reuse has not yet been achieved. Software
product lines allow one to share commonalities among
products while getting custom products. Architec-
tural views are useful to identify commonalities and
variabilities among products in a line [109, 93, 18, 23].
Conformance: To evolve a software application, it seems
hazardous to use the conceptual architecture because
it is often inaccurate with respect to the concrete one.
In this case, SAR is a means to check conformance
between the conceptual and the concrete architectures.
Murphy et al. introduced the reflexion model and RM-
Tool to bridge the gap between high-level architec-
tural models and the system’s source code [82]. Using
SAR, reverse engineer can check conformance of the
reconstructed architecture against rules or styles like
in the SAR tool [62], Nimeta [96], DiscoTect [136],
Focus [16, 76] and DAMRAM [75].
Co-evolution: Architecture and implementation are two
levels of abstraction that evolve at different speeds.
Ideally these abstractions should be synchronized to
avoid architectural drift. Tran et al. propose a method
to repair evolution anomalies between the conceptual
and the concrete architectures, possibly altering either
the conceptual architecture or the source code [120].
To dynamically maintain this synchronization, Wuyts
promotes logic meta-programming [134], and Mens
et al. exploit intensional source-code views and re-
lations through Intensive [134, 80]; Favre promotes
metaware [25]; Huang et al. propose a reflection me-
chanism too [51].
Analysis: In ArchView [89, 92], SAR and evolution anal-
ysis activities are interleaved. QADSAR is analysis-
oriented too [110, 111]. An analysis framework steers
a SAR framework so that it provides required architec-
tural views to compute architectural quality analyses.
This analysis assists stakeholders in their decision-
making processes. Moreover, flexible SAR environ-
ments such as Dali [57, 84] or Gupro [19] support
architectural analysis methods like SAAM [56] or
ATAM [58] thanks to exportation facilities.
Evolution and maintenance: SAR is also a first step to-
wards software evolution and maintenance. Focus is
one of these approaches [16, 76]. Its strength is that the
SAR scope is reduced to the system part which should
evolve. Krikhaar et al. also introduced a two-phase ap-
proach for evolving architecture based on SAR and on
change impact analyses [62, 63]. Huang et al. also
consider SAR in an evolution and maintenance per-
spective [51].
4.2. Related and Orthogonal Artifacts
Some approaches do not extract the architecture in it-
self but architectural correlated or side-effect artifacts that
crosscut or complement the architecture such as design pat-
terns, concerns, features, aspects, or roles and collabora-
tions. While such information is not directly related to the
architecture (i.e. view points, architecture), it provides valu-
able extra information [4]. These approaches consider that
higher level knowledge is necessary to extract valuable in-
formation at the architectural level and to improve the ex-
pressiveness of the reconstructed architectural views. Due
to space limitation, this topic is only briefly surveyed in this
paper.
It is well acknowledged that patterns play a key role
in software engineering and this whatever their abstraction
level [4, 8]. Some reverse engineering approaches conse-
quently are based on design pattern identification activi-
ties [1, 3, 46, 128, 5, 39].
Concerns are the stakeholders’ criterion for modulariz-
ing a software application into manageable and comprehen-
sible parts [98, 12]. Features and aspects are more specific
kinds of concerns. Features are considered in [131, 21, 87,
96, 36, 106] and aspect mining techniques in [10, 59, 83].
Source code artifacts interact together to fulfill software
behaviors. Wu et al. highlight that source code is structured
according a design in mind where software artifacts play
conceptual roles inside collaborations [133]. The recovery
of collaborations and roles was also explored in [95].
</bodyText>
<sectionHeader confidence="0.932457" genericHeader="method">
5. SAR Processes
</sectionHeader>
<bodyText confidence="0.8247155">
SAR follows either a bottom-up, a top-down or an hybrid
opportunistic process.
</bodyText>
<sectionHeader confidence="0.366288" genericHeader="method">
5.1. Bottom-Up Processes
</sectionHeader>
<bodyText confidence="0.824289">
Bottom-up processes start with low-level knowledge to
recover architecture. From source code models, they pro-
</bodyText>
<page confidence="0.98753">
4
</page>
<bodyText confidence="0.969100064516129">
gressively raise the abstraction level until a high-level un-
derstanding of the application is reached [7, 112].
Also called architecture recovery processes, bottom-up
processes are closely related to the well-known extract-
abstract-present cycle described by Tilley et al. [119].
Source code analyses populate a repository, which is
queried to yield abstract system representations, which are
then presented in a suitable interactive form to reverse engi-
neers.
Examples. Several tools support a bottom-up process
characterized by the extract-abstract-present metaphor:
PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84].
As an example, Dali works as follows: (1) Heteroge-
neous low-level knowledge is extracted from the software
implementation, fused and stored in a relational database.
(2) Using Rigi, one visualizes and manually abstracts this
information. (3) A reverse engineer can specify patterns us-
ing SQL queries and Perl expressions. The former selects
a set of source model entities and the latter treats this set
to abstract it. To summarize, Dali is a flexible workbench
around a central model storage. Based on Dali, Guo et al.
proposed ARM [40].
In Intensive, Mens et al. apply logic intension to group
related source-code entities structurally in a view [134, 80].
Reverse engineers incrementally define views and rela-
tions by means of intensions specified as Smalltalk or Soul
queries. Intensive classifies the views and displays consis-
tencies and inconsistencies with the code and between ar-
chitectural views.
Other bottom-up approaches for instance include
ArchView [89, 92], Revealer [90, 91] and ARES [23, 22].
</bodyText>
<sectionHeader confidence="0.436382" genericHeader="method">
5.2. Top-Down Processes
</sectionHeader>
<bodyText confidence="0.998677413793103">
Top-down processes start with high-level knowledge
such as requirements or architectural styles and aim to dis-
cover architecture by formulating conceptual hypotheses
and by matching them to the source code [103, 112]. The
term architecture discovery often describes such a process.
Examples. The Reflexion Model of Murphy et al. falls
into this category [82]. First, the reverse engineer defines
his high-level hypothesized views of the application. Sec-
ond, he specifies how his view maps to the source model.
Finally, RMTool identifies consistencies and inconsisten-
cies. Like that, the reverse engineer iteratively interprets
and computes successive reflexion models until satisfied.
Lungu et al. built both a method and a tool called Soft-
warenaut [71] to interactively explore hierarchical decom-
positions of software applications. Their method differs
from other classical exploration tools: to construct an archi-
tectural view on the fly, they enhance the exploration pro-
cess in guiding the reverse engineer towards the relevant hi-
erarchical parts. They characterize packages based on their
relation with the other ones and on their internal structure.
Categorizing such an approach shows the limit of a strict
classification. The approach takes into account physical en-
tities such as packages and does not check the conformance
to predefined views as in the Reflexion Model. Still, we
put it in this category since we considered that it flows from
abstract to concrete entities: the exploration activity starts
with the most abstract packages and iteratively open sub-
packages until to reach a relevant box and arrow view of the
software application.
</bodyText>
<subsectionHeader confidence="0.602233">
5.3. Hybrid Processes
</subsectionHeader>
<bodyText confidence="0.997929648648648">
Hybrid processes combine the previous two [112]. On
the one hand, low-level knowledge is abstracted up us-
ing various techniques. On the other hand, high-level
knowledge is refined. This kind of process is fre-
quently used to stop architectural erosion by reconciling
the conceptual and concrete architectures. Hybrid ap-
proaches often use hypothesis recognizers. Recognizer-
based tools provide bottom-up reverse engineering strate-
gies to support top-down exploration of architectural hy-
pothesis. ManSART [43, 137], ART [29], X-ray [79],
ARM [40] and DiscoTect [136] are examples of this ap-
proach. In ManSART, a top-down recognition engine maps
a style-compliant conceptual view with a system overview
which was defined using a visualization tool in a bottom-up
fashion.
Examples. Sartipi implemented a pattern-based SAR ap-
proach in Alborz [100, 101]. The architecture reconstruc-
tion consists of two phases. During the first bottom-up
phase, the source code is parsed, presented as a graph, then
divided in cohesive graph regions using data mining tech-
niques. This model is at a higher abstraction level than
the code. During the second top-down phase, the reverse
engineer iteratively specifies his hypothesized views of the
architecture in terms of patterns. These patterns are approx-
imately mapped with previous graph regions using graph
matching and clustering techniques. Finally, the reverse en-
gineer decides to proceed or not to a new iteration based on
the partially reconstructed architecture and evaluation infor-
mation provided by Alborz.
Christl et al. present an evolution of the Reflexion
Model [11]. They enhance it with automated clustering to
facilitate the mapping phase. As in the Reflexion Model, the
reverse engineer defines his hypothesized view of the archi-
tecture in a top-down process. However, instead of man-
ually mapping hypothetic entities with concrete ones, the
new method introduces clustering analysis to partially au-
tomate this step. The clustering algorithm groups currently
</bodyText>
<page confidence="0.974596">
5
</page>
<bodyText confidence="0.988782076923077">
unmapped concrete entities with concrete entities already
mapped to hypothesized entities.
To assess the creation of product lines, Stoermer et al.
introduce the MAP method [109]. MAP combines (1) a
bottom-up process, to recover the concrete architectures of
existing products; (2) a top-down process, to map architec-
tural styles onto recovered architectural views; (3) an ap-
proach to analyze commonalities and variabilities among
recovered architectures. They stress the ability of architec-
tural styles to act as the structural glue of the components,
and to highlight architecture strengths and weaknesses.
Other hybrid processes for instance include Focus [16,
76] and Nimeta [96].
</bodyText>
<sectionHeader confidence="0.872335" genericHeader="method">
6. SAR Inputs
</sectionHeader>
<bodyText confidence="0.982403625">
SAR essentially works on source code representations.
However, other kinds of information are sometimes consid-
ered such as dynamic information extracted from a system
as it is running or historical data held by version control
system repositories. In addition a few approaches take into
account architectural elements such as styles or viewpoints
as input to SAR. The current trend is to feed SAR with het-
erogeneous information of diverse abstraction levels.
</bodyText>
<subsectionHeader confidence="0.278604">
6.1. Non-Architectural Inputs
</subsectionHeader>
<bodyText confidence="0.992800746478873">
Source Code Constructs. The source code is an om-
nipresent trustworthy source of information that most ap-
proaches consider. Some of them query directly the source
code text like in RMTool [82]. However, most of them
are not directly based on the source code but represent
source code abstractions using different metamodels. These
metamodels cope with the paradigm of the analyzed soft-
ware. For instance, the language independent metamodel
Famix is used for reverse engineering object-oriented appli-
cations [15]; its concepts include classes, methods, calls or
accesses. Famix is used in ArchView [92, 89], Software-
naut [71] and Nimeta [96]. Other metamodels such as the
Dagstuhl Middle Metamodel [68] or GXL [50] have been
proposed.
Symbolic Textual Information. Some approaches con-
sider the symbolic information available in the com-
ments [90, 91] or in the name of the methods [65].
Dynamic Information. Static information is often insuf-
ficient for SAR since it only provides a limited insight into
the run-time nature of the analyzed software; dynamic in-
formation is more relevant to understand behavioral system
properties. Some SAR approaches use dynamic informa-
tion only [127, 136, 41] while others mix static and dy-
namic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect
uses runtime events such as method calls, CPU utilization
or network bandwidth consumption [136]. Huang et al. also
considered this kind of information because it may inform
reverse engineers on system security properties or system
performance aspects.
Some works focus more on dynamic software informa-
tion visualization [54, 116]; Hamou-Lhadj et al. present a
deeper survey of this domain [42]. There are approaches
based on dynamic information in areas adjacent to SAR:
feature extraction [21, 99, 36], design pattern localiza-
tion [128, 46], collaboration and role identification [95,
133]. Most of the time, dynamic information is generated
from instrumented source code and use-cases.
Physical Organization. ManSART [43, 137] and Soft-
warenaut [71] take into account the structural organization
of physical elements such as files, folders, or packages.
Human Organization. According to Conway [13]: “Or-
ganizations which design systems are constrained to pro-
duce designs which are copies of the communication struc-
tures of these organizations”. Inspired by Conway’s thesis,
Bowman et al. use the developer organization to form an
ownership architecture that helps reconstruct the software
architecture [6].
Historical Information. Historical information is rarely
used in SAR. Still ArchView is a recent approach that ex-
ploits source control system data and bug reports to analyze
the evolution of recovered architectural views [89, 92]. To
assist a reverse engineer to understand underlined depen-
dency gaps in a reflexion model [82], Hassan et al. annotate
entity dependencies with sticky notes. These sticky notes
record dependency evolution and rationale with information
extracted from version control systems [44].
Human Expertise. Although one cannot entirely trust
human knowledge, it is very helpful when it is available.
At high abstraction levels, SAR is iterative and requires
human knowledge to validate results and to guide it. As
Ivkovic et al. state [53], a SAR approach involves strat-
egy and knowledge of the domain and the application itself.
They propose to systematically update a knowledge base
that would become an helpful collection of domain-specific
architectural artifacts.
In current SAR approaches, it is frequent to specify a
conceptual architecture [82, 44, 76]. To define this architec-
ture, reverse engineers have to study system requirements,
read available documentation, interview stakeholders, re-
cover design rationale, investigate hypotheses and analyze
the business domain.
</bodyText>
<page confidence="0.98141">
6
</page>
<bodyText confidence="0.982061666666667">
Human expertise is also required when specifying view-
points, selecting architectural styles (Section 6.2), or inves-
tigating orthogonal artifacts (Section 4.2).
</bodyText>
<subsectionHeader confidence="0.899095">
6.2. Architectural Inputs
</subsectionHeader>
<bodyText confidence="0.998086897727273">
Architectural styles and viewpoints are the paramount of
software architecture, therefore we analyzed whether SAR
consider them.
Styles. Architectural styles are popular since like de-
sign patterns, they represent recurrent architectural situa-
tions [60]. They are valuable, expressive, and accepted ab-
stractions for SAR and more generally for software under-
standing. Recognizing them is however a challenge because
they basically span several architectural elements and can
be implemented in various ways [91]. The question that
turns up is whether SAR helps reverse engineers specify and
extract architectural styles.
Examples. Ding et al. proposed to use architectural styles
in Focus to infer a conceptual architecture that will be
mapped to a concrete architecture extracted from the source
code [16, 76].
Closely related to this work, Medvidovic et al. intro-
duced an approach to stop architectural erosion. In a top-
down process, requirements serve as high-level knowledge
to discover the conceptual architecture [75]. In a bottom-up
process, system implementation serves as low level knowl-
edge to recover the concrete architecture. Both the concep-
tual and the concrete architectures are incrementally built.
The reverse engineer reconciles the two architectures, based
on architectural styles. To select the most appropriate one,
they characterize each architectural style according to sev-
eral criteria. Their approach considers architectural styles
as key design idioms since they capture a large number of
design decisions, the rationale behind them, effective com-
positions of architectural elements, and system qualities that
will likely result from the style’s use.
Finally, DiscoTect considers architectural styles
too [136]. It generates program traces by running the
instrumented application. Then, it filters the traces and uses
a state engine that incrementally recognizes interleaved
execution patterns. In this way, DiscoTect reconstruct style-
compliant architecture since by choosing a state machine,
the reverse engineer defines and refines which hypothesized
architectural style the tool should look for [114].
ManSART [43, 137] and MAP [109] are other style-
based SAR approaches.
Viewpoints. As Holt states it: the architecture of a sys-
tem acts as a mental model shared among stakeholders [49].
Since the stakeholders’ interests in reverse engineering di-
verge, we must consider various viewpoints in SAR [52,
107]. Viewpoint catalogues were built to address this issue:
the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints
of Soni et al. [47, 108], the build-time viewpoint introduced
by Tu et al. [122] or the implicit viewpoints inherent to the
UML standard [123]. While most SAR approaches recon-
struct architectural views only according to a single view-
point or according to a few preselected ones, Smolander
et al. highlight that viewpoints cannot be standardized but
have to be selected or defined according to the environment
and the situation [107]. O’Brien et al. notably present the
View-Set Scenario pattern that helps determine which ar-
chitecture views sufficiently describe the system and cover
stakeholder needs [85].
Examples. The Symphony approach devised by
van Deursen et al. aims at reconstructing software ar-
chitecture using appropriate viewpoints [124]. Viewpoints
are selected from a catalogue or defined if they don’t exist.
Moreover, they evolve throughout the process. Chosen
viewpoints constrain SAR to provide architectural views
compliant to stakeholders’ expectations, ideally allowing
an immediate use of these views. For example, Symphony
authors highlight through four case studies some SAR
motivations such as checking the conformance of family
products to architectural rules. To do this they need to
provide to reverse engineers architectural views according
the viewpoints these reverse engineers typically use during
design. Riva proposed a view-based SAR approach called
Nimeta based on the Symphony one [96].
Favre outlines a generic SAR metamodel-driven ap-
proach called CacOphoNy [26]. Like Symphony, Ca-
cOphoNy recognizes the need to identify which viewpoints
are relevant for stakeholder concerns and have to be con-
sidered in SAR. Contrary to Symphony, CacOphoNy states
that metamodels are keys for representing viewpoints.
The QADSAR approach both reconstructs the architec-
ture of a system and drives quality attribute analyses on
it [110, 111]. To do this, QADSAR allows reverse engi-
neers to formulate their interests in reconstructing the ar-
chitecture by means of concrete quality attribute scenarios.
This results in the definition of relevant architectural view-
points.
ARES [23, 22] and SAR [62] also take viewpoints into
account.
</bodyText>
<sectionHeader confidence="0.628839" genericHeader="method">
7. SAR Techniques
</sectionHeader>
<bodyText confidence="0.99265825">
Techniques and the data they operate on are often cor-
related. For example, input information is represented re-
spectively as facts [80] or graphs [19] to use logic or graph
queries.
</bodyText>
<page confidence="0.994534">
7
</page>
<bodyText confidence="0.9977295">
SAR approaches use different techniques that we classi-
fied according to their automation level: quasi-manual, the
reverse engineer manually identifies architectural elements
using a tool to assist him to understand his findings; semi-
automatic, the reverse engineer manually instructs the tool
how to automatically discover refinements or recover ab-
stractions. quasi-automatic, the tool has the control and the
reverse engineer steers the iterative recovery process. Of
course, the boundaries between the classifications are not
clear-cut.
</bodyText>
<subsectionHeader confidence="0.537064">
7.1. Quasi-Manual Techniques
</subsectionHeader>
<bodyText confidence="0.994960428571429">
SAR is a reverse engineering activity which faces scala-
bility issues in manipulating knowledge. In response to this
problem, researchers have proposed slightly assisted SAR
approaches; we considered two categories.
Construction-based Techniques. These techniques re-
construct the software architecture by manually abstract-
ing low-level knowledge, thanks to interactive and expres-
sive visualization tools — Rigi [81, 113], PBS [28], Code-
Crawler [66].
Exploration-based Techniques. These techniques give
reverse engineers an architectural view of the system by
guiding them through the highest-level artifacts of the im-
plementation, like in Softwarenaut [71]. The architectural
view is then closely related to the developer’s view. Instead
of providing guidance, the SAB browser [24] allows re-
verse engineers to assign architectural layers to classes and
to navigate the resulting architectural views.
Gallagher et al. [30] surveyed other architecture visu-
alization tools: ArchView1 [27], the Searchable Book-
shelf [105], SoftArch [37], SoFi [9], LePUS [20] and Arch-
Vis [45].
</bodyText>
<subsectionHeader confidence="0.707417">
7.2. Semi-Automatic Techniques
</subsectionHeader>
<bodyText confidence="0.996387666666667">
Here the techniques automate repetitive aspects of SAR.
The reverse engineer steers the iterative refinement or ab-
straction leading to the identification of architectural ele-
ments.
Abstraction-based Techniques. These techniques are
based on technologies allowing reverse engineers to spec-
ify reusable abstraction rules and to execute them automat-
ically. They aim to map low-level concepts with high-level
concepts. Explored approaches are:
</bodyText>
<subsectionHeader confidence="0.447746">
1Different of Pinzger’s approach [89, 92], though homonymous.
</subsectionHeader>
<bodyText confidence="0.994317">
Graph queries: Gupro queries graphs using a specialized
declarative expression language called GReQL [19].
Rigi is based on graph transformations written in
Tcl [81, 113].
Relational queries: Often, relational algebra engines ab-
stract data of entity-relation databases. Dali uses SQL
queries to define grouping rules [57, 84]. Relational
algebra is used to define a repeatable set of transforma-
tions such as abstraction or decomposition for creating
a particular architectural view. Holt et al. propose the
Grok relational expression calculator to reason about
software facts [48]. Krikhaar presents a SAR approach
based on a Relational Algebra extension [62].
Logic queries: Mens and Wuyts uses Prolog as a meta pro-
gramming language to extract intensional source-code
views and relations in Intensive [134, 80]. Richner also
chose a logic query based approach to reconstruct ar-
chitectural views from static and dynamic facts [94].
Programs: Some approaches build analyses as programs.
For example, the analyses made in the Moose envi-
ronment are performed as object-oriented programs
that manipulate models representing the various in-
puts [17].
Lexical and structural queries: Some approaches are di-
rectly based on the lexical and structural information
in the source code. Pinzger et al. state that some hot-
spots clearly localize patterns in the source code and
consider them as the starting point of SAR [90, 91]. To
drive a pattern-supported architecture recovery, they
introduce a pattern specification language and the Re-
vealer tool.
Investigation-based Techniques. These techniques map
high-level concepts with low-level concepts. The high-level
concepts considered cover a wide area from architectural
descriptions, styles, and patterns to design patterns, con-
cerns, aspects, and features, that are orthogonal concepts to
architecture and that we do not treat in this paper for space
reasons (Section 4.2). Explored approaches are:
Recognizers. ManSART [43, 137], ART [29], X-ray [79]
and ARM [40] are based on a set of architectural
style or pattern recognizers written in a query lan-
guage. More precisely, pattern definitions in ARM are
progressively refined and finally transformed in SQL
queries exploitable in Dali [57, 84].
Graph pattern matching. In ARM, pattern definitions
can also be transformed into pattern graphs to match
with a graph-based source code representation like in
Alborz [100, 101].
State engine. In DiscoTect state machines are defined to
check architectural styles conformance [136]. A state
engine tracks at run-time the system execution and out-
puts architectural events when the execution satisfies
</bodyText>
<page confidence="0.992243">
8
</page>
<bodyText confidence="0.97172775">
the state machine description.
Maps. SAR approaches based on the Reflexion Model [82]
use rules to map hypothesized high-level entities with
source code entities.
</bodyText>
<subsectionHeader confidence="0.490989">
7.3. Quasi-Automatic Techniques
</subsectionHeader>
<bodyText confidence="0.987130341463414">
Pure automatic techniques failed in reconstructing soft-
ware architectures, and even if current techniques tend to-
wards an automatic process, reverse engineers must still
steer them. Concept, dominance, and cluster analysis tech-
niques are often combined.
The Bunch tool [73, 74] uses clustering algorithms to au-
tomatically partition software products into cohesive clus-
ters that are loosely interconnected [129]. Clustering al-
gorithms, based on hill climbing and genetic algorithms,
are applied on module dependency graphs extracted from
source code. The Bunch tool was extended to take into ac-
count human knowledge [74].
According to Xiao et al. [135], clustering techniques ap-
plied to dynamic analysis are as efficient as those applied
to static analysis, and this research area is promising and
unexplored.
The Bauhaus environment implements a wide number of
clustering techniques [61, 21, 11]. Koschke emphasizes the
need to refine existing clustering techniques, first by com-
bining them, and second by integrating the reverse engineer
as a conformance supervisor of the reconstruction process.
Adhering to Koschke’s thesis, Trifu unifies cluster and
dominance analysis techniques for the recovery of architec-
tural components in object-oriented legacy systems [121].
Similarly, Lundberg et al. outline a unified approach cen-
tered around dominance analysis [70]. On one hand,
they demonstrate how dominance analysis identifies passive
components. On the other hand, they state that dominance
analysis is not sufficient to recover the complete architec-
ture: it requires other techniques such as concept analysis to
take component interactions into account. Concept analysis
techniques were explored by Siff et al. [104], van Deursen
et al. [125], Arévalo [3, 2] or Eisenbarth et al. [21] and sur-
veyed by Tilley et al. [118].
8. SAR Outputs
While most approaches focus on producing presenta-
tions of software architectures, some provide valuable ad-
ditional information, like conformance data. It is not sur-
prising since SAR outputs are clearly related with goals that
lead to perform such an activity. In this section we highlight
some key aspects of these outputs.
</bodyText>
<subsectionHeader confidence="0.56843">
8.1. Architecture
</subsectionHeader>
<bodyText confidence="0.997482808510638">
Since SAR approaches are understanding-oriented, they
tend to present reconstructed architectural views to stake-
holders. As the code evolves some approaches focus on
the co-evolution of the reconstructed architectures: Inten-
sive [134, 80] synchronizes the architecture with its imple-
mentation; Focus [16, 76] or SAR [63] evolve the applica-
tion.
Visualization. Rigi [81, 113] is widely used to visualize
graph representations of software static views [28, 57, 18,
61, 91, 100, 96]. Rigi owes its success to its information
manipulation features—since it was originally intended to
reconstruct architectures—but also to its navigation capabil-
ities and to its RSF exchange format. The SHriMP visual-
ization technique enhances its navigation capabilities [113].
Several recent SAR tools [92, 80, 71] use Code-
Crawler [66] and its underlying polymetric view technique.
Riva [96] takes advantage of the strengths of different tar-
get visualization tools: SoftViz [117] and GraphViz [31]
for graph browsing and manipulating, Hava [97] for static
and dynamic information, and Rational Rose for UML di-
agrams. Focus [16, 76], Gupro [19], and the SWAGKit
pipeline [28] respectively use Rational Rose, GraphViz also
used in [74, 79], and LSEdit [115]. The SAB browser
is a dedicated graphical editor to navigate layer [24]. Pa-
cione proposed both a software-oriented visualization tool
Vanessa, and a taxonomy in which he surveyed related
tools [86].
As shown in Section 6, some SAR approaches focus on
the behavior of software. Hamou-Lhadj et al. surveyed
some of these tools dealing with visualization among oth-
ers considerations [42].
Description. Architecture Description Languages
(ADLs) have been proposed both to formally define archi-
tectures and to support architecture-centric development
activities [77]. In the scope of this paper, Darwin [72]
serves in X-ray [79] to define reconstructed architectural
views. It was also extended by Eixelsberger et al. for their
SAR approach [23, 22]. Acme [34] has ADL-like features
and is used in DiscoTect [136]. Huang et al. specify
architectures with the ABC ADL [51].
As said in Section 6.2, the notion of software architecture
heavily depends on the stakeholders’ interests. Since ADLs
have difficulty in taking different viewpoints into account
and focus on the module viewpoint, they are rarely used to
express reconstructed architectural views. To drive SAR in
CacOphoNy, Favre proposed to precisely define viewpoints
using metamodels [26].
</bodyText>
<page confidence="0.969085">
9
</page>
<subsectionHeader confidence="0.817752">
8.2. Conformance
</subsectionHeader>
<bodyText confidence="0.997335526315789">
We consider architecture conformance between similar
abstraction levels (horizontal conformance) and between
different abstraction levels (vertical conformance).
Horizontal Conformance is checked between two recon-
structed views, or between a conceptual and a concrete ar-
chitecture, or between a product line reference architecture
and the architecture of a given product. For example, SAR
approaches oriented towards a product line migration iden-
tify commonalities and variabilities among products, like in
MAP [109]. Sometimes SAR requires to define a concep-
tual architecture and to compare it with the reconstructed
concrete one [40, 120]. Sometimes, an architecture must
conform to architectural rules or styles; this was discussed
in Nimeta [96], the SAR tool [62], Focus [16, 76] and
DAMRAM [75] and DiscoTect [136].
Vertical Conformance assesses whether the recontructed
architecture conforms to the implementation. Both Reflex-
ion Model-based [82] and co-evolution-oriented [80] ap-
proaches revolve around vertical conformance.
</bodyText>
<subsectionHeader confidence="0.760386">
8.3. Analysis
</subsectionHeader>
<bodyText confidence="0.998979125">
Reverse engineers use modularity quality metrics either
to iteratively assess current results and steer the process, or
to get cues about reuse, system improvement Rigi [81, 113],
Bauhaus [61, 21, 11] or Alborz [100, 101] provide such
results.
A few SAR approaches are more analysis-oriented.
Archview [89, 92] provides structural and evolutionary
properties of a software application. Eixelsberger et al. in
ARES [23, 22], and Stoermer in QADSAR [110, 111] re-
construct software architectures to highlight properties like
safety, concurrency, portability or other high-level statis-
tics [51].
Approaches taking architectural patterns or orthogonal
artifacts into consideration highlight them. For instance,
ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight
architectural patterns.
</bodyText>
<sectionHeader confidence="0.984472" genericHeader="conclusions">
9. Conclusions
</sectionHeader>
<bodyText confidence="0.992892142857143">
In this paper we surveyed research works in the field of
software architecture reconstruction (SAR). To structure the
paper, we followed the general process of SAR: what are
the stakeholders’ goals; how does the general reconstruc-
tion proceed; what are the available sources of information;
based on this, which techniques can we apply, and finally
what kind of knowledge does the process provide. As usual
it is hard to classify research works in a multidisciplinary
domain, so in this paper we focused on the approaches most
related to architecture reconstruction; as future work several
related artifacts should be examined: design pattern identifi-
cation, aspect mining. We also plan to identify lacks and fu-
ture research axes in the field as well as providing an analy-
sis of the pros and cons of the categorized approaches when
it is possible.
Acknowledgments. We gratefully acknowledge the fi-
nancial support of the french ANR (National Research
Agency) for the project “COOK: Réarchitecturisation des
applications industrielles objets” (JC05 42872). We would
like to thanks Tudor Girba and Orla Greevy for the early
feedback on the paper.
</bodyText>
<sectionHeader confidence="0.93457" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.527752926829268">
[1] Antoniol, Fiutem, and Cristoforetti. Design pattern recov-
ery in object-oriented software. In IWPC, pp. 153–160,
1998.
[2] Arévalo. High Level Views in Object-Oriented Systems us-
ing Formal Concept Analysis. PhD thesis, Univ. Berne,
Berne, Jan. 2005.
[3] Arévalo, Buchli, and Nierstrasz. Detecting implicit collab-
oration patterns. In WCRE, pp. 122–131. IEEE CS, Nov.
2004.
[4] Beck and Johnson. Patterns generate architectures. In
ECOOP, vol. 821 of LNCS, pp. 139–149, 1994.
[5] Beyer and Lewerentz. CrocoPat: A tool for efficient pattern
recognition in large object-oriented programs. Tech. Report
I-04/2003, Univ. Cottbus, 2003.
[6] Bowman and Holt. Software architecture recovery using
conway’s law. In CASCON, p. 6, 1998.
[7] Brooks. Towards a theory of the comprehension of com-
puter programs. Int’l Journal of Man-Machine Studies, pp.
543–554, 1983.
[8] Buschmann, Meunier, Rohnert, Sommerlad, and Stad.
Pattern-Oriented Software Architecture — A System of Pat-
terns. 1996.
[9] Carmichael, Tzerpos, and Holt. Design maintenance: Un-
expected architectural interactions. vol. 00, p. 134. IEEE
CS, 1995.
[10] Ceccato, Marin, Mens, Moonen, Tonella, and Tourwe. A
qualitative comparison of three aspect mining techniques.
vol. 00, pp. 13–22, 2005.
[11] Christl, Koschke, and Storey. Equipping the reflexion
method with automated clustering. In WCRE, pp. 89–98.
[12] Coelho and Murphy. Presenting crosscutting structure with
active models. In AOSD, pp. 158–168, 2006.
[13] Conway. How do committees invent? Datamation,
14(4):28–31, 1968.
[14] Demeyer, Ducasse, and Lanza. A hybrid reverse engineer-
ing platform combining metrics and program visualization.
In WCRE, 1999.
[15] Demeyer, Tichelaar, and Ducasse. FAMIX 2.1 — The
FAMOOS Information Exchange Model. Tech. report,
Univ. of Bern, 2001.
[16] Ding and Medvidovic. Focus: A light-weight, incremental
</reference>
<page confidence="0.99898">
10
</page>
<bodyText confidence="0.981673">
approach to software architecture recovery and evolution.
In WICSA, pp. 191–, 2001.
</bodyText>
<reference confidence="0.980727254385965">
[17] Ducasse, Gı̂rba, Lanza, and Demeyer. Moose: a collabo-
rative and extensible reengineering Environment. In Tools
for Sw. Maint. and Reeng., RCOST / Software Technology
Series, pp. 55–71. 2005.
[18] Dueñas, de Oliveira, and de la Puente. Architecture recov-
ery for software evolution. In CSMR, pp. 113–120, 1998.
[19] Ebert, Kullbach, Riediger, and Winter. GUPRO – generic
understanding of programs, an overview. Tech. Report 7–
2002, Univ. Koblenz-Landau, 2002.
[20] Eden. Visualization of object oriented architectures. In
ICSE, May 2001.
[21] Eisenbarth, Koschke, and Simon. Locating Features in
Source Code. IEEE Computer, 29(3):210–224, 2003.
[22] Eixelsberger and Gall. Describing software architectures by
system structure and properties. In COMPSAC, pp. 106–
111, 1998.
[23] Eixelsberger, Ogris, Gall, and Bellay. Software architecture
recovery of a program family. In ICSE, pp. 508–511, 1998.
[24] Erben and Löhr. Sab - the software architecture browser. In
VISSOFT. IEEE CS, Sept. 2005.
[25] Favre. Meta-model and model co-evolution within the 3d
software space. In ELISA, 2003.
[26] Favre. CacOphoNy: Metamodel-driven software architec-
ture reconstruction. In WCRE, pp. 204–213, 2004.
[27] Feijs and de Jong. 3d visualization of software architec-
tures. vol. 41, pp. 72–78, 1998.
[28] Finnigan, Holt, Kalas, Kerr, Kontogiannis, Mueller, My-
lopoulos, Perelgut, Stanley, and Wong. The software book-
shelf. IBM Systems Journal, 36(4):564–593, 1997.
[29] Fiutem, Tonella, Antoniol, and Merlo. A cliché-based en-
vironment to support architectural reverse engineering. In
ICSM. IEEE, 1996.
[30] Gallagher, Hatch, and Munro. A framework for software
architecture visualisation assessment. In VISSOFT. IEEE
CS, Sept. 2005.
[31] Gansner and North. An open graph visualization system
and its applications to software engineering. Softw. Pract.
Exper., 30(11):1203–1233, 2000.
[32] Garlan. Software architecture: a roadmap. In ICSE - Future
of SE Track, pp. 91–101, 2000.
[33] Garlan, Allen, and Ockerbloom. Architectural mismatch:
Why reuse is so hard. IEEE Software, 12(6):17–26, 1995.
[34] Garlan, Monroe, and Wile. Acme: An architecture de-
scription interchange language. In CASCON, pp. 169–183,
1997.
[35] Garlan and Perry. Introduction to the special issue on soft-
ware architecture. IEEE TSE, 21(4), 1995.
[36] Greevy and Ducasse. Correlating features and code using a
compact two-sided trace analysis approach. In CSMR, pp.
314–323, 2005.
[37] Grundy and Hosking. High-level static and dynamic visu-
alization of software architectures. vol. 00, p. 5. IEEE CS,
2000.
[38] Guéhéneuc, Mens, and Wuyts. A comparative framework
for design recovery tools. In CSMR. IEEE CS, 2006.
[39] Guéhéneuc, Sahraoui, and Zaidi. Fingerprinting design pat-
terns. In WCRE, pp. 172–181, 2004.
[40] Y. Guo, Atlee, and Kazman. A software architecture recon-
struction method. In WICSA, pp. 15–34, 1999.
[41] Hamou-Lhadj, Braun, Amyot, and Lethbridge. Recovering
behavioral design models from execution traces. In CSMR.
IEEE CS, 2005.
[42] Hamou-Lhadj and Lethbridge. A survey of trace explo-
ration tools and techniques. In CASCON, pp. 42–55, 2004.
[43] Harris, Reubenstein, and Yeh. Reverse engineering to the
architectural level. In ICSE, 1995.
[44] Hassan and Holt. Using development history sticky notes
to understand software architecture. iwpc, 00:183, 2004.
[45] Hatch. Software Architecture Visualisation. Ph.D. thesis,
Univ. Durham, Mar. 2004.
[46] Heuzeroth, Holl, Hogstrom, and Lowe. Automatic design
pattern detection. iwpc, 00:94, 2003.
[47] Hofmeister, Nord, and Soni. Applied Software Architecture.
2000.
[48] Holt. Structural manipulations of software architecture us-
ing tarski relational algebra. In WCRE, pp. 210–219, 1998.
ISBN: 0-8186-89-67-6.
[49] Holt. Sofware architecture as a shared mental model. In
ASERC Workshop on Software Architecture, Univ. of Al-
berta, 2001.
[50] Holt, Schürr, Sim, and Winter. Gxl: A graph-based standard
exchange format for reengineering. Science of Computer
Programming, 60(2):149–170, 4 2006.
[51] Huang, Mei, and Yang. Runtime recovery and manipula-
tion of software architecture of component-based systems.
vol. 13, pp. 257–281, 2006.
[52] IEEE. Ieee recommended practice for architectural descrip-
tion for software-intensive systems. Tech. report, Arch.
Work. Group of the Sw.Eng. Committee, 2000.
[53] Ivkovic and Godfrey. Enhancing domain-specific software
architecture recovery. In IWPC, p. 266, 2003.
[54] Jerding and Rugaber. Using visualization for architectural
localization and extraction. In WCRE, pp. 56–65, 1997.
[55] Kazman and Bass. Categorizing business goals for software
architectures. CMU/SEI-2005-TR-021, CMU SEI, 2005.
[56] Kazman, Bass, Webb, and Abowd. Saam: A method for
analyzing the properties of software architectures. In ICSE,
pp. 81–90, 1994.
[57] Kazman and Carrière. Playing detective: Reconstructing
software architecture from available evidence. ASE, 1999.
[58] Kazman, Klein, Barbacci, Longstaff, Lipson, and Carrière.
The architecture tradeoff analysis method. In ICECCS, pp.
68–78, 1998.
[59] Kellens and Mens. A survey of aspect mining tools and
techniques. Tech. Report INGI TR 2005-07, UCL, Bel-
gium, 2005.
[60] Klein, Kazman, Bass, Carrière, Barbacci, and Lipson.
Attribute-based architecture styles. In WICSA, pp. 225–
244, 1999.
[61] Koschke. Atomic Architectural Component Recovery for
Program Understanding and Evolution. PhD thesis, Univ.
Stuttgart, 2000.
[62] Krikhaar. Software Architecture Reconstruction. PhD the-
sis, Univ. Amsterdam, 1999.
</reference>
<page confidence="0.995002">
11
</page>
<reference confidence="0.99963100862069">
[63] Krikhaar, Postma, Sellink, Stroucken, and Verhoef. A two-
phase process for software architecture improvement. In
ICSM, p. 371, 1999.
[64] Kruchten. The 4+1 view model of architecture. IEEE Soft-
ware, 12(6):42–50, 1995.
[65] Kuhn, Ducasse, and Gı̂rba. Enriching reverse engineering
with semantic clustering. In WCRE, pp. 113–122, 2005.
[66] Lanza and Ducasse. Polymetric views—A lightweight vi-
sual approach to reverse engineering. vol. 29, pp. 782–795.
IEEE CS, 2003.
[67] Lehman and Belady. Program Evolution: Processes of Soft-
ware Change. 1985.
[68] Lethbridge, Tichelaar, and Plödereder. The dagstuhl middle
metamodel: A schema for reverse engineering. In Elec.
Notes in Theoretical Comp. Sci., vol. 94, pp. 7–18, 2004.
[69] Li, Chu, Hu, Chen, and Yun. Architecture recovery and
abstraction from the perspective of processes. In WCRE,
pp. 57–66, 2005.
[70] Lundberg and Löwe. Architecture recovery by semi-
automatic component identification. Electr. Notes Theor.
Comput. Sci., 82(5), 2003.
[71] Lungu, Lanza, and Gı̂rba. Package patterns for visual ar-
chitecture recovery. In CSMR 2006, 2006.
[72] Magee, Dulay, Eisenbach, and Kramer. Specifying dis-
tributed software architectures. In ESEC, vol. 989 of LNCS,
pp. 137–153. Springer-Verlag, Sept. 1995.
[73] Mancoridis and Mitchell. Using Automatic Clustering to
produce High-Level System Organizations of Source Code.
In IWPC, 1998.
[74] Mancoridis, Mitchell, Chen, and Gansner. Bunch: A Clus-
tering Tool for the Recovery and Maintenance of Software
System Structures. In ICSM, 1999.
[75] Medvidovic, Egyed, and Gruenbacher. Stemming architec-
tural erosion by architectural discovery and recovery. In
STRAW, 2003.
[76] Medvidovic and Jakobac. Using software evolution to focus
architectural recovery. vol. 13, pp. 225–256, 2006.
[77] Medvidovic and Taylor. A classification and comparison
framework for software architecture description languages.
vol. 26, pp. 70–93, 2000.
[78] Mendonça and Kramer. Requirements for an effective ar-
chitecture recovery framework. In ISAW-2 and Viewpoints
workshops, pp. 101–105, 1996.
[79] Mendonça and Kramer. An approach for recovering dis-
tributed system architectures. vol. 8, pp. 311–354, 2001.
[80] Mens, Kellens, Pluquet, and Wuyts. Co-evolving code and
design with intensional views – a case study. Journal of
Computer Languages, Systems and Structures, 32(2):140–
156, 2006.
[81] Müller, Wong, and Tilley. Understanding software systems
using reverse engineering technology. In Object-Oriented
Technology for Database and Software Systems, pp. 240–
252. 1995.
[82] Murphy, Notkin, and Sullivan. Software reflexion models:
Bridging the gap between source and high-level models. In
SIGSOFT, pp. 18–28, 1995.
[83] Nora, Said, and Fadila. A comparative classification of as-
pect mining approaches. Journal of Computer Science 2,
4:322–325, 2006.
[84] O’Brien and Stoermer. Architecture reconstruction case
study. CMU/SEI-2003-TN-008, CMU SEI, 2003.
[85] O’Brien, Stoermer, and Verhoef. Software architecture
reconstruction: Practice needs and current approaches.
Cmu/sei-2002-tr-024, esc-tr-2002-024, CMU SEI, 2002.
[86] Pacione. A Novel Software Visualisation Model to Sup-
port Object-Oriented Program Comprehension. PhD the-
sis, Nov. 2005.
[87] Pashov and Riebisch. Using feature modeling for pro-
gram comprehension and software architecture recovery. In
ECBS, pp. 406–418, 2004.
[88] Perry and Wolf. Foundations for the study of software ar-
chitecture. ACM SIGSOFT Software Engineering Notes,
17(4):40–52, 1992.
[89] Pinzger. ArchView - Analyzing Evolutionary Aspects of
Complex Software Systems. PhD thesis, Univ. Vienna,
2005.
[90] Pinzger, Fischer, Gall, and Jazayeri. Revealer: A lexical
pattern matcher for architecture recovery. In WCRE, pp.
170–178, 2002.
[91] Pinzger and Gall. Pattern-supported architecture recovery.
In IWPC, pp. 53–61, 2002.
[92] Pinzger, Gall, Fischer, and Lanza. Visualizing multiple evo-
lution metrics. In SoftVis 2005, pp. 67–75, 2005.
[93] Pinzger, Gall, Girard, Knodel, Riva, Pasman, Broerse, and
Wijnstra. Architecture recovery for product families. In
PFE-5, LNCS 3014, pp. 332–351, 2004.
[94] Richner and Ducasse. Recovering high-level views of
object-oriented applications from static and dynamic infor-
mation. In ICSM, pp. 13–22, 1999.
[95] Richner and Ducasse. Using dynamic information for the it-
erative recovery of collaborations and roles. In ICSM, 2002.
[96] Riva. View-based Software Architecture Reconstruction.
PhD thesis, Univ. Vienna, 2004.
[97] Riva and Rodriguez. Combining static and dynamic views
for architecture reconstruction. CSMR, 00, 2002.
[98] Robillard and Murphy. Concern graphs: finding and de-
scribing concerns using structural program dependencies.
In ICSE, pp. 406–416, 2002.
[99] Salah and Mancoridis. A hierarchy of dynamic software
views: from object-interactions to feature-interacions. In
ICSM, 2004.
[100] Sartipi. Software Architecture Recovery based on Pattern
Matching. PhD thesis, Univ. Waterloo, CA, 2003.
[101] Sartipi, Yee, and Safyallah. Alborz: An interactive toolkit
to extract static and dynamic views of a software system. In
ICPC, 2006. To appear.
[102] Shaw and Garlan. Software Architecture: Perspectives on
an Emerging Discipline. Prentice-Hall, 1996.
[103] Shneiderman. Software Psychology: Human Factors in
Computer and Information Systems. Winthrop Publishers,
1980.
[104] Siff and Reps. Identifying Modules via Concept Analysis.
In ICSM, pp. 170–179, 1997.
[105] Sim, Clarke, Holt, and Cox. Browsing and searching soft-
ware architectures. vol. 00, p. 381, 1999.
[106] Smith and Munro. Identifying structural features of java
</reference>
<page confidence="0.941216">
12
</page>
<reference confidence="0.997242902439025">
programs by analysing the interaction of classes at runtime.
In VISSOFT. IEEE CS, Sept. 2005.
[107] Smolander, Hoikka, Isokallio, Kataikko, Mkel, and Klvi-
inen. Required and optional viewpoints what is included
in software architecture? Tech. report, Univ. Lappeenranta,
2001.
[108] Soni, Nord, and Hofmeister. Software architecture in in-
dustrial applications. In ICSE, pp. 196–207, 1995.
[109] Stoermer and O’Brien. Map - Mining architectures for
product line evaluations. In WICSA, vol. 00, p. 35, 2001.
[110] Stoermer, O’Brien, and Verhoef. Moving towards quality
attribute driven software architecture reconstruction. vol. 0,
p. 46, 2003.
[111] Stoermer, Rowe, O’Brien, and Verhoef. Model-centric soft-
ware architecture reconstruction. vol. 36, pp. 333–363,
2006.
[112] Storey, Fracchia, and Müller. Cognitive Design Elements to
Support the Construction of a Mental Model during Soft-
ware Exploration. Journal of Software Systems, 44:171–
185, 1999.
[113] Storey and Müller. Manipulating and Documenting Soft-
ware Structures using SHriMP Views. In ICSM, pp. 275–
284, 1995.
[114] Svetinovic and Godfrey. A lightweight architecture recov-
ery process. In WCRE, Oct. 2001.
[115] Synytskyy, Holt, and Davis. Browsing software architec-
tures with lsedit. In IWPC, pp. 176–178, 2005.
[116] Systä. Static and Dynamic Reverse Engineering Techniques
for Java Software Systems. PhD thesis, Univ. Tampere,
2000.
[117] Telea, Maccari, and Riva. An open visualization toolkit for
reverse architecting. iwpc, 00:3, 2002.
[118] Tilley, Cole, Becker, and Eklund. A Survey of Formal Con-
cept Analysis Support for Software Engineering Activities.
In ICFCA, 2003.
[119] Tilley, Smith, and Paul. Towards a framework for program
understanding. In WPC, p. 19, 1996.
[120] Tran and Holt. Forward and reverse repair of software ar-
chitecture. In CASCON, 1999.
[121] Trifu. Using Cluster Analysis in the Architecture Recovery
of Object-Oriented Systems. PhD thesis, Univ. Karlsruhe,
2001.
[122] Tu and Godfrey. The build-time software architecture view.
In ICSM, pp. 398–407, 2001.
[123] Unified Modeling Language 1.5 spec. Tech. report, Mar.
2003.
[124] van Deursen, Hofmeister, Koschke, Moonen, and Riva.
Symphony: View-driven software architecture reconstruc-
tion. In WICSA, pp. 122–134, 2004.
[125] van Deursen and Kuipers. Identifying Objects using Cluster
and Concept Analysis. In ICSE, pp. 246–255, 1999.
[126] Vasconcelos and Werner. Software architecture recovery
based on dynamic analysis. In 18th Brazilian Symp. on
Softw. Eng., 2004.
[127] Walker, Murphy, Freeman-Benson, Wright, Swanson, and
Isaak. Visualizing dynamic software system information
through high-level models. In OOPSLA, pp. 271–283,
1998.
[128] Wendehals. Improving design pattern instance recognition
by dynamic analysis. In WODA, 2003.
[129] Wiggerts. Using Clustering Algorithms in Legacy Systems
Remodularization. In WCRE, pp. 33–43, 1997.
[130] Wilde and Huitt. Maintenance Support for Object-Oriented
Programs. IEEE TSE, SE-18(12):1038–1044, 1992.
[131] Wilde and Scully. Software reconnaisance: Mapping pro-
gram features to code. Software Maintenance: Research
and Practice, 7(1):49–62, 1995.
[132] Woods, Carrière, and Kazman. The perils and joys of re-
constructing architectures, 1999.
[133] Wu, Sahraoui, and Valtchev. Program comprehension with
dynamic recovery of code collaboration patterns and roles.
In CASCON, pp. 56–67, 2004.
[134] Wuyts. A Logic Meta-Programming Approach to Support
the Co-Evolution of Object-Oriented Design and Imple-
mentation. PhD thesis, Vrije Universiteit Brussel, 2001.
[135] Xiao and Tzerpos. Software clustering based on dynamic
dependencies. csmr, 00:124–133, 2005.
[136] Yan, Garlan, Schmerl, Aldrich, and Kazman. Discotect: A
system for discovering architectures from running systems.
In ICSE, pp. 470–479, 2004.
[137] Yeh, Harris, and Chase. Manipulating recovered software
architecture views. In ICSE, pp. 184–194, 1997.
</reference>
<page confidence="0.999601">
13
</page>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.553534">
<title confidence="0.99823">A Process-Oriented Software Architecture Reconstruction Taxonomy</title>
<author confidence="0.835309">Stéphane Ducasse Damien Pollet Loı̈c Poyet</author>
<affiliation confidence="0.8262415">LISTIC - Language and Software Evolution Group Université de Savoie, France</affiliation>
<note confidence="0.967731">Accepted to CSMR 2007</note>
<abstract confidence="0.998520357142857">To maintain and understand large applications, it is crucial to know their architecture. The first problem is that architectures are not explicitly represented in the code as classes and packages are. The second problem is that successful applications evolve over time so their architecture inevitably drifts. Reconstructing and checking whether the architecture is still valid is thus an important aid. While there is a plethora of approaches and techniques supporting architecture reconstruction, there is no comprehensive state of the art and it is often difficult to compare the approaches. This article presents a first state of the art in software architecture reconstruction, with the desire to support the understanding of the field.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Fiutem Antoniol</author>
<author>Cristoforetti</author>
</authors>
<title>Design pattern recovery in object-oriented software.</title>
<date>1998</date>
<booktitle>In IWPC,</booktitle>
<pages>153--160</pages>
<contexts>
<context position="15250" citStr="[1, 3, 46, 128, 5, 39]" startWordPosition="2287" endWordPosition="2292">architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processe</context>
</contexts>
<marker>[1]</marker>
<rawString>Antoniol, Fiutem, and Cristoforetti. Design pattern recovery in object-oriented software. In IWPC, pp. 153–160, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Arevalo</author>
</authors>
<title>High Level Views in Object-Oriented Systems using Formal Concept Analysis.</title>
<date>2005</date>
<tech>PhD thesis,</tech>
<institution>Univ.</institution>
<location>Berne, Berne,</location>
<contexts>
<context position="38237" citStr="[3, 2]" startWordPosition="5727" endWordPosition="5728">inance analysis techniques for the recovery of architectural components in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance analysis is not sufficient to recover the complete architecture: it requires other techniques such as concept analysis to take component interactions into account. Concept analysis techniques were explored by Siff et al. [104], van Deursen et al. [125], Arevalo [3, 2] or Eisenbarth et al. [21] and surveyed by Tilley et al. [118]. 8. SAR Outputs While most approaches focus on producing presentations of software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolut</context>
</contexts>
<marker>[2]</marker>
<rawString>Arévalo. High Level Views in Object-Oriented Systems using Formal Concept Analysis. PhD thesis, Univ. Berne, Berne, Jan. 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Buchli Arevalo</author>
<author>Nierstrasz</author>
</authors>
<title>Detecting implicit collaboration patterns.</title>
<date>2004</date>
<booktitle>In WCRE,</booktitle>
<pages>122--131</pages>
<contexts>
<context position="15250" citStr="[1, 3, 46, 128, 5, 39]" startWordPosition="2287" endWordPosition="2292">architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processe</context>
<context position="38237" citStr="[3, 2]" startWordPosition="5727" endWordPosition="5728">inance analysis techniques for the recovery of architectural components in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance analysis is not sufficient to recover the complete architecture: it requires other techniques such as concept analysis to take component interactions into account. Concept analysis techniques were explored by Siff et al. [104], van Deursen et al. [125], Arevalo [3, 2] or Eisenbarth et al. [21] and surveyed by Tilley et al. [118]. 8. SAR Outputs While most approaches focus on producing presentations of software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolut</context>
</contexts>
<marker>[3]</marker>
<rawString>Arévalo, Buchli, and Nierstrasz. Detecting implicit collaboration patterns. In WCRE, pp. 122–131. IEEE CS, Nov. 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Beck</author>
<author>Johnson</author>
</authors>
<title>Patterns generate architectures.</title>
<date>1994</date>
<booktitle>In ECOOP,</booktitle>
<volume>821</volume>
<pages>139--149</pages>
<contexts>
<context position="14717" citStr="[4]" startWordPosition="2209" endWordPosition="2209"> a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some approaches do not extract the architecture in itself but architectural correlated or side-effect artifacts that crosscut or complement the architecture such as design patterns, concerns, features, aspects, or roles and collaborations. While such information is not directly related to the architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a softw</context>
</contexts>
<marker>[4]</marker>
<rawString>Beck and Johnson. Patterns generate architectures. In ECOOP, vol. 821 of LNCS, pp. 139–149, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>CrocoPat</author>
</authors>
<title>A tool for efficient pattern recognition in large object-oriented programs.</title>
<date>2003</date>
<tech>Tech. Report I-04/2003,</tech>
<institution>Univ.</institution>
<location>Cottbus,</location>
<contexts>
<context position="15250" citStr="[1, 3, 46, 128, 5, 39]" startWordPosition="2287" endWordPosition="2292">architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processe</context>
</contexts>
<marker>[5]</marker>
<rawString>Beyer and Lewerentz. CrocoPat: A tool for efficient pattern recognition in large object-oriented programs. Tech. Report I-04/2003, Univ. Cottbus, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bowman</author>
<author>Holt</author>
</authors>
<title>Software architecture recovery using conway’s law.</title>
<date>1998</date>
<booktitle>In CASCON,</booktitle>
<pages>6</pages>
<contexts>
<context position="25076" citStr="[6]" startWordPosition="3785" endWordPosition="3785"> time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software architecture [6]. Historical Information. Historical information is rarely used in SAR. Still ArchView is a recent approach that exploits source control system data and bug reports to analyze the evolution of recovered architectural views [89, 92]. To assist a reverse engineer to understand underlined dependency gaps in a reflexion model [82], Hassan et al. annotate entity dependencies with sticky notes. These sticky notes record dependency evolution and rationale with information extracted from version control systems [44]. Human Expertise. Although one cannot entirely trust human knowledge, it is very helpf</context>
</contexts>
<marker>[6]</marker>
<rawString>Bowman and Holt. Software architecture recovery using conway’s law. In CASCON, p. 6, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Brooks</author>
</authors>
<title>Towards a theory of the comprehension of computer programs.</title>
<date>1983</date>
<journal>Int’l Journal of Man-Machine Studies,</journal>
<pages>543--554</pages>
<contexts>
<context position="16177" citStr="[7, 112]" startWordPosition="2431" endWordPosition="2432">act together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system representations, which are then presented in a suitable interactive form to reverse engineers. Examples. Several tools support a bottom-up process characterized by the extract-abstract-present metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted </context>
</contexts>
<marker>[7]</marker>
<rawString>Brooks. Towards a theory of the comprehension of computer programs. Int’l Journal of Man-Machine Studies, pp. 543–554, 1983.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Meunier Buschmann</author>
<author>Sommerlad Rohnert</author>
<author>Stad</author>
</authors>
<date>1996</date>
<booktitle>Pattern-Oriented Software Architecture — A System of Patterns.</booktitle>
<contexts>
<context position="15123" citStr="[4, 8]" startWordPosition="2271" endWordPosition="2272">oncerns, features, aspects, or roles and collaborations. While such information is not directly related to the architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play co</context>
</contexts>
<marker>[8]</marker>
<rawString>Buschmann, Meunier, Rohnert, Sommerlad, and Stad. Pattern-Oriented Software Architecture — A System of Patterns. 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tzerpos Carmichael</author>
<author>Holt</author>
</authors>
<title>Design maintenance: Unexpected architectural interactions.</title>
<date>1995</date>
<volume>00</volume>
<pages>134</pages>
<publisher>IEEE CS,</publisher>
<contexts>
<context position="33078" citStr="[9]" startWordPosition="4964" endWordPosition="4964">wler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs </context>
</contexts>
<marker>[9]</marker>
<rawString>Carmichael, Tzerpos, and Holt. Design maintenance: Unexpected architectural interactions. vol. 00, p. 134. IEEE CS, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Marin Ceccato</author>
<author>Moonen Mens</author>
<author>Tonella</author>
<author>Tourwe</author>
</authors>
<title>A qualitative comparison of three aspect mining techniques.</title>
<date>2005</date>
<volume>00</volume>
<pages>13--22</pages>
<contexts>
<context position="15540" citStr="[10, 59, 83]" startWordPosition="2336" endWordPosition="2338">space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstraction level until a high-level understanding o</context>
</contexts>
<marker>[10]</marker>
<rawString>Ceccato, Marin, Mens, Moonen, Tonella, and Tourwe. A qualitative comparison of three aspect mining techniques. vol. 00, pp. 13–22, 2005.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Koschke Christl</author>
<author>Storey</author>
</authors>
<title>Equipping the reflexion method with automated clustering.</title>
<booktitle>In WCRE,</booktitle>
<pages>89--98</pages>
<contexts>
<context position="21005" citStr="[11]" startWordPosition="3166" endWordPosition="3166">ohesive graph regions using data mining techniques. This model is at a higher abstraction level than the code. During the second top-down phase, the reverse engineer iteratively specifies his hypothesized views of the architecture in terms of patterns. These patterns are approximately mapped with previous graph regions using graph matching and clustering techniques. Finally, the reverse engineer decides to proceed or not to a new iteration based on the partially reconstructed architecture and evaluation information provided by Alborz. Christl et al. present an evolution of the Reflexion Model [11]. They enhance it with automated clustering to facilitate the mapping phase. As in the Reflexion Model, the reverse engineer defines his hypothesized view of the architecture in a top-down process. However, instead of manually mapping hypothetic entities with concrete ones, the new method introduces clustering analysis to partially automate this step. The clustering algorithm groups currently 5 unmapped concrete entities with concrete entities already mapped to hypothesized entities. To assess the creation of product lines, Stoermer et al. introduce the MAP method [109]. MAP combines (1) a bot</context>
<context position="37369" citStr="[61, 21, 11]" startWordPosition="5599" endWordPosition="5601">clustering algorithms to automatically partition software products into cohesive clusters that are loosely interconnected [129]. Clustering algorithms, based on hill climbing and genetic algorithms, are applied on module dependency graphs extracted from source code. The Bunch tool was extended to take into account human knowledge [74]. According to Xiao et al. [135], clustering techniques applied to dynamic analysis are as efficient as those applied to static analysis, and this research area is promising and unexplored. The Bauhaus environment implements a wide number of clustering techniques [61, 21, 11]. Koschke emphasizes the need to refine existing clustering techniques, first by combining them, and second by integrating the reverse engineer as a conformance supervisor of the reconstruction process. Adhering to Koschke’s thesis, Trifu unifies cluster and dominance analysis techniques for the recovery of architectural components in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance a</context>
<context position="42405" citStr="[61, 21, 11]" startWordPosition="6351" endWordPosition="6353"> 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusi</context>
</contexts>
<marker>[11]</marker>
<rawString>Christl, Koschke, and Storey. Equipping the reflexion method with automated clustering. In WCRE, pp. 89–98.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Coelho</author>
<author>Murphy</author>
</authors>
<title>Presenting crosscutting structure with active models.</title>
<date>2006</date>
<booktitle>In AOSD,</booktitle>
<pages>158--168</pages>
<contexts>
<context position="15382" citStr="[98, 12]" startWordPosition="2310" endWordPosition="2311">s necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start </context>
</contexts>
<marker>[12]</marker>
<rawString>Coelho and Murphy. Presenting crosscutting structure with active models. In AOSD, pp. 158–168, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Conway</author>
</authors>
<title>How do committees invent?</title>
<date>1968</date>
<journal>Datamation,</journal>
<volume>14</volume>
<issue>4</issue>
<contexts>
<context position="24769" citStr="[13]" startWordPosition="3740" endWordPosition="3740">nformation visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software architecture [6]. Historical Information. Historical information is rarely used in SAR. Still ArchView is a recent approach that exploits source control system data and bug reports to analyze the evolution of recovered architectural views [89, 92]. To assist a reverse engineer to understand underlined depend</context>
</contexts>
<marker>[13]</marker>
<rawString>Conway. How do committees invent? Datamation, 14(4):28–31, 1968.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ducasse Demeyer</author>
<author>Lanza</author>
</authors>
<title>A hybrid reverse engineering platform combining metrics and program visualization.</title>
<date>1999</date>
<booktitle>In WCRE,</booktitle>
<contexts>
<context position="7675" citStr="[130, 14]" startWordPosition="1182" endWordPosition="1183">h contains its actual architecture. However, reconstructing the architecture from the source code raises several problems: • The large amount of data held by the source code raises scalability issues. • Since the considered systems are typically large, complex and long-living, SAR should handle development methods, languages and technologies that are often heterogeneous and sometimes interleaved. • Architecture is not explicitly represented at the source code level. In addition, language concepts such as polymorphism, late-binding, delegation, or inheritance make it harder to analyze the code [130, 14]. How to identify the relevant information to reach an architectural level? • The nature of software raises the questions of whether dynamic information should be extracted as the system is running, and then how do the behavioral aspects appear in the architecture. To summarize this section, the major challenge of SAR is in abstracting, identifying and displaying higher-level views from lower-level and often heterogeneous information. 3. SAR Taxonomy Axes Mendonca et al. [78] classified SAR environments and distinguished five families: filtering and clustering, compliance checking, analysers </context>
</contexts>
<marker>[14]</marker>
<rawString>Demeyer, Ducasse, and Lanza. A hybrid reverse engineering platform combining metrics and program visualization. In WCRE, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tichelaar Demeyer</author>
<author>Ducasse</author>
</authors>
<date>2001</date>
<journal>FAMIX 2.1 — The FAMOOS Information Exchange Model.</journal>
<tech>Tech. report,</tech>
<institution>Univ. of Bern,</institution>
<contexts>
<context position="23101" citStr="[15]" startWordPosition="3483" endWordPosition="3483">R with heterogeneous information of diverse abstraction levels. 6.1. Non-Architectural Inputs Source Code Constructs. The source code is an omnipresent trustworthy source of information that most approaches consider. Some of them query directly the source code text like in RMTool [82]. However, most of them are not directly based on the source code but represent source code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral sy</context>
</contexts>
<marker>[15]</marker>
<rawString>Demeyer, Tichelaar, and Ducasse. FAMIX 2.1 — The FAMOOS Information Exchange Model. Tech. report, Univ. of Bern, 2001.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Ding</author>
<author>Medvidovic</author>
</authors>
<title>Focus: A</title>
<note>light-weight, incremental</note>
<contexts>
<context position="12676" citStr="[16, 76]" startWordPosition="1902" endWordPosition="1903">18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promot</context>
<context position="13995" citStr="[16, 76]" startWordPosition="2095" endWordPosition="2096"> evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should evolve. Krikhaar et al. also introduced a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some approaches do not extract the architecture in itself but architectural correlated or side-effect artifacts that crosscut or complement the architecture such as design patterns, concerns, features, aspects, or roles and collaborations. While such informatio</context>
<context position="22070" citStr="[16, 76]" startWordPosition="3323" endWordPosition="3324">apped to hypothesized entities. To assess the creation of product lines, Stoermer et al. introduce the MAP method [109]. MAP combines (1) a bottom-up process, to recover the concrete architectures of existing products; (2) a top-down process, to map architectural styles onto recovered architectural views; (3) an approach to analyze commonalities and variabilities among recovered architectures. They stress the ability of architectural styles to act as the structural glue of the components, and to highlight architecture strengths and weaknesses. Other hybrid processes for instance include Focus [16, 76] and Nimeta [96]. 6. SAR Inputs SAR essentially works on source code representations. However, other kinds of information are sometimes considered such as dynamic information extracted from a system as it is running or historical data held by version control system repositories. In addition a few approaches take into account architectural elements such as styles or viewpoints as input to SAR. The current trend is to feed SAR with heterogeneous information of diverse abstraction levels. 6.1. Non-Architectural Inputs Source Code Constructs. The source code is an omnipresent trustworthy source of</context>
<context position="27376" citStr="[16, 76]" startWordPosition="4121" endWordPosition="4122">hey represent recurrent architectural situations [60]. They are valuable, expressive, and accepted abstractions for SAR and more generally for software understanding. Recognizing them is however a challenge because they basically span several architectural elements and can be implemented in various ways [91]. The question that turns up is whether SAR helps reverse engineers specify and extract architectural styles. Examples. Ding et al. proposed to use architectural styles in Focus to infer a conceptual architecture that will be mapped to a concrete architecture extracted from the source code [16, 76]. Closely related to this work, Medvidovic et al. introduced an approach to stop architectural erosion. In a topdown process, requirements serve as high-level knowledge to discover the conceptual architecture [75]. In a bottom-up process, system implementation serves as low level knowledge to recover the concrete architecture. Both the conceptual and the concrete architectures are incrementally built. The reverse engineer reconciles the two architectures, based on architectural styles. To select the most appropriate one, they characterize each architectural style according to several criteria.</context>
<context position="38966" citStr="[16, 76]" startWordPosition="5839" endWordPosition="5840">resentations of software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of </context>
<context position="41942" citStr="[16, 76]" startWordPosition="6288" endWordPosition="6289">formance is checked between two reconstructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and ev</context>
</contexts>
<marker>[16]</marker>
<rawString>Ding and Medvidovic. Focus: A light-weight, incremental</rawString>
</citation>
<citation valid="true">
<authors>
<author>Moose</author>
</authors>
<title>a collaborative and extensible reengineering Environment.</title>
<date>2005</date>
<booktitle>In Tools for Sw. Maint. and Reeng., RCOST / Software Technology Series,</booktitle>
<pages>55--71</pages>
<contexts>
<context position="34785" citStr="[17]" startWordPosition="5213" endWordPosition="5213">lator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code views and relations in Intensive [134, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts [94]. Programs: Some approaches build analyses as programs. For example, the analyses made in the Moose environment are performed as object-oriented programs that manipulate models representing the various inputs [17]. Lexical and structural queries: Some approaches are directly based on the lexical and structural information in the source code. Pinzger et al. state that some hotspots clearly localize patterns in the source code and consider them as the starting point of SAR [90, 91]. To drive a pattern-supported architecture recovery, they introduce a pattern specification language and the Revealer tool. Investigation-based Techniques. These techniques map high-level concepts with low-level concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns</context>
</contexts>
<marker>[17]</marker>
<rawString>Ducasse, Gı̂rba, Lanza, and Demeyer. Moose: a collaborative and extensible reengineering Environment. In Tools for Sw. Maint. and Reeng., RCOST / Software Technology Series, pp. 55–71. 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>de Oliveira Duenas</author>
<author>de la Puente</author>
</authors>
<title>Architecture recovery for software evolution.</title>
<date>1998</date>
<booktitle>In CSMR,</booktitle>
<pages>113--120</pages>
<contexts>
<context position="12075" citStr="[109, 93, 18, 23]" startWordPosition="1805" endWordPosition="1808"> al. illustrates this goal [28]. Svetinovic et al. state that not only the recovered architecture is important, but also its rationale, i.e. why it is as it is [114]. They focus on the architecture rationale forces to recover the decisions made, their alternatives, and why each one was or was not chosen. Reuse investigation and product line migration: Systematic reuse has not yet been achieved. Software product lines allow one to share commonalities among products while getting custom products. Architectural views are useful to identify commonalities and variabilities among products in a line [109, 93, 18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76</context>
<context position="39137" citStr="[28, 57, 18, 61, 91, 100, 96]" startWordPosition="5863" endWordPosition="5869">e clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose </context>
</contexts>
<marker>[18]</marker>
<rawString>Dueñas, de Oliveira, and de la Puente. Architecture recovery for software evolution. In CSMR, pp. 113–120, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>GUPRO</author>
</authors>
<title>generic understanding of programs, an overview.</title>
<date>2002</date>
<tech>Tech. Report 7– 2002, Univ. Koblenz-Landau,</tech>
<contexts>
<context position="13756" citStr="[19]" startWordPosition="2059" endWordPosition="2059">ramming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should evolve. Krikhaar et al. also introduced a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some approaches do not</context>
<context position="16671" citStr="[19]" startWordPosition="2500" endWordPosition="2500">gressively raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system representations, which are then presented in a suitable interactive form to reverse engineers. Examples. Several tools support a bottom-up process characterized by the extract-abstract-present metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engineer can specify patterns using SQL queries and Perl expressions. The former selects a set of source model entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intens</context>
<context position="31435" citStr="[19]" startWordPosition="4732" endWordPosition="4732">representing viewpoints. The QADSAR approach both reconstructs the architecture of a system and drives quality attribute analyses on it [110, 111]. To do this, QADSAR allows reverse engineers to formulate their interests in reconstructing the architecture by means of concrete quality attribute scenarios. This results in the definition of relevant architectural viewpoints. ARES [23, 22] and SAR [62] also take viewpoints into account. 7. SAR Techniques Techniques and the data they operate on are often correlated. For example, input information is represented respectively as facts [80] or graphs [19] to use logic or graph queries. 7 SAR approaches use different techniques that we classified according to their automation level: quasi-manual, the reverse engineer manually identifies architectural elements using a tool to assist him to understand his findings; semiautomatic, the reverse engineer manually instructs the tool how to automatically discover refinements or recover abstractions. quasi-automatic, the tool has the control and the reverse engineer steers the iterative recovery process. Of course, the boundaries between the classifications are not clear-cut. 7.1. Quasi-Manual Technique</context>
<context position="33747" citStr="[19]" startWordPosition="5056" endWordPosition="5056">e the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs using a specialized declarative expression language called GReQL [19]. Rigi is based on graph transformations written in Tcl [81, 113]. Relational queries: Often, relational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as</context>
<context position="39781" citStr="[19]" startWordPosition="5966" endWordPosition="5966">on manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define arc</context>
</contexts>
<marker>[19]</marker>
<rawString>Ebert, Kullbach, Riediger, and Winter. GUPRO – generic understanding of programs, an overview. Tech. Report 7– 2002, Univ. Koblenz-Landau, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eden</author>
</authors>
<title>Visualization of object oriented architectures.</title>
<date>2001</date>
<booktitle>In ICSE,</booktitle>
<contexts>
<context position="33090" citStr="[20]" startWordPosition="4966" endWordPosition="4966">Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs using a spec</context>
</contexts>
<marker>[20]</marker>
<rawString>Eden. Visualization of object oriented architectures. In ICSE, May 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Koschke Eisenbarth</author>
<author>Simon</author>
</authors>
<title>Locating Features in Source Code.</title>
<date>2003</date>
<journal>IEEE Computer,</journal>
<volume>29</volume>
<issue>3</issue>
<contexts>
<context position="15495" citStr="[131, 21, 87, 96, 36, 106]" startWordPosition="2325" endWordPosition="2330">ssiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstrac</context>
<context position="24372" citStr="[21, 99, 36]" startWordPosition="3682" endWordPosition="3684">n only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the devel</context>
<context position="37369" citStr="[61, 21, 11]" startWordPosition="5599" endWordPosition="5601">clustering algorithms to automatically partition software products into cohesive clusters that are loosely interconnected [129]. Clustering algorithms, based on hill climbing and genetic algorithms, are applied on module dependency graphs extracted from source code. The Bunch tool was extended to take into account human knowledge [74]. According to Xiao et al. [135], clustering techniques applied to dynamic analysis are as efficient as those applied to static analysis, and this research area is promising and unexplored. The Bauhaus environment implements a wide number of clustering techniques [61, 21, 11]. Koschke emphasizes the need to refine existing clustering techniques, first by combining them, and second by integrating the reverse engineer as a conformance supervisor of the reconstruction process. Adhering to Koschke’s thesis, Trifu unifies cluster and dominance analysis techniques for the recovery of architectural components in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance a</context>
<context position="42405" citStr="[61, 21, 11]" startWordPosition="6351" endWordPosition="6353"> 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusi</context>
</contexts>
<marker>[21]</marker>
<rawString>Eisenbarth, Koschke, and Simon. Locating Features in Source Code. IEEE Computer, 29(3):210–224, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eixelsberger</author>
<author>Gall</author>
</authors>
<title>Describing software architectures by system structure and properties.</title>
<date>1998</date>
<booktitle>In COMPSAC,</booktitle>
<pages>106--111</pages>
<contexts>
<context position="17696" citStr="[23, 22]" startWordPosition="2661" endWordPosition="2662">et to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group related source-code entities structurally in a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies consistencies and inconsistencies. Li</context>
<context position="31219" citStr="[23, 22]" startWordPosition="4695" endWordPosition="4696">[26]. Like Symphony, CacOphoNy recognizes the need to identify which viewpoints are relevant for stakeholder concerns and have to be considered in SAR. Contrary to Symphony, CacOphoNy states that metamodels are keys for representing viewpoints. The QADSAR approach both reconstructs the architecture of a system and drives quality attribute analyses on it [110, 111]. To do this, QADSAR allows reverse engineers to formulate their interests in reconstructing the architecture by means of concrete quality attribute scenarios. This results in the definition of relevant architectural viewpoints. ARES [23, 22] and SAR [62] also take viewpoints into account. 7. SAR Techniques Techniques and the data they operate on are often correlated. For example, input information is represented respectively as facts [80] or graphs [19] to use logic or graph queries. 7 SAR approaches use different techniques that we classified according to their automation level: quasi-manual, the reverse engineer manually identifies architectural elements using a tool to assist him to understand his findings; semiautomatic, the reverse engineer manually instructs the tool how to automatically discover refinements or recover abst</context>
<context position="40638" citStr="[23, 22]" startWordPosition="6096" endWordPosition="6097">nessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in DiscoTect [136]. Huang et al. specify architectures with the ABC ADL [51]. As said in Section 6.2, the notion of software architecture heavily depends on the stakeholders’ interests. Since ADLs have difficulty in taking different viewpoints into account and focus on the module viewpoint, they are rarely used to express reconstructed architectural views. To drive SAR in CacOphoNy, Favre proposed to precisely define viewpoints using metamodels [26]. 9 8.2. Conformance We consider architecture conformance between similar abstraction levels (horizon</context>
<context position="42627" citStr="[23, 22]" startWordPosition="6385" endWordPosition="6386">he recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we surveyed research works in the field of software architecture reconstruction (SAR). To structure the paper, we followed the general process of SAR: what are the stakeholders’ goals; how does the genera</context>
</contexts>
<marker>[22]</marker>
<rawString>Eixelsberger and Gall. Describing software architectures by system structure and properties. In COMPSAC, pp. 106– 111, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ogris Eixelsberger</author>
<author>Gall</author>
<author>Bellay</author>
</authors>
<title>Software architecture recovery of a program family.</title>
<date>1998</date>
<booktitle>In ICSE,</booktitle>
<pages>508--511</pages>
<contexts>
<context position="12075" citStr="[109, 93, 18, 23]" startWordPosition="1805" endWordPosition="1808"> al. illustrates this goal [28]. Svetinovic et al. state that not only the recovered architecture is important, but also its rationale, i.e. why it is as it is [114]. They focus on the architecture rationale forces to recover the decisions made, their alternatives, and why each one was or was not chosen. Reuse investigation and product line migration: Systematic reuse has not yet been achieved. Software product lines allow one to share commonalities among products while getting custom products. Architectural views are useful to identify commonalities and variabilities among products in a line [109, 93, 18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76</context>
<context position="17696" citStr="[23, 22]" startWordPosition="2661" endWordPosition="2662">et to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group related source-code entities structurally in a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies consistencies and inconsistencies. Li</context>
<context position="31219" citStr="[23, 22]" startWordPosition="4695" endWordPosition="4696">[26]. Like Symphony, CacOphoNy recognizes the need to identify which viewpoints are relevant for stakeholder concerns and have to be considered in SAR. Contrary to Symphony, CacOphoNy states that metamodels are keys for representing viewpoints. The QADSAR approach both reconstructs the architecture of a system and drives quality attribute analyses on it [110, 111]. To do this, QADSAR allows reverse engineers to formulate their interests in reconstructing the architecture by means of concrete quality attribute scenarios. This results in the definition of relevant architectural viewpoints. ARES [23, 22] and SAR [62] also take viewpoints into account. 7. SAR Techniques Techniques and the data they operate on are often correlated. For example, input information is represented respectively as facts [80] or graphs [19] to use logic or graph queries. 7 SAR approaches use different techniques that we classified according to their automation level: quasi-manual, the reverse engineer manually identifies architectural elements using a tool to assist him to understand his findings; semiautomatic, the reverse engineer manually instructs the tool how to automatically discover refinements or recover abst</context>
<context position="40638" citStr="[23, 22]" startWordPosition="6096" endWordPosition="6097">nessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in DiscoTect [136]. Huang et al. specify architectures with the ABC ADL [51]. As said in Section 6.2, the notion of software architecture heavily depends on the stakeholders’ interests. Since ADLs have difficulty in taking different viewpoints into account and focus on the module viewpoint, they are rarely used to express reconstructed architectural views. To drive SAR in CacOphoNy, Favre proposed to precisely define viewpoints using metamodels [26]. 9 8.2. Conformance We consider architecture conformance between similar abstraction levels (horizon</context>
<context position="42627" citStr="[23, 22]" startWordPosition="6385" endWordPosition="6386">he recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we surveyed research works in the field of software architecture reconstruction (SAR). To structure the paper, we followed the general process of SAR: what are the stakeholders’ goals; how does the genera</context>
</contexts>
<marker>[23]</marker>
<rawString>Eixelsberger, Ogris, Gall, and Bellay. Software architecture recovery of a program family. In ICSE, pp. 508–511, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Erben</author>
<author>Lohr</author>
</authors>
<title>Sab - the software architecture browser.</title>
<date>2005</date>
<booktitle>In VISSOFT. IEEE CS,</booktitle>
<contexts>
<context position="32817" citStr="[24]" startWordPosition="4926" endWordPosition="4926">roaches; we considered two categories. Construction-based Techniques. These techniques reconstruct the software architecture by manually abstracting low-level knowledge, thanks to interactive and expressive visualization tools — Rigi [81, 113], PBS [28], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engine</context>
<context position="39965" citStr="[24]" startWordPosition="5996" endWordPosition="5996">technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It</context>
</contexts>
<marker>[24]</marker>
<rawString>Erben and Löhr. Sab - the software architecture browser. In VISSOFT. IEEE CS, Sept. 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Favre</author>
</authors>
<title>Meta-model and model co-evolution within the 3d software space.</title>
<date>2003</date>
<booktitle>In ELISA,</booktitle>
<contexts>
<context position="13292" citStr="[25]" startWordPosition="1987" endWordPosition="1987">[75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is </context>
</contexts>
<marker>[25]</marker>
<rawString>Favre. Meta-model and model co-evolution within the 3d software space. In ELISA, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Favre</author>
</authors>
<title>CacOphoNy: Metamodel-driven software architecture reconstruction.</title>
<date>2004</date>
<booktitle>In WCRE,</booktitle>
<pages>204--213</pages>
<contexts>
<context position="30615" citStr="[26]" startWordPosition="4603" endWordPosition="4603">n SAR to provide architectural views compliant to stakeholders’ expectations, ideally allowing an immediate use of these views. For example, Symphony authors highlight through four case studies some SAR motivations such as checking the conformance of family products to architectural rules. To do this they need to provide to reverse engineers architectural views according the viewpoints these reverse engineers typically use during design. Riva proposed a view-based SAR approach called Nimeta based on the Symphony one [96]. Favre outlines a generic SAR metamodel-driven approach called CacOphoNy [26]. Like Symphony, CacOphoNy recognizes the need to identify which viewpoints are relevant for stakeholder concerns and have to be considered in SAR. Contrary to Symphony, CacOphoNy states that metamodels are keys for representing viewpoints. The QADSAR approach both reconstructs the architecture of a system and drives quality attribute analyses on it [110, 111]. To do this, QADSAR allows reverse engineers to formulate their interests in reconstructing the architecture by means of concrete quality attribute scenarios. This results in the definition of relevant architectural viewpoints. ARES [23,</context>
<context position="41137" citStr="[26]" startWordPosition="6173" endWordPosition="6173">structed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in DiscoTect [136]. Huang et al. specify architectures with the ABC ADL [51]. As said in Section 6.2, the notion of software architecture heavily depends on the stakeholders’ interests. Since ADLs have difficulty in taking different viewpoints into account and focus on the module viewpoint, they are rarely used to express reconstructed architectural views. To drive SAR in CacOphoNy, Favre proposed to precisely define viewpoints using metamodels [26]. 9 8.2. Conformance We consider architecture conformance between similar abstraction levels (horizontal conformance) and between different abstraction levels (vertical conformance). Horizontal Conformance is checked between two reconstructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture an</context>
</contexts>
<marker>[26]</marker>
<rawString>Favre. CacOphoNy: Metamodel-driven software architecture reconstruction. In WCRE, pp. 204–213, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Feijs</author>
<author>de Jong</author>
</authors>
<title>3d visualization of software architectures.</title>
<date>1998</date>
<volume>41</volume>
<pages>72--78</pages>
<contexts>
<context position="33021" citStr="[27]" startWordPosition="4955" endWordPosition="4955">ve visualization tools — Rigi [81, 113], PBS [28], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92]</context>
</contexts>
<marker>[27]</marker>
<rawString>Feijs and de Jong. 3d visualization of software architectures. vol. 41, pp. 72–78, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Holt Finnigan</author>
<author>Kerr Kalas</author>
<author>Mueller Kontogiannis</author>
<author>Perelgut Mylopoulos</author>
<author>Stanley</author>
<author>Wong</author>
</authors>
<title>The software bookshelf.</title>
<date>1997</date>
<journal>IBM Systems Journal,</journal>
<volume>36</volume>
<issue>4</issue>
<contexts>
<context position="11489" citStr="[28]" startWordPosition="1715" endWordPosition="1715">n et al. have a pragmatic categorization of business goals [55]. In the context 3 of maintenance, a SAR process answers stakeholder business objectives. It must be considered as a proactive process realized for future forward engineering tasks. SAR approaches match various often interleaved intentions: Redocumentation and understanding: The primary goal of SAR is to re-establish software abstractions. Recovered architectural views document software applications and help reverse engineers understand them. For instance, the software bookshelf introduced by Finningan et al. illustrates this goal [28]. Svetinovic et al. state that not only the recovered architecture is important, but also its rationale, i.e. why it is as it is [114]. They focus on the architecture rationale forces to recover the decisions made, their alternatives, and why each one was or was not chosen. Reuse investigation and product line migration: Systematic reuse has not yet been achieved. Software product lines allow one to share commonalities among products while getting custom products. Architectural views are useful to identify commonalities and variabilities among products in a line [109, 93, 18, 23]. Conformance:</context>
<context position="16643" citStr="[28]" startWordPosition="2495" endWordPosition="2495">urce code models, they pro4 gressively raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system representations, which are then presented in a suitable interactive form to reverse engineers. Examples. Several tools support a bottom-up process characterized by the extract-abstract-present metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engineer can specify patterns using SQL queries and Perl expressions. The former selects a set of source model entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Me</context>
<context position="32466" citStr="[28]" startWordPosition="4876" endWordPosition="4876"> control and the reverse engineer steers the iterative recovery process. Of course, the boundaries between the classifications are not clear-cut. 7.1. Quasi-Manual Techniques SAR is a reverse engineering activity which faces scalability issues in manipulating knowledge. In response to this problem, researchers have proposed slightly assisted SAR approaches; we considered two categories. Construction-based Techniques. These techniques reconstruct the software architecture by manually abstracting low-level knowledge, thanks to interactive and expressive visualization tools — Rigi [81, 113], PBS [28], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [3</context>
<context position="39137" citStr="[28, 57, 18, 61, 91, 100, 96]" startWordPosition="5863" endWordPosition="5869">e clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose </context>
</contexts>
<marker>[28]</marker>
<rawString>Finnigan, Holt, Kalas, Kerr, Kontogiannis, Mueller, Mylopoulos, Perelgut, Stanley, and Wong. The software bookshelf. IBM Systems Journal, 36(4):564–593, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tonella Fiutem</author>
<author>Antoniol</author>
<author>Merlo</author>
</authors>
<title>A cliche-based environment to support architectural reverse engineering.</title>
<date>1996</date>
<booktitle>In ICSM. IEEE,</booktitle>
<contexts>
<context position="19917" citStr="[29]" startWordPosition="2997" endWordPosition="2997">ch a relevant box and arrow view of the software application. 5.3. Hybrid Processes Hybrid processes combine the previous two [112]. On the one hand, low-level knowledge is abstracted up using various techniques. On the other hand, high-level knowledge is refined. This kind of process is frequently used to stop architectural erosion by reconciling the conceptual and concrete architectures. Hybrid approaches often use hypothesis recognizers. Recognizerbased tools provide bottom-up reverse engineering strategies to support top-down exploration of architectural hypothesis. ManSART [43, 137], ART [29], X-ray [79], ARM [40] and DiscoTect [136] are examples of this approach. In ManSART, a top-down recognition engine maps a style-compliant conceptual view with a system overview which was defined using a visualization tool in a bottom-up fashion. Examples. Sartipi implemented a pattern-based SAR approach in Alborz [100, 101]. The architecture reconstruction consists of two phases. During the first bottom-up phase, the source code is parsed, presented as a graph, then divided in cohesive graph regions using data mining techniques. This model is at a higher abstraction level than the code. Durin</context>
<context position="35621" citStr="[29]" startWordPosition="5337" endWordPosition="5337">m as the starting point of SAR [90, 91]. To drive a pattern-supported architecture recovery, they introduce a pattern specification language and the Revealer tool. Investigation-based Techniques. These techniques map high-level concepts with low-level concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns to design patterns, concerns, aspects, and features, that are orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execution and ou</context>
</contexts>
<marker>[29]</marker>
<rawString>Fiutem, Tonella, Antoniol, and Merlo. A cliché-based environment to support architectural reverse engineering. In ICSM. IEEE, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hatch Gallagher</author>
<author>Munro</author>
</authors>
<title>A framework for software architecture visualisation assessment.</title>
<date>2005</date>
<booktitle>In VISSOFT. IEEE CS,</booktitle>
<contexts>
<context position="8424" citStr="[30]" startWordPosition="1294" endWordPosition="1294">rmation should be extracted as the system is running, and then how do the behavioral aspects appear in the architecture. To summarize this section, the major challenge of SAR is in abstracting, identifying and displaying higher-level views from lower-level and often heterogeneous information. 3. SAR Taxonomy Axes Mendonca et al. [78] classified SAR environments and distinguished five families: filtering and clustering, compliance checking, analysers generators, program understanding and architecture recognition. O’Brien et al. surveyed SAR practice needs and approaches [85]. Gallagher et al. [30] proposed a framework to assess architectural visualization tools. Gueheneuc et al. [38] proposed a comparative framework for design recovery tools. We propose a more elaborated classification based on the life-time of SAR presented in Figures 1 and 2): intended goals, followed processes, required inputs, used techniques and expected outputs. 2 Goals Processes Techniques Outputs InputsSAR Hybrid Bottom-Up Top-Down Semi-Automatic Quasi-Manual Quasi-Automatic Abstraction Investigation Construction Exploration Architecture Conformance Analysis Redocumentation Reuse Conformance Analysis Co-Evolu</context>
<context position="32957" citStr="[30]" startWordPosition="4947" endWordPosition="4947">tracting low-level knowledge, thanks to interactive and expressive visualization tools — Rigi [81, 113], PBS [28], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Ex</context>
</contexts>
<marker>[30]</marker>
<rawString>Gallagher, Hatch, and Munro. A framework for software architecture visualisation assessment. In VISSOFT. IEEE CS, Sept. 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gansner</author>
<author>North</author>
</authors>
<title>An open graph visualization system and its applications to software engineering.</title>
<date>2000</date>
<journal>Softw. Pract. Exper.,</journal>
<volume>30</volume>
<issue>11</issue>
<contexts>
<context position="39635" citStr="[31]" startWordPosition="5942" endWordPosition="5942">] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with vis</context>
</contexts>
<marker>[31]</marker>
<rawString>Gansner and North. An open graph visualization system and its applications to software engineering. Softw. Pract. Exper., 30(11):1203–1233, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Garlan</author>
</authors>
<title>Software architecture: a roadmap. In ICSE -</title>
<date>2000</date>
<journal>Future of SE Track,</journal>
<pages>91--101</pages>
<contexts>
<context position="1196" citStr="[32]" startWordPosition="182" endWordPosition="182">id is thus an important aid. While there is a plethora of approaches and techniques supporting architecture reconstruction, there is no comprehensive state of the art and it is often difficult to compare the approaches. This article presents a first state of the art in software architecture reconstruction, with the desire to support the understanding of the field. 1. Introduction Software architecture acts as a shared mental model of a system expressed at a high-level of abstraction [49]. By leaving details aside, this model plays a key role as a bridge between requirements and implementation [32]. It allows one to reason architecturally about a software application during the various steps of the software life cycle. According to Garlan [32], software architecture plays an important role in at least six aspects of software development: understanding, reuse, construction, evolution, analysis and management. Software architecture is thus crucial for software development. The first problem is that architectures are not explicitly represented in the code as classes and packages are. The second problem is that successful software applications are doomed to continually evolve and grow [67];</context>
<context position="10863" citStr="[32]" startWordPosition="1623" endWordPosition="1623">ot all approaches support the specification and use of architectural styles and viewpoints which are the paramount of architecture. Techniques. The research community has explored various techniques to reconstruct architecture that can be roughly classified according to their automation level. Outputs. While all SAR approaches intend to provide architectural views, some of them however produce other valuable outputs like conformance data. 4. SAR Goals We discuss now the goals of SAR as well as related artifacts. 4.1. Goals Several authors categorized architecture roles in software development [32]; in particular, Kazman et al. have a pragmatic categorization of business goals [55]. In the context 3 of maintenance, a SAR process answers stakeholder business objectives. It must be considered as a proactive process realized for future forward engineering tasks. SAR approaches match various often interleaved intentions: Redocumentation and understanding: The primary goal of SAR is to re-establish software abstractions. Recovered architectural views document software applications and help reverse engineers understand them. For instance, the software bookshelf introduced by Finningan et al. </context>
</contexts>
<marker>[32]</marker>
<rawString>Garlan. Software architecture: a roadmap. In ICSE - Future of SE Track, pp. 91–101, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Allen Garlan</author>
<author>Ockerbloom</author>
</authors>
<title>Architectural mismatch: Why reuse is so hard.</title>
<date>1995</date>
<journal>IEEE Software,</journal>
<volume>12</volume>
<issue>6</issue>
<contexts>
<context position="2041" citStr="[33]" startWordPosition="310" endWordPosition="310">nt: understanding, reuse, construction, evolution, analysis and management. Software architecture is thus crucial for software development. The first problem is that architectures are not explicitly represented in the code as classes and packages are. The second problem is that successful software applications are doomed to continually evolve and grow [67]; and as a software application evolves and grows, so does its architecture. The conceptual architecture often becomes inaccurate with respect to the concrete architecture; this results in architectural erosion [75, 88], drift [88], mismatch [33], or chasm [96]. Software architecture reconstruction (SAR) is the reverse engineering process that aims at reconstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in the literature to support S</context>
</contexts>
<marker>[33]</marker>
<rawString>Garlan, Allen, and Ockerbloom. Architectural mismatch: Why reuse is so hard. IEEE Software, 12(6):17–26, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Monroe Garlan</author>
<author>Wile</author>
</authors>
<title>Acme: An architecture description interchange language. In</title>
<date>1997</date>
<booktitle>CASCON,</booktitle>
<pages>169--183</pages>
<contexts>
<context position="40649" citStr="[34]" startWordPosition="6099" endWordPosition="6099">xonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in DiscoTect [136]. Huang et al. specify architectures with the ABC ADL [51]. As said in Section 6.2, the notion of software architecture heavily depends on the stakeholders’ interests. Since ADLs have difficulty in taking different viewpoints into account and focus on the module viewpoint, they are rarely used to express reconstructed architectural views. To drive SAR in CacOphoNy, Favre proposed to precisely define viewpoints using metamodels [26]. 9 8.2. Conformance We consider architecture conformance between similar abstraction levels (horizontal conform</context>
</contexts>
<marker>[34]</marker>
<rawString>Garlan, Monroe, and Wile. Acme: An architecture description interchange language. In CASCON, pp. 169–183, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Garlan</author>
<author>Perry</author>
</authors>
<title>Introduction to the special issue on software architecture.</title>
<date>1995</date>
<journal>IEEE TSE,</journal>
<volume>21</volume>
<issue>4</issue>
<contexts>
<context position="4084" citStr="[102, 35]" startWordPosition="641" endWordPosition="642"> in the field. Section 3 describes the criteria that we adopted in our taxonomy; sections 4 to 8 then cover each of these criteria, and we conclude. 2. SAR Challenges Before going in more depth into the challenges of SAR, we feel the need to clarify the vocabulary. 2.1. Vocabulary Software architecture. IEEE defines software architecture as “the fundamental organization of a system embodied in its components, their relationships to each other, and to the environment, and the principles guiding its design and 1 evolution”[52]; this is closely related to the definition of Shaw, Perry and Garlan [102, 35]. Architectural style. A software architecture often conforms to an architectural style that is a class of architectures, or a pattern of structural organization: “a vocabulary of components and connector types, and a set of constraints on how they can be combined” [102]. Architectural views and viewpoints. We can view a software architecture from several viewpoints since the different system stakeholders have different expectations or concerns about the system [64, 52]: View: “a representation of a whole system from the perspective of a related set of concerns.” Viewpoint: “a specification of</context>
</contexts>
<marker>[35]</marker>
<rawString>Garlan and Perry. Introduction to the special issue on software architecture. IEEE TSE, 21(4), 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Greevy</author>
<author>Ducasse</author>
</authors>
<title>Correlating features and code using a compact two-sided trace analysis approach.</title>
<date>2005</date>
<booktitle>In CSMR,</booktitle>
<pages>314--323</pages>
<contexts>
<context position="15495" citStr="[131, 21, 87, 96, 36, 106]" startWordPosition="2325" endWordPosition="2330">ssiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstrac</context>
<context position="24372" citStr="[21, 99, 36]" startWordPosition="3682" endWordPosition="3684">n only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the devel</context>
</contexts>
<marker>[36]</marker>
<rawString>Greevy and Ducasse. Correlating features and code using a compact two-sided trace analysis approach. In CSMR, pp. 314–323, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Grundy</author>
<author>Hosking</author>
</authors>
<title>High-level static and dynamic visualization of software architectures.</title>
<date>2000</date>
<booktitle>IEEE CS,</booktitle>
<volume>00</volume>
<pages>5</pages>
<contexts>
<context position="33068" citStr="[37]" startWordPosition="4962" endWordPosition="4962">8], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queri</context>
</contexts>
<marker>[37]</marker>
<rawString>Grundy and Hosking. High-level static and dynamic visualization of software architectures. vol. 00, p. 5. IEEE CS, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mens Gueheneuc</author>
<author>Wuyts</author>
</authors>
<title>A comparative framework for design recovery tools.</title>
<date>2006</date>
<booktitle>In CSMR. IEEE CS,</booktitle>
<contexts>
<context position="8514" citStr="[38]" startWordPosition="1307" endWordPosition="1307">ts appear in the architecture. To summarize this section, the major challenge of SAR is in abstracting, identifying and displaying higher-level views from lower-level and often heterogeneous information. 3. SAR Taxonomy Axes Mendonca et al. [78] classified SAR environments and distinguished five families: filtering and clustering, compliance checking, analysers generators, program understanding and architecture recognition. O’Brien et al. surveyed SAR practice needs and approaches [85]. Gallagher et al. [30] proposed a framework to assess architectural visualization tools. Gueheneuc et al. [38] proposed a comparative framework for design recovery tools. We propose a more elaborated classification based on the life-time of SAR presented in Figures 1 and 2): intended goals, followed processes, required inputs, used techniques and expected outputs. 2 Goals Processes Techniques Outputs InputsSAR Hybrid Bottom-Up Top-Down Semi-Automatic Quasi-Manual Quasi-Automatic Abstraction Investigation Construction Exploration Architecture Conformance Analysis Redocumentation Reuse Conformance Analysis Co-Evolution Evolution Related Artifacts Non-Architectural Architectural Styles Viewpoints Graph P</context>
</contexts>
<marker>[38]</marker>
<rawString>Guéhéneuc, Mens, and Wuyts. A comparative framework for design recovery tools. In CSMR. IEEE CS, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sahraoui Gueheneuc</author>
<author>Zaidi</author>
</authors>
<title>Fingerprinting design patterns.</title>
<date>2004</date>
<booktitle>In WCRE,</booktitle>
<pages>172--181</pages>
<contexts>
<context position="15250" citStr="[1, 3, 46, 128, 5, 39]" startWordPosition="2287" endWordPosition="2292">architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processe</context>
</contexts>
<marker>[39]</marker>
<rawString>Guéhéneuc, Sahraoui, and Zaidi. Fingerprinting design patterns. In WCRE, pp. 172–181, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Y Guo</author>
<author>Atlee</author>
<author>Kazman</author>
</authors>
<title>A software architecture reconstruction method.</title>
<date>1999</date>
<booktitle>In WICSA,</booktitle>
<pages>15--34</pages>
<contexts>
<context position="17225" citStr="[40]" startWordPosition="2591" endWordPosition="2591">ent metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engineer can specify patterns using SQL queries and Perl expressions. The former selects a set of source model entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group related source-code entities structurally in a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim</context>
<context position="19939" citStr="[40]" startWordPosition="3001" endWordPosition="3001">arrow view of the software application. 5.3. Hybrid Processes Hybrid processes combine the previous two [112]. On the one hand, low-level knowledge is abstracted up using various techniques. On the other hand, high-level knowledge is refined. This kind of process is frequently used to stop architectural erosion by reconciling the conceptual and concrete architectures. Hybrid approaches often use hypothesis recognizers. Recognizerbased tools provide bottom-up reverse engineering strategies to support top-down exploration of architectural hypothesis. ManSART [43, 137], ART [29], X-ray [79], ARM [40] and DiscoTect [136] are examples of this approach. In ManSART, a top-down recognition engine maps a style-compliant conceptual view with a system overview which was defined using a visualization tool in a bottom-up fashion. Examples. Sartipi implemented a pattern-based SAR approach in Alborz [100, 101]. The architecture reconstruction consists of two phases. During the first bottom-up phase, the source code is parsed, presented as a graph, then divided in cohesive graph regions using data mining techniques. This model is at a higher abstraction level than the code. During the second top-down </context>
<context position="35646" citStr="[40]" startWordPosition="5342" endWordPosition="5342">f SAR [90, 91]. To drive a pattern-supported architecture recovery, they introduce a pattern specification language and the Revealer tool. Investigation-based Techniques. These techniques map high-level concepts with low-level concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns to design patterns, concerns, aspects, and features, that are orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execution and outputs architectural event</context>
<context position="41798" citStr="[40, 120]" startWordPosition="6265" endWordPosition="6266">mance between similar abstraction levels (horizontal conformance) and between different abstraction levels (vertical conformance). Horizontal Conformance is checked between two reconstructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, </context>
</contexts>
<marker>[40]</marker>
<rawString>Y. Guo, Atlee, and Kazman. A software architecture reconstruction method. In WICSA, pp. 15–34, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Braun Hamou-Lhadj</author>
<author>Amyot</author>
<author>Lethbridge</author>
</authors>
<title>Recovering behavioral design models from execution traces.</title>
<date>2005</date>
<booktitle>In CSMR. IEEE CS,</booktitle>
<contexts>
<context position="23781" citStr="[127, 136, 41]" startWordPosition="3589" endWordPosition="3591">is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design </context>
</contexts>
<marker>[41]</marker>
<rawString>Hamou-Lhadj, Braun, Amyot, and Lethbridge. Recovering behavioral design models from execution traces. In CSMR. IEEE CS, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hamou-Lhadj</author>
<author>Lethbridge</author>
</authors>
<title>A survey of trace exploration tools and techniques.</title>
<date>2004</date>
<booktitle>In CASCON,</booktitle>
<pages>42--55</pages>
<contexts>
<context position="24263" citStr="[42]" startWordPosition="3667" endWordPosition="3667"> more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of t</context>
<context position="40278" citStr="[42]" startWordPosition="6045" endWordPosition="6045">ava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in DiscoTect [136]. Huang et al. specify architectures with the ABC ADL [51]. As said in Section 6.2, the notion of software architecture heavily depends on the stakeholders’ interests. Since AD</context>
</contexts>
<marker>[42]</marker>
<rawString>Hamou-Lhadj and Lethbridge. A survey of trace exploration tools and techniques. In CASCON, pp. 42–55, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Reubenstein Harris</author>
<author>Yeh</author>
</authors>
<title>Reverse engineering to the architectural level.</title>
<date>1995</date>
<booktitle>In ICSE,</booktitle>
<contexts>
<context position="2414" citStr="[43]" startWordPosition="366" endWordPosition="366">ware application evolves and grows, so does its architecture. The conceptual architecture often becomes inaccurate with respect to the concrete architecture; this results in architectural erosion [75, 88], drift [88], mismatch [33], or chasm [96]. Software architecture reconstruction (SAR) is the reverse engineering process that aims at reconstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in the literature to support SAR. Mendonca et al. presented a first raw classification of SAR environments based on a few typical scenarios [78]. O’Brien et al. surveyed SAR practice needs and approaches [85]. Still, there is no comprehensive state of the art and it is often difficult to compare the approaches. This article presents a first state of the art in SAR, with the desire to help understand</context>
<context position="5109" citStr="[43]" startWordPosition="807" endWordPosition="807">nt expectations or concerns about the system [64, 52]: View: “a representation of a whole system from the perspective of a related set of concerns.” Viewpoint: “a specification of the conventions for constructing and using a view. A pattern or a template from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis.” Conceptual architecture. It refers to the architecture that exists in human minds or in the software documentation [120, 96]. In the literature, this kind of architecture is also qualified as idealized [43], intended [132, 96], asdesigned [57, 120] or logical [76]. Concrete architecture. It refers to the architecture that can be derived from source code [120, 96]. It is also known as the as-implemented [57, 96], as-built [120, 43], realized [132] or physical [76] architecture. Software architecture reconstruction (SAR). SAR is the reverse engineering approach that aims at reconstructing viable architectural views of a software application. The literature uses several other terms to refer to SAR: reverse architecting, or architecture extraction, mining, recovery or discovery. The last two terms a</context>
<context position="19907" citStr="[43, 137]" startWordPosition="2994" endWordPosition="2995">es until to reach a relevant box and arrow view of the software application. 5.3. Hybrid Processes Hybrid processes combine the previous two [112]. On the one hand, low-level knowledge is abstracted up using various techniques. On the other hand, high-level knowledge is refined. This kind of process is frequently used to stop architectural erosion by reconciling the conceptual and concrete architectures. Hybrid approaches often use hypothesis recognizers. Recognizerbased tools provide bottom-up reverse engineering strategies to support top-down exploration of architectural hypothesis. ManSART [43, 137], ART [29], X-ray [79], ARM [40] and DiscoTect [136] are examples of this approach. In ManSART, a top-down recognition engine maps a style-compliant conceptual view with a system overview which was defined using a visualization tool in a bottom-up fashion. Examples. Sartipi implemented a pattern-based SAR approach in Alborz [100, 101]. The architecture reconstruction consists of two phases. During the first bottom-up phase, the source code is parsed, presented as a graph, then divided in cohesive graph regions using data mining techniques. This model is at a higher abstraction level than the c</context>
<context position="24598" citStr="[43, 137]" startWordPosition="3714" endWordPosition="3715">idered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software architecture [6]. Historical Information. Historical information is rarely used in SAR. Still ArchView is a recent approach that exploits </context>
<context position="28714" citStr="[43, 137]" startWordPosition="4312" endWordPosition="4313">tionale behind them, effective compositions of architectural elements, and system qualities that will likely result from the style’s use. Finally, DiscoTect considers architectural styles too [136]. It generates program traces by running the instrumented application. Then, it filters the traces and uses a state engine that incrementally recognizes interleaved execution patterns. In this way, DiscoTect reconstruct stylecompliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural vie</context>
<context position="35611" citStr="[43, 137]" startWordPosition="5334" endWordPosition="5335">nd consider them as the starting point of SAR [90, 91]. To drive a pattern-supported architecture recovery, they introduce a pattern specification language and the Revealer tool. Investigation-based Techniques. These techniques map high-level concepts with low-level concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns to design patterns, concerns, aspects, and features, that are orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execut</context>
</contexts>
<marker>[43]</marker>
<rawString>Harris, Reubenstein, and Yeh. Reverse engineering to the architectural level. In ICSE, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hassan</author>
<author>Holt</author>
</authors>
<title>Using development history sticky notes to understand software architecture. iwpc,</title>
<date>2004</date>
<pages>00--183</pages>
<contexts>
<context position="25589" citStr="[44]" startWordPosition="3861" endWordPosition="3861">tion to form an ownership architecture that helps reconstruct the software architecture [6]. Historical Information. Historical information is rarely used in SAR. Still ArchView is a recent approach that exploits source control system data and bug reports to analyze the evolution of recovered architectural views [89, 92]. To assist a reverse engineer to understand underlined dependency gaps in a reflexion model [82], Hassan et al. annotate entity dependencies with sticky notes. These sticky notes record dependency evolution and rationale with information extracted from version control systems [44]. Human Expertise. Although one cannot entirely trust human knowledge, it is very helpful when it is available. At high abstraction levels, SAR is iterative and requires human knowledge to validate results and to guide it. As Ivkovic et al. state [53], a SAR approach involves strategy and knowledge of the domain and the application itself. They propose to systematically update a knowledge base that would become an helpful collection of domain-specific architectural artifacts. In current SAR approaches, it is frequent to specify a conceptual architecture [82, 44, 76]. To define this architectur</context>
</contexts>
<marker>[44]</marker>
<rawString>Hassan and Holt. Using development history sticky notes to understand software architecture. iwpc, 00:183, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hatch</author>
</authors>
<title>Software Architecture Visualisation.</title>
<date>2004</date>
<tech>Ph.D. thesis,</tech>
<institution>Univ.</institution>
<location>Durham,</location>
<contexts>
<context position="33107" citStr="[45]" startWordPosition="4970" endWordPosition="4970"> Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs using a specialized declarati</context>
</contexts>
<marker>[45]</marker>
<rawString>Hatch. Software Architecture Visualisation. Ph.D. thesis, Univ. Durham, Mar. 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Holl Heuzeroth</author>
<author>Hogstrom</author>
<author>Lowe</author>
</authors>
<title>Automatic design pattern detection. iwpc,</title>
<date>2003</date>
<pages>00--94</pages>
<contexts>
<context position="15250" citStr="[1, 3, 46, 128, 5, 39]" startWordPosition="2287" endWordPosition="2292">architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processe</context>
<context position="24411" citStr="[128, 46]" startWordPosition="3689" endWordPosition="3690">tic and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership </context>
</contexts>
<marker>[46]</marker>
<rawString>Heuzeroth, Holl, Hogstrom, and Lowe. Automatic design pattern detection. iwpc, 00:94, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nord Hofmeister</author>
<author>Soni</author>
</authors>
<title>Applied Software Architecture.</title>
<date>2000</date>
<contexts>
<context position="29139" citStr="[47, 108]" startWordPosition="4384" endWordPosition="4385">pliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be selected or defined according to the environment and the situation [107]. O’Brien et al. notably present the View-Set Scenario pattern that helps determine which architecture views sufficiently describe the system and cover stakeholder needs [85]. Examples. The Sy</context>
</contexts>
<marker>[47]</marker>
<rawString>Hofmeister, Nord, and Soni. Applied Software Architecture. 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Holt</author>
</authors>
<title>Structural manipulations of software architecture using tarski relational algebra.</title>
<date>1998</date>
<booktitle>In WCRE,</booktitle>
<pages>210--219</pages>
<contexts>
<context position="34222" citStr="[48]" startWordPosition="5127" endWordPosition="5127">92], though homonymous. Graph queries: Gupro queries graphs using a specialized declarative expression language called GReQL [19]. Rigi is based on graph transformations written in Tcl [81, 113]. Relational queries: Often, relational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code views and relations in Intensive [134, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts [94]. Programs: Some approaches build analyses as programs. For example, the analyses made in the Moose environment are performed as object-oriented programs that manipulate models representing the various inputs [17]. Lexical and structural queries: Som</context>
</contexts>
<marker>[48]</marker>
<rawString>Holt. Structural manipulations of software architecture using tarski relational algebra. In WCRE, pp. 210–219, 1998. ISBN: 0-8186-89-67-6.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Holt</author>
</authors>
<title>Sofware architecture as a shared mental model.</title>
<date>2001</date>
<booktitle>In ASERC Workshop on Software Architecture,</booktitle>
<location>Univ. of Alberta,</location>
<contexts>
<context position="1084" citStr="[49]" startWordPosition="164" endWordPosition="164"> time so their architecture inevitably drifts. Reconstructing and checking whether the architecture is still valid is thus an important aid. While there is a plethora of approaches and techniques supporting architecture reconstruction, there is no comprehensive state of the art and it is often difficult to compare the approaches. This article presents a first state of the art in software architecture reconstruction, with the desire to support the understanding of the field. 1. Introduction Software architecture acts as a shared mental model of a system expressed at a high-level of abstraction [49]. By leaving details aside, this model plays a key role as a bridge between requirements and implementation [32]. It allows one to reason architecturally about a software application during the various steps of the software life cycle. According to Garlan [32], software architecture plays an important role in at least six aspects of software development: understanding, reuse, construction, evolution, analysis and management. Software architecture is thus crucial for software development. The first problem is that architectures are not explicitly represented in the code as classes and packages </context>
<context position="28879" citStr="[49]" startWordPosition="4342" endWordPosition="4342">hitectural styles too [136]. It generates program traces by running the instrumented application. Then, it filters the traces and uses a state engine that incrementally recognizes interleaved execution patterns. In this way, DiscoTect reconstruct stylecompliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be sele</context>
</contexts>
<marker>[49]</marker>
<rawString>Holt. Sofware architecture as a shared mental model. In ASERC Workshop on Software Architecture, Univ. of Alberta, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gxl</author>
</authors>
<title>A graph-based standard exchange format for reengineering.</title>
<date>2006</date>
<journal>Science of Computer Programming,</journal>
<volume>60</volume>
<issue>2</issue>
<contexts>
<context position="23303" citStr="[50]" startWordPosition="3516" endWordPosition="3516">ches consider. Some of them query directly the source code text like in RMTool [82]. However, most of them are not directly based on the source code but represent source code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method</context>
</contexts>
<marker>[50]</marker>
<rawString>Holt, Schürr, Sim, and Winter. Gxl: A graph-based standard exchange format for reengineering. Science of Computer Programming, 60(2):149–170, 4 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mei Huang</author>
<author>Yang</author>
</authors>
<title>Runtime recovery and manipulation of software architecture of component-based systems.</title>
<date>2006</date>
<volume>13</volume>
<pages>257--281</pages>
<contexts>
<context position="13346" citStr="[51]" startWordPosition="1997" endWordPosition="1997">e two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maint</context>
<context position="23857" citStr="[54, 94, 97, 126, 69, 51, 89]" startWordPosition="3600" endWordPosition="3606">6]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 1</context>
<context position="40760" citStr="[51]" startWordPosition="6118" endWordPosition="6118">r of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in DiscoTect [136]. Huang et al. specify architectures with the ABC ADL [51]. As said in Section 6.2, the notion of software architecture heavily depends on the stakeholders’ interests. Since ADLs have difficulty in taking different viewpoints into account and focus on the module viewpoint, they are rarely used to express reconstructed architectural views. To drive SAR in CacOphoNy, Favre proposed to precisely define viewpoints using metamodels [26]. 9 8.2. Conformance We consider architecture conformance between similar abstraction levels (horizontal conformance) and between different abstraction levels (vertical conformance). Horizontal Conformance is checked betwee</context>
<context position="42795" citStr="[51]" startWordPosition="6409" endWordPosition="6409">8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we surveyed research works in the field of software architecture reconstruction (SAR). To structure the paper, we followed the general process of SAR: what are the stakeholders’ goals; how does the general reconstruction proceed; what are the available sources of information; based on this, which techniques can we apply, and finally what kind of knowledge does the proce</context>
</contexts>
<marker>[51]</marker>
<rawString>Huang, Mei, and Yang. Runtime recovery and manipulation of software architecture of component-based systems. vol. 13, pp. 257–281, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>IEEE</author>
</authors>
<title>Ieee recommended practice for architectural description for software-intensive systems.</title>
<date>2000</date>
<journal>Arch. Work. Group of the Sw.Eng. Committee,</journal>
<tech>Tech. report,</tech>
<contexts>
<context position="4005" citStr="[52]" startWordPosition="628" endWordPosition="628">irst stresses some key vocabulary definitions and the challenges addressed in the field. Section 3 describes the criteria that we adopted in our taxonomy; sections 4 to 8 then cover each of these criteria, and we conclude. 2. SAR Challenges Before going in more depth into the challenges of SAR, we feel the need to clarify the vocabulary. 2.1. Vocabulary Software architecture. IEEE defines software architecture as “the fundamental organization of a system embodied in its components, their relationships to each other, and to the environment, and the principles guiding its design and 1 evolution”[52]; this is closely related to the definition of Shaw, Perry and Garlan [102, 35]. Architectural style. A software architecture often conforms to an architectural style that is a class of architectures, or a pattern of structural organization: “a vocabulary of components and connector types, and a set of constraints on how they can be combined” [102]. Architectural views and viewpoints. We can view a software architecture from several viewpoints since the different system stakeholders have different expectations or concerns about the system [64, 52]: View: “a representation of a whole system fro</context>
<context position="28999" citStr="[52, 107]" startWordPosition="4359" endWordPosition="4360">the traces and uses a state engine that incrementally recognizes interleaved execution patterns. In this way, DiscoTect reconstruct stylecompliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be selected or defined according to the environment and the situation [107]. O’Brien et al. notably present the View-Set Scenar</context>
</contexts>
<marker>[52]</marker>
<rawString>IEEE. Ieee recommended practice for architectural description for software-intensive systems. Tech. report, Arch. Work. Group of the Sw.Eng. Committee, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ivkovic</author>
<author>Godfrey</author>
</authors>
<title>Enhancing domain-specific software architecture recovery.</title>
<date>2003</date>
<booktitle>In IWPC,</booktitle>
<pages>266</pages>
<contexts>
<context position="25840" citStr="[53]" startWordPosition="3902" endWordPosition="3902">orts to analyze the evolution of recovered architectural views [89, 92]. To assist a reverse engineer to understand underlined dependency gaps in a reflexion model [82], Hassan et al. annotate entity dependencies with sticky notes. These sticky notes record dependency evolution and rationale with information extracted from version control systems [44]. Human Expertise. Although one cannot entirely trust human knowledge, it is very helpful when it is available. At high abstraction levels, SAR is iterative and requires human knowledge to validate results and to guide it. As Ivkovic et al. state [53], a SAR approach involves strategy and knowledge of the domain and the application itself. They propose to systematically update a knowledge base that would become an helpful collection of domain-specific architectural artifacts. In current SAR approaches, it is frequent to specify a conceptual architecture [82, 44, 76]. To define this architecture, reverse engineers have to study system requirements, read available documentation, interview stakeholders, recover design rationale, investigate hypotheses and analyze the business domain. 6 Human expertise is also required when specifying viewpoin</context>
</contexts>
<marker>[53]</marker>
<rawString>Ivkovic and Godfrey. Enhancing domain-specific software architecture recovery. In IWPC, p. 266, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jerding</author>
<author>Rugaber</author>
</authors>
<title>Using visualization for architectural localization and extraction.</title>
<date>1997</date>
<booktitle>In WCRE,</booktitle>
<pages>56--65</pages>
<contexts>
<context position="23857" citStr="[54, 94, 97, 126, 69, 51, 89]" startWordPosition="3600" endWordPosition="3606">6]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 1</context>
</contexts>
<marker>[54]</marker>
<rawString>Jerding and Rugaber. Using visualization for architectural localization and extraction. In WCRE, pp. 56–65, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kazman</author>
<author>Bass</author>
</authors>
<title>Categorizing business goals for software architectures.</title>
<date>2005</date>
<tech>CMU/SEI-2005-TR-021, CMU SEI,</tech>
<contexts>
<context position="10948" citStr="[55]" startWordPosition="1637" endWordPosition="1637">oints which are the paramount of architecture. Techniques. The research community has explored various techniques to reconstruct architecture that can be roughly classified according to their automation level. Outputs. While all SAR approaches intend to provide architectural views, some of them however produce other valuable outputs like conformance data. 4. SAR Goals We discuss now the goals of SAR as well as related artifacts. 4.1. Goals Several authors categorized architecture roles in software development [32]; in particular, Kazman et al. have a pragmatic categorization of business goals [55]. In the context 3 of maintenance, a SAR process answers stakeholder business objectives. It must be considered as a proactive process realized for future forward engineering tasks. SAR approaches match various often interleaved intentions: Redocumentation and understanding: The primary goal of SAR is to re-establish software abstractions. Recovered architectural views document software applications and help reverse engineers understand them. For instance, the software bookshelf introduced by Finningan et al. illustrates this goal [28]. Svetinovic et al. state that not only the recovered archi</context>
</contexts>
<marker>[55]</marker>
<rawString>Kazman and Bass. Categorizing business goals for software architectures. CMU/SEI-2005-TR-021, CMU SEI, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Saam</author>
</authors>
<title>A method for analyzing the properties of software architectures.</title>
<date>1994</date>
<booktitle>In ICSE,</booktitle>
<pages>81--90</pages>
<contexts>
<context position="13810" citStr="[56]" startWordPosition="2066" endWordPosition="2066">rce-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should evolve. Krikhaar et al. also introduced a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some approaches do not extract the architecture in itself but architectural </context>
</contexts>
<marker>[56]</marker>
<rawString>Kazman, Bass, Webb, and Abowd. Saam: A method for analyzing the properties of software architectures. In ICSE, pp. 81–90, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kazman</author>
<author>Carriere</author>
</authors>
<title>Playing detective: Reconstructing software architecture from available evidence.</title>
<date>1999</date>
<publisher>ASE,</publisher>
<contexts>
<context position="5151" citStr="[57, 120]" startWordPosition="813" endWordPosition="814"> system [64, 52]: View: “a representation of a whole system from the perspective of a related set of concerns.” Viewpoint: “a specification of the conventions for constructing and using a view. A pattern or a template from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis.” Conceptual architecture. It refers to the architecture that exists in human minds or in the software documentation [120, 96]. In the literature, this kind of architecture is also qualified as idealized [43], intended [132, 96], asdesigned [57, 120] or logical [76]. Concrete architecture. It refers to the architecture that can be derived from source code [120, 96]. It is also known as the as-implemented [57, 96], as-built [120, 43], realized [132] or physical [76] architecture. Software architecture reconstruction (SAR). SAR is the reverse engineering approach that aims at reconstructing viable architectural views of a software application. The literature uses several other terms to refer to SAR: reverse architecting, or architecture extraction, mining, recovery or discovery. The last two terms are more specific than the others [75]: rec</context>
<context position="13742" citStr="[57, 84]" startWordPosition="2055" endWordPosition="2056">es logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should evolve. Krikhaar et al. also introduced a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some app</context>
<context position="16686" citStr="[57, 84]" startWordPosition="2502" endWordPosition="2503">raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system representations, which are then presented in a suitable interactive form to reverse engineers. Examples. Several tools support a bottom-up process characterized by the extract-abstract-present metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engineer can specify patterns using SQL queries and Perl expressions. The former selects a set of source model entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group re</context>
<context position="33967" citStr="[57, 84]" startWordPosition="5088" endWordPosition="5089">chniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs using a specialized declarative expression language called GReQL [19]. Rigi is based on graph transformations written in Tcl [81, 113]. Relational queries: Often, relational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code views and relations in Intensive [134, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts</context>
<context position="35877" citStr="[57, 84]" startWordPosition="5378" endWordPosition="5379">concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns to design patterns, concerns, aspects, and features, that are orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execution and outputs architectural events when the execution satisfies 8 the state machine description. Maps. SAR approaches based on the Reflexion Model [82] use rules to map hypothesized high-level entities with source code entities. 7.3. Quasi-Automatic Techniques Pur</context>
<context position="39137" citStr="[28, 57, 18, 61, 91, 100, 96]" startWordPosition="5863" endWordPosition="5869">e clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose </context>
</contexts>
<marker>[57]</marker>
<rawString>Kazman and Carrière. Playing detective: Reconstructing software architecture from available evidence. ASE, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Klein Kazman</author>
<author>Longstaff Barbacci</author>
<author>Lipson</author>
<author>Carriere</author>
</authors>
<title>The architecture tradeoff analysis method.</title>
<date>1998</date>
<booktitle>In ICECCS,</booktitle>
<pages>68--78</pages>
<contexts>
<context position="13823" citStr="[58]" startWordPosition="2069" endWordPosition="2069">s and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should evolve. Krikhaar et al. also introduced a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some approaches do not extract the architecture in itself but architectural correlated or</context>
</contexts>
<marker>[58]</marker>
<rawString>Kazman, Klein, Barbacci, Longstaff, Lipson, and Carrière. The architecture tradeoff analysis method. In ICECCS, pp. 68–78, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kellens</author>
</authors>
<title>Mens. A survey of aspect mining tools and techniques.</title>
<date>2005</date>
<tech>Tech. Report INGI TR 2005-07,</tech>
<location>UCL,</location>
<contexts>
<context position="15540" citStr="[10, 59, 83]" startWordPosition="2336" endWordPosition="2338">space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstraction level until a high-level understanding o</context>
</contexts>
<marker>[59]</marker>
<rawString>Kellens and Mens. A survey of aspect mining tools and techniques. Tech. Report INGI TR 2005-07, UCL, Belgium, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kazman Klein</author>
<author>Carriere Bass</author>
<author>Barbacci</author>
<author>Lipson</author>
</authors>
<title>Attribute-based architecture styles.</title>
<date>1999</date>
<booktitle>In WICSA,</booktitle>
<pages>225--244</pages>
<contexts>
<context position="26821" citStr="[60]" startWordPosition="4037" endWordPosition="4037"> study system requirements, read available documentation, interview stakeholders, recover design rationale, investigate hypotheses and analyze the business domain. 6 Human expertise is also required when specifying viewpoints, selecting architectural styles (Section 6.2), or investigating orthogonal artifacts (Section 4.2). 6.2. Architectural Inputs Architectural styles and viewpoints are the paramount of software architecture, therefore we analyzed whether SAR consider them. Styles. Architectural styles are popular since like design patterns, they represent recurrent architectural situations [60]. They are valuable, expressive, and accepted abstractions for SAR and more generally for software understanding. Recognizing them is however a challenge because they basically span several architectural elements and can be implemented in various ways [91]. The question that turns up is whether SAR helps reverse engineers specify and extract architectural styles. Examples. Ding et al. proposed to use architectural styles in Focus to infer a conceptual architecture that will be mapped to a concrete architecture extracted from the source code [16, 76]. Closely related to this work, Medvidovic et</context>
</contexts>
<marker>[60]</marker>
<rawString>Klein, Kazman, Bass, Carrière, Barbacci, and Lipson. Attribute-based architecture styles. In WICSA, pp. 225– 244, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Koschke</author>
</authors>
<title>Atomic Architectural Component Recovery for Program Understanding and Evolution.</title>
<date>2000</date>
<tech>PhD thesis,</tech>
<institution>Univ.</institution>
<location>Stuttgart,</location>
<contexts>
<context position="37369" citStr="[61, 21, 11]" startWordPosition="5599" endWordPosition="5601">clustering algorithms to automatically partition software products into cohesive clusters that are loosely interconnected [129]. Clustering algorithms, based on hill climbing and genetic algorithms, are applied on module dependency graphs extracted from source code. The Bunch tool was extended to take into account human knowledge [74]. According to Xiao et al. [135], clustering techniques applied to dynamic analysis are as efficient as those applied to static analysis, and this research area is promising and unexplored. The Bauhaus environment implements a wide number of clustering techniques [61, 21, 11]. Koschke emphasizes the need to refine existing clustering techniques, first by combining them, and second by integrating the reverse engineer as a conformance supervisor of the reconstruction process. Adhering to Koschke’s thesis, Trifu unifies cluster and dominance analysis techniques for the recovery of architectural components in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance a</context>
<context position="39137" citStr="[28, 57, 18, 61, 91, 100, 96]" startWordPosition="5863" endWordPosition="5869">e clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose </context>
<context position="42405" citStr="[61, 21, 11]" startWordPosition="6351" endWordPosition="6353"> 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusi</context>
</contexts>
<marker>[61]</marker>
<rawString>Koschke. Atomic Architectural Component Recovery for Program Understanding and Evolution. PhD thesis, Univ. Stuttgart, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Krikhaar</author>
</authors>
<title>Software Architecture Reconstruction.</title>
<date>1999</date>
<tech>PhD thesis,</tech>
<institution>Univ.</institution>
<location>Amsterdam,</location>
<contexts>
<context position="2266" citStr="[62]" startWordPosition="342" endWordPosition="342"> classes and packages are. The second problem is that successful software applications are doomed to continually evolve and grow [67]; and as a software application evolves and grows, so does its architecture. The conceptual architecture often becomes inaccurate with respect to the concrete architecture; this results in architectural erosion [75, 88], drift [88], mismatch [33], or chasm [96]. Software architecture reconstruction (SAR) is the reverse engineering process that aims at reconstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in the literature to support SAR. Mendonca et al. presented a first raw classification of SAR environments based on a few typical scenarios [78]. O’Brien et al. surveyed SAR practice needs and approaches [85]. Still, there is no comprehensive state of th</context>
<context position="12630" citStr="[62]" startWordPosition="1896" endWordPosition="1896">lities among products in a line [109, 93, 18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relat</context>
<context position="14213" citStr="[62, 63]" startWordPosition="2133" endWordPosition="2134">analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should evolve. Krikhaar et al. also introduced a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some approaches do not extract the architecture in itself but architectural correlated or side-effect artifacts that crosscut or complement the architecture such as design patterns, concerns, features, aspects, or roles and collaborations. While such information is not directly related to the architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable informa</context>
<context position="31232" citStr="[62]" startWordPosition="4699" endWordPosition="4699">ny, CacOphoNy recognizes the need to identify which viewpoints are relevant for stakeholder concerns and have to be considered in SAR. Contrary to Symphony, CacOphoNy states that metamodels are keys for representing viewpoints. The QADSAR approach both reconstructs the architecture of a system and drives quality attribute analyses on it [110, 111]. To do this, QADSAR allows reverse engineers to formulate their interests in reconstructing the architecture by means of concrete quality attribute scenarios. This results in the definition of relevant architectural viewpoints. ARES [23, 22] and SAR [62] also take viewpoints into account. 7. SAR Techniques Techniques and the data they operate on are often correlated. For example, input information is represented respectively as facts [80] or graphs [19] to use logic or graph queries. 7 SAR approaches use different techniques that we classified according to their automation level: quasi-manual, the reverse engineer manually identifies architectural elements using a tool to assist him to understand his findings; semiautomatic, the reverse engineer manually instructs the tool how to automatically discover refinements or recover abstractions. qua</context>
<context position="34301" citStr="[62]" startWordPosition="5139" endWordPosition="5139"> declarative expression language called GReQL [19]. Rigi is based on graph transformations written in Tcl [81, 113]. Relational queries: Often, relational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code views and relations in Intensive [134, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts [94]. Programs: Some approaches build analyses as programs. For example, the analyses made in the Moose environment are performed as object-oriented programs that manipulate models representing the various inputs [17]. Lexical and structural queries: Some approaches are directly based on the lexical and structural information in th</context>
<context position="41926" citStr="[62]" startWordPosition="6286" endWordPosition="6286">rizontal Conformance is checked between two reconstructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides s</context>
</contexts>
<marker>[62]</marker>
<rawString>Krikhaar. Software Architecture Reconstruction. PhD thesis, Univ. Amsterdam, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Postma Krikhaar</author>
<author>Stroucken Sellink</author>
<author>Verhoef</author>
</authors>
<title>A twophase process for software architecture improvement.</title>
<date>1999</date>
<booktitle>In ICSM,</booktitle>
<pages>371</pages>
<contexts>
<context position="14213" citStr="[62, 63]" startWordPosition="2133" endWordPosition="2134">analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should evolve. Krikhaar et al. also introduced a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some approaches do not extract the architecture in itself but architectural correlated or side-effect artifacts that crosscut or complement the architecture such as design patterns, concerns, features, aspects, or roles and collaborations. While such information is not directly related to the architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable informa</context>
<context position="38978" citStr="[63]" startWordPosition="5843" endWordPosition="5843">software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different ta</context>
</contexts>
<marker>[63]</marker>
<rawString>Krikhaar, Postma, Sellink, Stroucken, and Verhoef. A twophase process for software architecture improvement. In ICSM, p. 371, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kruchten</author>
</authors>
<title>The 4+1 view model of architecture.</title>
<date>1995</date>
<journal>IEEE Software,</journal>
<volume>12</volume>
<issue>6</issue>
<contexts>
<context position="4558" citStr="[64, 52]" startWordPosition="714" endWordPosition="715"> the principles guiding its design and 1 evolution”[52]; this is closely related to the definition of Shaw, Perry and Garlan [102, 35]. Architectural style. A software architecture often conforms to an architectural style that is a class of architectures, or a pattern of structural organization: “a vocabulary of components and connector types, and a set of constraints on how they can be combined” [102]. Architectural views and viewpoints. We can view a software architecture from several viewpoints since the different system stakeholders have different expectations or concerns about the system [64, 52]: View: “a representation of a whole system from the perspective of a related set of concerns.” Viewpoint: “a specification of the conventions for constructing and using a view. A pattern or a template from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis.” Conceptual architecture. It refers to the architecture that exists in human minds or in the software documentation [120, 96]. In the literature, this kind of architecture is also qualified as idealized [43], intended [132, 96], asdesigned [57, 120] or log</context>
<context position="29093" citStr="[64]" startWordPosition="4376" endWordPosition="4376"> this way, DiscoTect reconstruct stylecompliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be selected or defined according to the environment and the situation [107]. O’Brien et al. notably present the View-Set Scenario pattern that helps determine which architecture views sufficiently describe the system and </context>
</contexts>
<marker>[64]</marker>
<rawString>Kruchten. The 4+1 view model of architecture. IEEE Software, 12(6):42–50, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Ducasse Kuhn</author>
<author>Gırba</author>
</authors>
<title>Enriching reverse engineering with semantic clustering.</title>
<date>2005</date>
<booktitle>In WCRE,</booktitle>
<pages>113--122</pages>
<contexts>
<context position="23473" citStr="[65]" startWordPosition="3544" endWordPosition="3544">code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system se</context>
</contexts>
<marker>[65]</marker>
<rawString>Kuhn, Ducasse, and Gı̂rba. Enriching reverse engineering with semantic clustering. In WCRE, pp. 113–122, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lanza</author>
<author>Ducasse</author>
</authors>
<title>Polymetric views—A lightweight visual approach to reverse engineering.</title>
<date>2003</date>
<booktitle>IEEE CS,</booktitle>
<volume>29</volume>
<pages>782--795</pages>
<contexts>
<context position="32484" citStr="[66]" startWordPosition="4879" endWordPosition="4879">everse engineer steers the iterative recovery process. Of course, the boundaries between the classifications are not clear-cut. 7.1. Quasi-Manual Techniques SAR is a reverse engineering activity which faces scalability issues in manipulating knowledge. In response to this problem, researchers have proposed slightly assisted SAR approaches; we considered two categories. Construction-based Techniques. These techniques reconstruct the software architecture by manually abstracting low-level knowledge, thanks to interactive and expressive visualization tools — Rigi [81, 113], PBS [28], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePU</context>
<context position="39473" citStr="[66]" startWordPosition="5918" endWordPosition="5918">ctures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed </context>
</contexts>
<marker>[66]</marker>
<rawString>Lanza and Ducasse. Polymetric views—A lightweight visual approach to reverse engineering. vol. 29, pp. 782–795. IEEE CS, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lehman</author>
<author>Belady</author>
</authors>
<date>1985</date>
<booktitle>Program Evolution: Processes of Software Change.</booktitle>
<contexts>
<context position="1795" citStr="[67]" startWordPosition="273" endWordPosition="273"> [32]. It allows one to reason architecturally about a software application during the various steps of the software life cycle. According to Garlan [32], software architecture plays an important role in at least six aspects of software development: understanding, reuse, construction, evolution, analysis and management. Software architecture is thus crucial for software development. The first problem is that architectures are not explicitly represented in the code as classes and packages are. The second problem is that successful software applications are doomed to continually evolve and grow [67]; and as a software application evolves and grows, so does its architecture. The conceptual architecture often becomes inaccurate with respect to the concrete architecture; this results in architectural erosion [75, 88], drift [88], mismatch [33], or chasm [96]. Software architecture reconstruction (SAR) is the reverse engineering process that aims at reconstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated softwa</context>
</contexts>
<marker>[67]</marker>
<rawString>Lehman and Belady. Program Evolution: Processes of Software Change. 1985.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tichelaar Lethbridge</author>
<author>Plodereder</author>
</authors>
<title>The dagstuhl middle metamodel: A schema for reverse engineering.</title>
<date>2004</date>
<booktitle>In Elec. Notes in Theoretical Comp. Sci.,</booktitle>
<volume>94</volume>
<pages>7--18</pages>
<contexts>
<context position="23291" citStr="[68]" startWordPosition="3513" endWordPosition="3513"> most approaches consider. Some of them query directly the source code text like in RMTool [82]. However, most of them are not directly based on the source code but represent source code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events su</context>
</contexts>
<marker>[68]</marker>
<rawString>Lethbridge, Tichelaar, and Plödereder. The dagstuhl middle metamodel: A schema for reverse engineering. In Elec. Notes in Theoretical Comp. Sci., vol. 94, pp. 7–18, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Chu Li</author>
<author>Chen Hu</author>
<author>Yun</author>
</authors>
<title>Architecture recovery and abstraction from the perspective of processes.</title>
<date>2005</date>
<booktitle>In WCRE,</booktitle>
<pages>57--66</pages>
<contexts>
<context position="23857" citStr="[54, 94, 97, 126, 69, 51, 89]" startWordPosition="3600" endWordPosition="3606">6]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 1</context>
</contexts>
<marker>[69]</marker>
<rawString>Li, Chu, Hu, Chen, and Yun. Architecture recovery and abstraction from the perspective of processes. In WCRE, pp. 57–66, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lundberg</author>
<author>Lowe</author>
</authors>
<title>Architecture recovery by semiautomatic component identification.</title>
<date>2003</date>
<journal>Electr. Notes Theor. Comput. Sci.,</journal>
<volume>82</volume>
<issue>5</issue>
<contexts>
<context position="37837" citStr="[70]" startWordPosition="5667" endWordPosition="5667">d this research area is promising and unexplored. The Bauhaus environment implements a wide number of clustering techniques [61, 21, 11]. Koschke emphasizes the need to refine existing clustering techniques, first by combining them, and second by integrating the reverse engineer as a conformance supervisor of the reconstruction process. Adhering to Koschke’s thesis, Trifu unifies cluster and dominance analysis techniques for the recovery of architectural components in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance analysis is not sufficient to recover the complete architecture: it requires other techniques such as concept analysis to take component interactions into account. Concept analysis techniques were explored by Siff et al. [104], van Deursen et al. [125], Arevalo [3, 2] or Eisenbarth et al. [21] and surveyed by Tilley et al. [118]. 8. SAR Outputs While most approaches focus on producing presentations of software architectures, some provide valuable additional inform</context>
</contexts>
<marker>[70]</marker>
<rawString>Lundberg and Löwe. Architecture recovery by semiautomatic component identification. Electr. Notes Theor. Comput. Sci., 82(5), 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Lanza Lungu</author>
<author>Gırba</author>
</authors>
<title>Package patterns for visual architecture recovery. In CSMR</title>
<date>2006</date>
<contexts>
<context position="18475" citStr="[71]" startWordPosition="2778" endWordPosition="2778">ptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies consistencies and inconsistencies. Like that, the reverse engineer iteratively interprets and computes successive reflexion models until satisfied. Lungu et al. built both a method and a tool called Softwarenaut [71] to interactively explore hierarchical decompositions of software applications. Their method differs from other classical exploration tools: to construct an architectural view on the fly, they enhance the exploration process in guiding the reverse engineer towards the relevant hierarchical parts. They characterize packages based on their relation with the other ones and on their internal structure. Categorizing such an approach shows the limit of a strict classification. The approach takes into account physical entities such as packages and does not check the conformance to predefined views as</context>
<context position="23214" citStr="[71]" startWordPosition="3501" endWordPosition="3501">cts. The source code is an omnipresent trustworthy source of information that most approaches consider. Some of them query directly the source code text like in RMTool [82]. However, most of them are not directly based on the source code but represent source code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dyna</context>
<context position="24620" citStr="[71]" startWordPosition="3719" endWordPosition="3719">tion because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software architecture [6]. Historical Information. Historical information is rarely used in SAR. Still ArchView is a recent approach that exploits source control system </context>
<context position="32692" citStr="[71]" startWordPosition="4907" endWordPosition="4907">calability issues in manipulating knowledge. In response to this problem, researchers have proposed slightly assisted SAR approaches; we considered two categories. Construction-based Techniques. These techniques reconstruct the software architecture by manually abstracting low-level knowledge, thanks to interactive and expressive visualization tools — Rigi [81, 113], PBS [28], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identificatio</context>
<context position="39452" citStr="[92, 80, 71]" startWordPosition="5912" endWordPosition="5914"> of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy </context>
</contexts>
<marker>[71]</marker>
<rawString>Lungu, Lanza, and Gı̂rba. Package patterns for visual architecture recovery. In CSMR 2006, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dulay Magee</author>
<author>Eisenbach</author>
<author>Kramer</author>
</authors>
<title>Specifying distributed software architectures.</title>
<date>1995</date>
<booktitle>In ESEC,</booktitle>
<volume>989</volume>
<pages>137--153</pages>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="40496" citStr="[72]" startWordPosition="6074" endWordPosition="6074">]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in DiscoTect [136]. Huang et al. specify architectures with the ABC ADL [51]. As said in Section 6.2, the notion of software architecture heavily depends on the stakeholders’ interests. Since ADLs have difficulty in taking different viewpoints into account and focus on the module viewpoint, they are rarely used to express reconstructed architectural views. To drive SAR in CacOphoNy, Favre proposed to precisel</context>
</contexts>
<marker>[72]</marker>
<rawString>Magee, Dulay, Eisenbach, and Kramer. Specifying distributed software architectures. In ESEC, vol. 989 of LNCS, pp. 137–153. Springer-Verlag, Sept. 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mancoridis</author>
<author>Mitchell</author>
</authors>
<title>Using Automatic Clustering to produce High-Level System Organizations of Source Code.</title>
<date>1998</date>
<booktitle>In IWPC,</booktitle>
<contexts>
<context position="36751" citStr="[73, 74]" startWordPosition="5506" endWordPosition="5507">nformance [136]. A state engine tracks at run-time the system execution and outputs architectural events when the execution satisfies 8 the state machine description. Maps. SAR approaches based on the Reflexion Model [82] use rules to map hypothesized high-level entities with source code entities. 7.3. Quasi-Automatic Techniques Pure automatic techniques failed in reconstructing software architectures, and even if current techniques tend towards an automatic process, reverse engineers must still steer them. Concept, dominance, and cluster analysis techniques are often combined. The Bunch tool [73, 74] uses clustering algorithms to automatically partition software products into cohesive clusters that are loosely interconnected [129]. Clustering algorithms, based on hill climbing and genetic algorithms, are applied on module dependency graphs extracted from source code. The Bunch tool was extended to take into account human knowledge [74]. According to Xiao et al. [135], clustering techniques applied to dynamic analysis are as efficient as those applied to static analysis, and this research area is promising and unexplored. The Bauhaus environment implements a wide number of clustering techn</context>
</contexts>
<marker>[73]</marker>
<rawString>Mancoridis and Mitchell. Using Automatic Clustering to produce High-Level System Organizations of Source Code. In IWPC, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Bunch</author>
</authors>
<title>A Clustering Tool for the Recovery and Maintenance of Software System Structures.</title>
<date>1999</date>
<booktitle>In ICSM,</booktitle>
<contexts>
<context position="36751" citStr="[73, 74]" startWordPosition="5506" endWordPosition="5507">nformance [136]. A state engine tracks at run-time the system execution and outputs architectural events when the execution satisfies 8 the state machine description. Maps. SAR approaches based on the Reflexion Model [82] use rules to map hypothesized high-level entities with source code entities. 7.3. Quasi-Automatic Techniques Pure automatic techniques failed in reconstructing software architectures, and even if current techniques tend towards an automatic process, reverse engineers must still steer them. Concept, dominance, and cluster analysis techniques are often combined. The Bunch tool [73, 74] uses clustering algorithms to automatically partition software products into cohesive clusters that are loosely interconnected [129]. Clustering algorithms, based on hill climbing and genetic algorithms, are applied on module dependency graphs extracted from source code. The Bunch tool was extended to take into account human knowledge [74]. According to Xiao et al. [135], clustering techniques applied to dynamic analysis are as efficient as those applied to static analysis, and this research area is promising and unexplored. The Bauhaus environment implements a wide number of clustering techn</context>
<context position="39875" citStr="[74, 79]" startWordPosition="5980" endWordPosition="5981"> also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of th</context>
</contexts>
<marker>[74]</marker>
<rawString>Mancoridis, Mitchell, Chen, and Gansner. Bunch: A Clustering Tool for the Recovery and Maintenance of Software System Structures. In ICSM, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Egyed Medvidovic</author>
<author>Gruenbacher</author>
</authors>
<title>Stemming architectural erosion by architectural discovery and recovery. In</title>
<date>2003</date>
<booktitle>STRAW,</booktitle>
<contexts>
<context position="2014" citStr="[75, 88]" startWordPosition="305" endWordPosition="306">x aspects of software development: understanding, reuse, construction, evolution, analysis and management. Software architecture is thus crucial for software development. The first problem is that architectures are not explicitly represented in the code as classes and packages are. The second problem is that successful software applications are doomed to continually evolve and grow [67]; and as a software application evolves and grows, so does its architecture. The conceptual architecture often becomes inaccurate with respect to the concrete architecture; this results in architectural erosion [75, 88], drift [88], mismatch [33], or chasm [96]. Software architecture reconstruction (SAR) is the reverse engineering process that aims at reconstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in </context>
<context position="5746" citStr="[75]" startWordPosition="904" endWordPosition="904">[57, 120] or logical [76]. Concrete architecture. It refers to the architecture that can be derived from source code [120, 96]. It is also known as the as-implemented [57, 96], as-built [120, 43], realized [132] or physical [76] architecture. Software architecture reconstruction (SAR). SAR is the reverse engineering approach that aims at reconstructing viable architectural views of a software application. The literature uses several other terms to refer to SAR: reverse architecting, or architecture extraction, mining, recovery or discovery. The last two terms are more specific than the others [75]: recovery refers to a bottom-up process while discovery refers to a top-down process (see Section 5). 2.2. Challenges SAR is a multidisciplinary activity which covers several research areas dealing with information processing: extraction, abstraction, modeling and presentation of the results. On the one hand, human expertise is primordial to treat architectural concepts. Knowledge of business goals, requirements, product family reference architectures, or design constraints is useful to assist SAR. However, when we take human knowledge into consideration, several problems appear: • Because of</context>
<context position="12692" citStr="[75]" startWordPosition="1906" endWordPosition="1906">: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]</context>
<context position="27589" citStr="[75]" startWordPosition="4154" endWordPosition="4154">ey basically span several architectural elements and can be implemented in various ways [91]. The question that turns up is whether SAR helps reverse engineers specify and extract architectural styles. Examples. Ding et al. proposed to use architectural styles in Focus to infer a conceptual architecture that will be mapped to a concrete architecture extracted from the source code [16, 76]. Closely related to this work, Medvidovic et al. introduced an approach to stop architectural erosion. In a topdown process, requirements serve as high-level knowledge to discover the conceptual architecture [75]. In a bottom-up process, system implementation serves as low level knowledge to recover the concrete architecture. Both the conceptual and the concrete architectures are incrementally built. The reverse engineer reconciles the two architectures, based on architectural styles. To select the most appropriate one, they characterize each architectural style according to several criteria. Their approach considers architectural styles as key design idioms since they capture a large number of design decisions, the rationale behind them, effective compositions of architectural elements, and system qu</context>
<context position="41958" citStr="[75]" startWordPosition="6292" endWordPosition="6292">between two reconstructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary prope</context>
</contexts>
<marker>[75]</marker>
<rawString>Medvidovic, Egyed, and Gruenbacher. Stemming architectural erosion by architectural discovery and recovery. In STRAW, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Medvidovic</author>
<author>Jakobac</author>
</authors>
<title>Using software evolution to focus architectural recovery.</title>
<date>2006</date>
<volume>13</volume>
<pages>225--256</pages>
<contexts>
<context position="5167" citStr="[76]" startWordPosition="817" endWordPosition="817">w: “a representation of a whole system from the perspective of a related set of concerns.” Viewpoint: “a specification of the conventions for constructing and using a view. A pattern or a template from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis.” Conceptual architecture. It refers to the architecture that exists in human minds or in the software documentation [120, 96]. In the literature, this kind of architecture is also qualified as idealized [43], intended [132, 96], asdesigned [57, 120] or logical [76]. Concrete architecture. It refers to the architecture that can be derived from source code [120, 96]. It is also known as the as-implemented [57, 96], as-built [120, 43], realized [132] or physical [76] architecture. Software architecture reconstruction (SAR). SAR is the reverse engineering approach that aims at reconstructing viable architectural views of a software application. The literature uses several other terms to refer to SAR: reverse architecting, or architecture extraction, mining, recovery or discovery. The last two terms are more specific than the others [75]: recovery refers to </context>
<context position="12676" citStr="[16, 76]" startWordPosition="1902" endWordPosition="1903">18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promot</context>
<context position="13995" citStr="[16, 76]" startWordPosition="2095" endWordPosition="2096"> evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should evolve. Krikhaar et al. also introduced a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some approaches do not extract the architecture in itself but architectural correlated or side-effect artifacts that crosscut or complement the architecture such as design patterns, concerns, features, aspects, or roles and collaborations. While such informatio</context>
<context position="22070" citStr="[16, 76]" startWordPosition="3323" endWordPosition="3324">apped to hypothesized entities. To assess the creation of product lines, Stoermer et al. introduce the MAP method [109]. MAP combines (1) a bottom-up process, to recover the concrete architectures of existing products; (2) a top-down process, to map architectural styles onto recovered architectural views; (3) an approach to analyze commonalities and variabilities among recovered architectures. They stress the ability of architectural styles to act as the structural glue of the components, and to highlight architecture strengths and weaknesses. Other hybrid processes for instance include Focus [16, 76] and Nimeta [96]. 6. SAR Inputs SAR essentially works on source code representations. However, other kinds of information are sometimes considered such as dynamic information extracted from a system as it is running or historical data held by version control system repositories. In addition a few approaches take into account architectural elements such as styles or viewpoints as input to SAR. The current trend is to feed SAR with heterogeneous information of diverse abstraction levels. 6.1. Non-Architectural Inputs Source Code Constructs. The source code is an omnipresent trustworthy source of</context>
<context position="26161" citStr="[82, 44, 76]" startWordPosition="3948" endWordPosition="3950">racted from version control systems [44]. Human Expertise. Although one cannot entirely trust human knowledge, it is very helpful when it is available. At high abstraction levels, SAR is iterative and requires human knowledge to validate results and to guide it. As Ivkovic et al. state [53], a SAR approach involves strategy and knowledge of the domain and the application itself. They propose to systematically update a knowledge base that would become an helpful collection of domain-specific architectural artifacts. In current SAR approaches, it is frequent to specify a conceptual architecture [82, 44, 76]. To define this architecture, reverse engineers have to study system requirements, read available documentation, interview stakeholders, recover design rationale, investigate hypotheses and analyze the business domain. 6 Human expertise is also required when specifying viewpoints, selecting architectural styles (Section 6.2), or investigating orthogonal artifacts (Section 4.2). 6.2. Architectural Inputs Architectural styles and viewpoints are the paramount of software architecture, therefore we analyzed whether SAR consider them. Styles. Architectural styles are popular since like design patt</context>
<context position="27376" citStr="[16, 76]" startWordPosition="4121" endWordPosition="4122">hey represent recurrent architectural situations [60]. They are valuable, expressive, and accepted abstractions for SAR and more generally for software understanding. Recognizing them is however a challenge because they basically span several architectural elements and can be implemented in various ways [91]. The question that turns up is whether SAR helps reverse engineers specify and extract architectural styles. Examples. Ding et al. proposed to use architectural styles in Focus to infer a conceptual architecture that will be mapped to a concrete architecture extracted from the source code [16, 76]. Closely related to this work, Medvidovic et al. introduced an approach to stop architectural erosion. In a topdown process, requirements serve as high-level knowledge to discover the conceptual architecture [75]. In a bottom-up process, system implementation serves as low level knowledge to recover the concrete architecture. Both the conceptual and the concrete architectures are incrementally built. The reverse engineer reconciles the two architectures, based on architectural styles. To select the most appropriate one, they characterize each architectural style according to several criteria.</context>
<context position="38966" citStr="[16, 76]" startWordPosition="5839" endWordPosition="5840">resentations of software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of </context>
<context position="41942" citStr="[16, 76]" startWordPosition="6288" endWordPosition="6289">formance is checked between two reconstructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and ev</context>
</contexts>
<marker>[76]</marker>
<rawString>Medvidovic and Jakobac. Using software evolution to focus architectural recovery. vol. 13, pp. 225–256, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Medvidovic</author>
<author>Taylor</author>
</authors>
<title>A classification and comparison framework for software architecture description languages.</title>
<date>2000</date>
<volume>26</volume>
<pages>70--93</pages>
<contexts>
<context position="40455" citStr="[77]" startWordPosition="6066" endWordPosition="6066">iz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in DiscoTect [136]. Huang et al. specify architectures with the ABC ADL [51]. As said in Section 6.2, the notion of software architecture heavily depends on the stakeholders’ interests. Since ADLs have difficulty in taking different viewpoints into account and focus on the module viewpoint, they are rarely used to express reconstructed architectural views. To drive SAR</context>
</contexts>
<marker>[77]</marker>
<rawString>Medvidovic and Taylor. A classification and comparison framework for software architecture description languages. vol. 26, pp. 70–93, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mendonca</author>
<author>Kramer</author>
</authors>
<title>Requirements for an effective architecture recovery framework.</title>
<date>1996</date>
<booktitle>In ISAW-2 and Viewpoints workshops,</booktitle>
<pages>101--105</pages>
<contexts>
<context position="2756" citStr="[78]" startWordPosition="419" endWordPosition="419">onstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in the literature to support SAR. Mendonca et al. presented a first raw classification of SAR environments based on a few typical scenarios [78]. O’Brien et al. surveyed SAR practice needs and approaches [85]. Still, there is no comprehensive state of the art and it is often difficult to compare the approaches. This article presents a first state of the art in SAR, with the desire to help understand the field and to identify the current approaches, techniques and tools. The presented taxonomy takes the perspective of a reverseengineer who would like to reconstruct the architecture of an existing application and would like to know which tools or approach to take. The taxonomy takes into account the goals, the process, the inputs, the t</context>
<context position="8156" citStr="[78]" startWordPosition="1258" endWordPosition="1258">nguage concepts such as polymorphism, late-binding, delegation, or inheritance make it harder to analyze the code [130, 14]. How to identify the relevant information to reach an architectural level? • The nature of software raises the questions of whether dynamic information should be extracted as the system is running, and then how do the behavioral aspects appear in the architecture. To summarize this section, the major challenge of SAR is in abstracting, identifying and displaying higher-level views from lower-level and often heterogeneous information. 3. SAR Taxonomy Axes Mendonca et al. [78] classified SAR environments and distinguished five families: filtering and clustering, compliance checking, analysers generators, program understanding and architecture recognition. O’Brien et al. surveyed SAR practice needs and approaches [85]. Gallagher et al. [30] proposed a framework to assess architectural visualization tools. Gueheneuc et al. [38] proposed a comparative framework for design recovery tools. We propose a more elaborated classification based on the life-time of SAR presented in Figures 1 and 2): intended goals, followed processes, required inputs, used techniques and exp</context>
</contexts>
<marker>[78]</marker>
<rawString>Mendonça and Kramer. Requirements for an effective architecture recovery framework. In ISAW-2 and Viewpoints workshops, pp. 101–105, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Mendonca</author>
<author>Kramer</author>
</authors>
<title>An approach for recovering distributed system architectures.</title>
<date>2001</date>
<volume>8</volume>
<pages>311--354</pages>
<contexts>
<context position="19929" citStr="[79]" startWordPosition="2999" endWordPosition="2999">t box and arrow view of the software application. 5.3. Hybrid Processes Hybrid processes combine the previous two [112]. On the one hand, low-level knowledge is abstracted up using various techniques. On the other hand, high-level knowledge is refined. This kind of process is frequently used to stop architectural erosion by reconciling the conceptual and concrete architectures. Hybrid approaches often use hypothesis recognizers. Recognizerbased tools provide bottom-up reverse engineering strategies to support top-down exploration of architectural hypothesis. ManSART [43, 137], ART [29], X-ray [79], ARM [40] and DiscoTect [136] are examples of this approach. In ManSART, a top-down recognition engine maps a style-compliant conceptual view with a system overview which was defined using a visualization tool in a bottom-up fashion. Examples. Sartipi implemented a pattern-based SAR approach in Alborz [100, 101]. The architecture reconstruction consists of two phases. During the first bottom-up phase, the source code is parsed, presented as a graph, then divided in cohesive graph regions using data mining techniques. This model is at a higher abstraction level than the code. During the second</context>
<context position="35633" citStr="[79]" startWordPosition="5339" endWordPosition="5339">rting point of SAR [90, 91]. To drive a pattern-supported architecture recovery, they introduce a pattern specification language and the Revealer tool. Investigation-based Techniques. These techniques map high-level concepts with low-level concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns to design patterns, concerns, aspects, and features, that are orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execution and outputs archit</context>
<context position="39875" citStr="[74, 79]" startWordPosition="5980" endWordPosition="5981"> also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of th</context>
</contexts>
<marker>[79]</marker>
<rawString>Mendonça and Kramer. An approach for recovering distributed system architectures. vol. 8, pp. 311–354, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Kellens Mens</author>
<author>Pluquet</author>
<author>Wuyts</author>
</authors>
<title>Co-evolving code and design with intensional views – a case study.</title>
<date>2006</date>
<journal>Journal of Computer Languages, Systems and Structures,</journal>
<volume>32</volume>
<issue>2</issue>
<pages>156</pages>
<contexts>
<context position="13262" citStr="[134, 80]" startWordPosition="1982" endWordPosition="1983">t [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evol</context>
<context position="17345" citStr="[134, 80]" startWordPosition="2609" endWordPosition="2610">geneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engineer can specify patterns using SQL queries and Perl expressions. The former selects a set of source model entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group related source-code entities structurally in a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The t</context>
<context position="31420" citStr="[80]" startWordPosition="4729" endWordPosition="4729">s are keys for representing viewpoints. The QADSAR approach both reconstructs the architecture of a system and drives quality attribute analyses on it [110, 111]. To do this, QADSAR allows reverse engineers to formulate their interests in reconstructing the architecture by means of concrete quality attribute scenarios. This results in the definition of relevant architectural viewpoints. ARES [23, 22] and SAR [62] also take viewpoints into account. 7. SAR Techniques Techniques and the data they operate on are often correlated. For example, input information is represented respectively as facts [80] or graphs [19] to use logic or graph queries. 7 SAR approaches use different techniques that we classified according to their automation level: quasi-manual, the reverse engineer manually identifies architectural elements using a tool to assist him to understand his findings; semiautomatic, the reverse engineer manually instructs the tool how to automatically discover refinements or recover abstractions. quasi-automatic, the tool has the control and the reverse engineer steers the iterative recovery process. Of course, the boundaries between the classifications are not clear-cut. 7.1. Quasi-M</context>
<context position="34453" citStr="[134, 80]" startWordPosition="5162" endWordPosition="5163">ational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code views and relations in Intensive [134, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts [94]. Programs: Some approaches build analyses as programs. For example, the analyses made in the Moose environment are performed as object-oriented programs that manipulate models representing the various inputs [17]. Lexical and structural queries: Some approaches are directly based on the lexical and structural information in the source code. Pinzger et al. state that some hotspots clearly localize patterns in the source code and consider them as the starting point of SAR [90, </context>
<context position="38896" citStr="[134, 80]" startWordPosition="5829" endWordPosition="5830">et al. [118]. 8. SAR Outputs While most approaches focus on producing presentations of software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying pol</context>
<context position="42142" citStr="[80]" startWordPosition="6314" endWordPosition="6314">ple, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurr</context>
</contexts>
<marker>[80]</marker>
<rawString>Mens, Kellens, Pluquet, and Wuyts. Co-evolving code and design with intensional views – a case study. Journal of Computer Languages, Systems and Structures, 32(2):140– 156, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wong Muller</author>
<author>Tilley</author>
</authors>
<title>Understanding software systems using reverse engineering technology.</title>
<date>1995</date>
<booktitle>In Object-Oriented Technology for Database and Software Systems,</booktitle>
<pages>240--252</pages>
<contexts>
<context position="16659" citStr="[81, 113]" startWordPosition="2497" endWordPosition="2498">odels, they pro4 gressively raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system representations, which are then presented in a suitable interactive form to reverse engineers. Examples. Several tools support a bottom-up process characterized by the extract-abstract-present metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engineer can specify patterns using SQL queries and Perl expressions. The former selects a set of source model entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply </context>
<context position="32456" citStr="[81, 113]" startWordPosition="4873" endWordPosition="4874">he tool has the control and the reverse engineer steers the iterative recovery process. Of course, the boundaries between the classifications are not clear-cut. 7.1. Quasi-Manual Techniques SAR is a reverse engineering activity which faces scalability issues in manipulating knowledge. In response to this problem, researchers have proposed slightly assisted SAR approaches; we considered two categories. Construction-based Techniques. These techniques reconstruct the software architecture by manually abstracting low-level knowledge, thanks to interactive and expressive visualization tools — Rigi [81, 113], PBS [28], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], S</context>
<context position="33812" citStr="[81, 113]" startWordPosition="5066" endWordPosition="5067">erse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs using a specialized declarative expression language called GReQL [19]. Rigi is based on graph transformations written in Tcl [81, 113]. Relational queries: Often, relational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code v</context>
<context position="39032" citStr="[81, 113]" startWordPosition="5850" endWordPosition="5851">itional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [</context>
<context position="42383" citStr="[81, 113]" startWordPosition="6348" endWordPosition="6349">d concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural</context>
</contexts>
<marker>[81]</marker>
<rawString>Müller, Wong, and Tilley. Understanding software systems using reverse engineering technology. In Object-Oriented Technology for Database and Software Systems, pp. 240– 252. 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Notkin Murphy</author>
<author>Sullivan</author>
</authors>
<title>Software reflexion models: Bridging the gap between source and high-level models.</title>
<date>1995</date>
<booktitle>In SIGSOFT,</booktitle>
<pages>18--28</pages>
<contexts>
<context position="2556" citStr="[82]" startWordPosition="388" endWordPosition="388">e architecture; this results in architectural erosion [75, 88], drift [88], mismatch [33], or chasm [96]. Software architecture reconstruction (SAR) is the reverse engineering process that aims at reconstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in the literature to support SAR. Mendonca et al. presented a first raw classification of SAR environments based on a few typical scenarios [78]. O’Brien et al. surveyed SAR practice needs and approaches [85]. Still, there is no comprehensive state of the art and it is often difficult to compare the approaches. This article presents a first state of the art in SAR, with the desire to help understand the field and to identify the current approaches, techniques and tools. The presented taxonomy takes the perspective of a reverseengineer who</context>
<context position="12495" citStr="[82]" startWordPosition="1875" endWordPosition="1875"> share commonalities among products while getting custom products. Architectural views are useful to identify commonalities and variabilities among products in a line [109, 93, 18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically main</context>
<context position="18080" citStr="[82]" startWordPosition="2719" endWordPosition="2719">ve classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies consistencies and inconsistencies. Like that, the reverse engineer iteratively interprets and computes successive reflexion models until satisfied. Lungu et al. built both a method and a tool called Softwarenaut [71] to interactively explore hierarchical decompositions of software applications. Their method differs from other classical exploration tools: to construct an architectural view on the fly, they enhance the </context>
<context position="22782" citStr="[82]" startWordPosition="3436" endWordPosition="3436">f information are sometimes considered such as dynamic information extracted from a system as it is running or historical data held by version control system repositories. In addition a few approaches take into account architectural elements such as styles or viewpoints as input to SAR. The current trend is to feed SAR with heterogeneous information of diverse abstraction levels. 6.1. Non-Architectural Inputs Source Code Constructs. The source code is an omnipresent trustworthy source of information that most approaches consider. Some of them query directly the source code text like in RMTool [82]. However, most of them are not directly based on the source code but represent source code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the</context>
<context position="25404" citStr="[82]" startWordPosition="3836" endWordPosition="3836">ystems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software architecture [6]. Historical Information. Historical information is rarely used in SAR. Still ArchView is a recent approach that exploits source control system data and bug reports to analyze the evolution of recovered architectural views [89, 92]. To assist a reverse engineer to understand underlined dependency gaps in a reflexion model [82], Hassan et al. annotate entity dependencies with sticky notes. These sticky notes record dependency evolution and rationale with information extracted from version control systems [44]. Human Expertise. Although one cannot entirely trust human knowledge, it is very helpful when it is available. At high abstraction levels, SAR is iterative and requires human knowledge to validate results and to guide it. As Ivkovic et al. state [53], a SAR approach involves strategy and knowledge of the domain and the application itself. They propose to systematically update a knowledge base that would become </context>
<context position="36364" citStr="[82]" startWordPosition="5452" endWordPosition="5452">tern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execution and outputs architectural events when the execution satisfies 8 the state machine description. Maps. SAR approaches based on the Reflexion Model [82] use rules to map hypothesized high-level entities with source code entities. 7.3. Quasi-Automatic Techniques Pure automatic techniques failed in reconstructing software architectures, and even if current techniques tend towards an automatic process, reverse engineers must still steer them. Concept, dominance, and cluster analysis techniques are often combined. The Bunch tool [73, 74] uses clustering algorithms to automatically partition software products into cohesive clusters that are loosely interconnected [129]. Clustering algorithms, based on hill climbing and genetic algorithms, are appl</context>
<context position="42111" citStr="[82]" startWordPosition="6311" endWordPosition="6311">re of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight </context>
</contexts>
<marker>[82]</marker>
<rawString>Murphy, Notkin, and Sullivan. Software reflexion models: Bridging the gap between source and high-level models. In SIGSOFT, pp. 18–28, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Said Nora</author>
<author>Fadila</author>
</authors>
<title>A comparative classification of aspect mining approaches.</title>
<date>2006</date>
<journal>Journal of Computer Science</journal>
<volume>2</volume>
<pages>4--322</pages>
<contexts>
<context position="15540" citStr="[10, 59, 83]" startWordPosition="2336" endWordPosition="2338">space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstraction level until a high-level understanding o</context>
</contexts>
<marker>[83]</marker>
<rawString>Nora, Said, and Fadila. A comparative classification of aspect mining approaches. Journal of Computer Science 2, 4:322–325, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>O’Brien</author>
<author>Stoermer</author>
</authors>
<title>Architecture reconstruction case study.</title>
<date>2003</date>
<booktitle>CMU/SEI-2003-TN-008, CMU SEI,</booktitle>
<contexts>
<context position="13742" citStr="[57, 84]" startWordPosition="2055" endWordPosition="2056">es logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should evolve. Krikhaar et al. also introduced a two-phase approach for evolving architecture based on SAR and on change impact analyses [62, 63]. Huang et al. also consider SAR in an evolution and maintenance perspective [51]. 4.2. Related and Orthogonal Artifacts Some app</context>
<context position="16686" citStr="[57, 84]" startWordPosition="2502" endWordPosition="2503">raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system representations, which are then presented in a suitable interactive form to reverse engineers. Examples. Several tools support a bottom-up process characterized by the extract-abstract-present metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engineer can specify patterns using SQL queries and Perl expressions. The former selects a set of source model entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group re</context>
<context position="33967" citStr="[57, 84]" startWordPosition="5088" endWordPosition="5089">chniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs using a specialized declarative expression language called GReQL [19]. Rigi is based on graph transformations written in Tcl [81, 113]. Relational queries: Often, relational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code views and relations in Intensive [134, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts</context>
<context position="35877" citStr="[57, 84]" startWordPosition="5378" endWordPosition="5379">concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns to design patterns, concerns, aspects, and features, that are orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execution and outputs architectural events when the execution satisfies 8 the state machine description. Maps. SAR approaches based on the Reflexion Model [82] use rules to map hypothesized high-level entities with source code entities. 7.3. Quasi-Automatic Techniques Pur</context>
</contexts>
<marker>[84]</marker>
<rawString>O’Brien and Stoermer. Architecture reconstruction case study. CMU/SEI-2003-TN-008, CMU SEI, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Stoermer O’Brien</author>
<author>Verhoef</author>
</authors>
<title>Software architecture reconstruction: Practice needs and current approaches.</title>
<date>2002</date>
<tech>Cmu/sei-2002-tr-024, esc-tr-2002-024, CMU SEI,</tech>
<contexts>
<context position="2820" citStr="[85]" startWordPosition="429" endWordPosition="429">. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in the literature to support SAR. Mendonca et al. presented a first raw classification of SAR environments based on a few typical scenarios [78]. O’Brien et al. surveyed SAR practice needs and approaches [85]. Still, there is no comprehensive state of the art and it is often difficult to compare the approaches. This article presents a first state of the art in SAR, with the desire to help understand the field and to identify the current approaches, techniques and tools. The presented taxonomy takes the perspective of a reverseengineer who would like to reconstruct the architecture of an existing application and would like to know which tools or approach to take. The taxonomy takes into account the goals, the process, the inputs, the techniques and the outputs of SAR. Section 2 first stresses some </context>
<context position="8401" citStr="[85]" startWordPosition="1290" endWordPosition="1290">of whether dynamic information should be extracted as the system is running, and then how do the behavioral aspects appear in the architecture. To summarize this section, the major challenge of SAR is in abstracting, identifying and displaying higher-level views from lower-level and often heterogeneous information. 3. SAR Taxonomy Axes Mendonca et al. [78] classified SAR environments and distinguished five families: filtering and clustering, compliance checking, analysers generators, program understanding and architecture recognition. O’Brien et al. surveyed SAR practice needs and approaches [85]. Gallagher et al. [30] proposed a framework to assess architectural visualization tools. Gueheneuc et al. [38] proposed a comparative framework for design recovery tools. We propose a more elaborated classification based on the life-time of SAR presented in Figures 1 and 2): intended goals, followed processes, required inputs, used techniques and expected outputs. 2 Goals Processes Techniques Outputs InputsSAR Hybrid Bottom-Up Top-Down Semi-Automatic Quasi-Manual Quasi-Automatic Abstraction Investigation Construction Exploration Architecture Conformance Analysis Redocumentation Reuse Confor</context>
<context position="29721" citStr="[85]" startWordPosition="4475" endWordPosition="4475"> Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be selected or defined according to the environment and the situation [107]. O’Brien et al. notably present the View-Set Scenario pattern that helps determine which architecture views sufficiently describe the system and cover stakeholder needs [85]. Examples. The Symphony approach devised by van Deursen et al. aims at reconstructing software architecture using appropriate viewpoints [124]. Viewpoints are selected from a catalogue or defined if they don’t exist. Moreover, they evolve throughout the process. Chosen viewpoints constrain SAR to provide architectural views compliant to stakeholders’ expectations, ideally allowing an immediate use of these views. For example, Symphony authors highlight through four case studies some SAR motivations such as checking the conformance of family products to architectural rules. To do this they nee</context>
</contexts>
<marker>[85]</marker>
<rawString>O’Brien, Stoermer, and Verhoef. Software architecture reconstruction: Practice needs and current approaches. Cmu/sei-2002-tr-024, esc-tr-2002-024, CMU SEI, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pacione</author>
</authors>
<title>A Novel Software Visualisation Model to Support Object-Oriented Program Comprehension.</title>
<date>2005</date>
<tech>PhD thesis,</tech>
<contexts>
<context position="40091" citStr="[86]" startWordPosition="6015" endWordPosition="6015">lying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in Disc</context>
</contexts>
<marker>[86]</marker>
<rawString>Pacione. A Novel Software Visualisation Model to Support Object-Oriented Program Comprehension. PhD thesis, Nov. 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pashov</author>
<author>Riebisch</author>
</authors>
<title>Using feature modeling for program comprehension and software architecture recovery. In</title>
<date>2004</date>
<booktitle>ECBS,</booktitle>
<pages>406--418</pages>
<contexts>
<context position="15495" citStr="[131, 21, 87, 96, 36, 106]" startWordPosition="2325" endWordPosition="2330">ssiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstrac</context>
</contexts>
<marker>[87]</marker>
<rawString>Pashov and Riebisch. Using feature modeling for program comprehension and software architecture recovery. In ECBS, pp. 406–418, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Perry</author>
<author>Wolf</author>
</authors>
<title>Foundations for the study of software architecture.</title>
<date>1992</date>
<journal>ACM SIGSOFT Software Engineering Notes,</journal>
<volume>17</volume>
<issue>4</issue>
<contexts>
<context position="2014" citStr="[75, 88]" startWordPosition="305" endWordPosition="306">x aspects of software development: understanding, reuse, construction, evolution, analysis and management. Software architecture is thus crucial for software development. The first problem is that architectures are not explicitly represented in the code as classes and packages are. The second problem is that successful software applications are doomed to continually evolve and grow [67]; and as a software application evolves and grows, so does its architecture. The conceptual architecture often becomes inaccurate with respect to the concrete architecture; this results in architectural erosion [75, 88], drift [88], mismatch [33], or chasm [96]. Software architecture reconstruction (SAR) is the reverse engineering process that aims at reconstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in </context>
</contexts>
<marker>[88]</marker>
<rawString>Perry and Wolf. Foundations for the study of software architecture. ACM SIGSOFT Software Engineering Notes, 17(4):40–52, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pinzger</author>
</authors>
<title>ArchView - Analyzing Evolutionary Aspects of Complex Software Systems.</title>
<date>2005</date>
<tech>PhD thesis,</tech>
<institution>Univ.</institution>
<location>Vienna,</location>
<contexts>
<context position="13378" citStr="[89, 92]" startWordPosition="2001" endWordPosition="2002">that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these ap</context>
<context position="17659" citStr="[89, 92]" startWordPosition="2654" endWordPosition="2655">entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group related source-code entities structurally in a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies </context>
<context position="23195" citStr="[92, 89]" startWordPosition="3497" endWordPosition="3498">uts Source Code Constructs. The source code is an omnipresent trustworthy source of information that most approaches consider. Some of them query directly the source code text like in RMTool [82]. However, most of them are not directly based on the source code but represent source code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others </context>
<context position="25307" citStr="[89, 92]" startWordPosition="3819" endWordPosition="3820">es, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software architecture [6]. Historical Information. Historical information is rarely used in SAR. Still ArchView is a recent approach that exploits source control system data and bug reports to analyze the evolution of recovered architectural views [89, 92]. To assist a reverse engineer to understand underlined dependency gaps in a reflexion model [82], Hassan et al. annotate entity dependencies with sticky notes. These sticky notes record dependency evolution and rationale with information extracted from version control systems [44]. Human Expertise. Although one cannot entirely trust human knowledge, it is very helpful when it is available. At high abstraction levels, SAR is iterative and requires human knowledge to validate results and to guide it. As Ivkovic et al. state [53], a SAR approach involves strategy and knowledge of the domain and </context>
<context position="33621" citStr="[89, 92]" startWordPosition="5039" endWordPosition="5040">ew1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs using a specialized declarative expression language called GReQL [19]. Rigi is based on graph transformations written in Tcl [81, 113]. Relational queries: Often, relational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48</context>
<context position="42515" citStr="[89, 92]" startWordPosition="6369" endWordPosition="6370">, the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we surveyed research works in the field of software architecture reconstruction (SAR). To st</context>
</contexts>
<marker>[89]</marker>
<rawString>Pinzger. ArchView - Analyzing Evolutionary Aspects of Complex Software Systems. PhD thesis, Univ. Vienna, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fischer Pinzger</author>
<author>Gall</author>
<author>Jazayeri</author>
</authors>
<title>Revealer: A lexical pattern matcher for architecture recovery. In</title>
<date>2002</date>
<booktitle>WCRE,</booktitle>
<pages>170--178</pages>
<contexts>
<context position="17678" citStr="[90, 91]" startWordPosition="2657" endWordPosition="2658">tter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group related source-code entities structurally in a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies consistencies and i</context>
<context position="23438" citStr="[90, 91]" startWordPosition="3535" endWordPosition="3536">n the source code but represent source code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may in</context>
<context position="35056" citStr="[90, 91]" startWordPosition="5258" endWordPosition="5259">, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts [94]. Programs: Some approaches build analyses as programs. For example, the analyses made in the Moose environment are performed as object-oriented programs that manipulate models representing the various inputs [17]. Lexical and structural queries: Some approaches are directly based on the lexical and structural information in the source code. Pinzger et al. state that some hotspots clearly localize patterns in the source code and consider them as the starting point of SAR [90, 91]. To drive a pattern-supported architecture recovery, they introduce a pattern specification language and the Revealer tool. Investigation-based Techniques. These techniques map high-level concepts with low-level concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns to design patterns, concerns, aspects, and features, that are orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based</context>
<context position="42938" citStr="[90, 91]" startWordPosition="6426" endWordPosition="6427">t cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we surveyed research works in the field of software architecture reconstruction (SAR). To structure the paper, we followed the general process of SAR: what are the stakeholders’ goals; how does the general reconstruction proceed; what are the available sources of information; based on this, which techniques can we apply, and finally what kind of knowledge does the process provide. As usual it is hard to classify research works in a multidisciplinary domain, so in this paper we focused on the approaches most re</context>
</contexts>
<marker>[90]</marker>
<rawString>Pinzger, Fischer, Gall, and Jazayeri. Revealer: A lexical pattern matcher for architecture recovery. In WCRE, pp. 170–178, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Pinzger</author>
<author>Gall</author>
</authors>
<title>Pattern-supported architecture recovery.</title>
<date>2002</date>
<booktitle>In IWPC,</booktitle>
<pages>53--61</pages>
<contexts>
<context position="17678" citStr="[90, 91]" startWordPosition="2657" endWordPosition="2658">tter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group related source-code entities structurally in a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies consistencies and i</context>
<context position="23438" citStr="[90, 91]" startWordPosition="3535" endWordPosition="3536">n the source code but represent source code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may in</context>
<context position="27077" citStr="[91]" startWordPosition="4075" endWordPosition="4075">s (Section 6.2), or investigating orthogonal artifacts (Section 4.2). 6.2. Architectural Inputs Architectural styles and viewpoints are the paramount of software architecture, therefore we analyzed whether SAR consider them. Styles. Architectural styles are popular since like design patterns, they represent recurrent architectural situations [60]. They are valuable, expressive, and accepted abstractions for SAR and more generally for software understanding. Recognizing them is however a challenge because they basically span several architectural elements and can be implemented in various ways [91]. The question that turns up is whether SAR helps reverse engineers specify and extract architectural styles. Examples. Ding et al. proposed to use architectural styles in Focus to infer a conceptual architecture that will be mapped to a concrete architecture extracted from the source code [16, 76]. Closely related to this work, Medvidovic et al. introduced an approach to stop architectural erosion. In a topdown process, requirements serve as high-level knowledge to discover the conceptual architecture [75]. In a bottom-up process, system implementation serves as low level knowledge to recover</context>
<context position="35056" citStr="[90, 91]" startWordPosition="5258" endWordPosition="5259">, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts [94]. Programs: Some approaches build analyses as programs. For example, the analyses made in the Moose environment are performed as object-oriented programs that manipulate models representing the various inputs [17]. Lexical and structural queries: Some approaches are directly based on the lexical and structural information in the source code. Pinzger et al. state that some hotspots clearly localize patterns in the source code and consider them as the starting point of SAR [90, 91]. To drive a pattern-supported architecture recovery, they introduce a pattern specification language and the Revealer tool. Investigation-based Techniques. These techniques map high-level concepts with low-level concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns to design patterns, concerns, aspects, and features, that are orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based</context>
<context position="39137" citStr="[28, 57, 18, 61, 91, 100, 96]" startWordPosition="5863" endWordPosition="5869">e clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose </context>
<context position="42938" citStr="[90, 91]" startWordPosition="6426" endWordPosition="6427">t cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we surveyed research works in the field of software architecture reconstruction (SAR). To structure the paper, we followed the general process of SAR: what are the stakeholders’ goals; how does the general reconstruction proceed; what are the available sources of information; based on this, which techniques can we apply, and finally what kind of knowledge does the process provide. As usual it is hard to classify research works in a multidisciplinary domain, so in this paper we focused on the approaches most re</context>
</contexts>
<marker>[91]</marker>
<rawString>Pinzger and Gall. Pattern-supported architecture recovery. In IWPC, pp. 53–61, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gall Pinzger</author>
<author>Fischer</author>
<author>Lanza</author>
</authors>
<title>Visualizing multiple evolution metrics.</title>
<date>2005</date>
<booktitle>In SoftVis</booktitle>
<pages>67--75</pages>
<contexts>
<context position="13378" citStr="[89, 92]" startWordPosition="2001" endWordPosition="2002">that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these ap</context>
<context position="17659" citStr="[89, 92]" startWordPosition="2654" endWordPosition="2655">entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group related source-code entities structurally in a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies </context>
<context position="23195" citStr="[92, 89]" startWordPosition="3497" endWordPosition="3498">uts Source Code Constructs. The source code is an omnipresent trustworthy source of information that most approaches consider. Some of them query directly the source code text like in RMTool [82]. However, most of them are not directly based on the source code but represent source code abstractions using different metamodels. These metamodels cope with the paradigm of the analyzed software. For instance, the language independent metamodel Famix is used for reverse engineering object-oriented applications [15]; its concepts include classes, methods, calls or accesses. Famix is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others </context>
<context position="25307" citStr="[89, 92]" startWordPosition="3819" endWordPosition="3820">es, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software architecture [6]. Historical Information. Historical information is rarely used in SAR. Still ArchView is a recent approach that exploits source control system data and bug reports to analyze the evolution of recovered architectural views [89, 92]. To assist a reverse engineer to understand underlined dependency gaps in a reflexion model [82], Hassan et al. annotate entity dependencies with sticky notes. These sticky notes record dependency evolution and rationale with information extracted from version control systems [44]. Human Expertise. Although one cannot entirely trust human knowledge, it is very helpful when it is available. At high abstraction levels, SAR is iterative and requires human knowledge to validate results and to guide it. As Ivkovic et al. state [53], a SAR approach involves strategy and knowledge of the domain and </context>
<context position="33621" citStr="[89, 92]" startWordPosition="5039" endWordPosition="5040">ew1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs using a specialized declarative expression language called GReQL [19]. Rigi is based on graph transformations written in Tcl [81, 113]. Relational queries: Often, relational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48</context>
<context position="39452" citStr="[92, 80, 71]" startWordPosition="5912" endWordPosition="5914"> of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy </context>
<context position="42515" citStr="[89, 92]" startWordPosition="6369" endWordPosition="6370">, the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we surveyed research works in the field of software architecture reconstruction (SAR). To st</context>
</contexts>
<marker>[92]</marker>
<rawString>Pinzger, Gall, Fischer, and Lanza. Visualizing multiple evolution metrics. In SoftVis 2005, pp. 67–75, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Gall Pinzger</author>
<author>Knodel Girard</author>
<author>Pasman Riva</author>
<author>Broerse</author>
<author>Wijnstra</author>
</authors>
<title>Architecture recovery for product families.</title>
<date>2004</date>
<booktitle>In PFE-5, LNCS 3014,</booktitle>
<pages>332--351</pages>
<contexts>
<context position="12075" citStr="[109, 93, 18, 23]" startWordPosition="1805" endWordPosition="1808"> al. illustrates this goal [28]. Svetinovic et al. state that not only the recovered architecture is important, but also its rationale, i.e. why it is as it is [114]. They focus on the architecture rationale forces to recover the decisions made, their alternatives, and why each one was or was not chosen. Reuse investigation and product line migration: Systematic reuse has not yet been achieved. Software product lines allow one to share commonalities among products while getting custom products. Architectural views are useful to identify commonalities and variabilities among products in a line [109, 93, 18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76</context>
</contexts>
<marker>[93]</marker>
<rawString>Pinzger, Gall, Girard, Knodel, Riva, Pasman, Broerse, and Wijnstra. Architecture recovery for product families. In PFE-5, LNCS 3014, pp. 332–351, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richner</author>
<author>Ducasse</author>
</authors>
<title>Recovering high-level views of object-oriented applications from static and dynamic information.</title>
<date>1999</date>
<booktitle>In ICSM,</booktitle>
<pages>13--22</pages>
<contexts>
<context position="23857" citStr="[54, 94, 97, 126, 69, 51, 89]" startWordPosition="3600" endWordPosition="3606">6]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 1</context>
<context position="34572" citStr="[94]" startWordPosition="5182" endWordPosition="5182"> Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code views and relations in Intensive [134, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts [94]. Programs: Some approaches build analyses as programs. For example, the analyses made in the Moose environment are performed as object-oriented programs that manipulate models representing the various inputs [17]. Lexical and structural queries: Some approaches are directly based on the lexical and structural information in the source code. Pinzger et al. state that some hotspots clearly localize patterns in the source code and consider them as the starting point of SAR [90, 91]. To drive a pattern-supported architecture recovery, they introduce a pattern specification language and the Reveal</context>
</contexts>
<marker>[94]</marker>
<rawString>Richner and Ducasse. Recovering high-level views of object-oriented applications from static and dynamic information. In ICSM, pp. 13–22, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Richner</author>
<author>Ducasse</author>
</authors>
<title>Using dynamic information for the iterative recovery of collaborations and roles.</title>
<date>2002</date>
<booktitle>In ICSM,</booktitle>
<contexts>
<context position="15833" citStr="[95]" startWordPosition="2381" endWordPosition="2381">1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system r</context>
<context position="24460" citStr="[95, 133]" startWordPosition="3695" endWordPosition="3696">1, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software </context>
</contexts>
<marker>[95]</marker>
<rawString>Richner and Ducasse. Using dynamic information for the iterative recovery of collaborations and roles. In ICSM, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Riva</author>
</authors>
<title>View-based Software Architecture Reconstruction.</title>
<date>2004</date>
<tech>PhD thesis,</tech>
<institution>Univ.</institution>
<location>Vienna,</location>
<contexts>
<context position="2056" citStr="[96]" startWordPosition="313" endWordPosition="313">ng, reuse, construction, evolution, analysis and management. Software architecture is thus crucial for software development. The first problem is that architectures are not explicitly represented in the code as classes and packages are. The second problem is that successful software applications are doomed to continually evolve and grow [67]; and as a software application evolves and grows, so does its architecture. The conceptual architecture often becomes inaccurate with respect to the concrete architecture; this results in architectural erosion [75, 88], drift [88], mismatch [33], or chasm [96]. Software architecture reconstruction (SAR) is the reverse engineering process that aims at reconstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in the literature to support SAR. Mendonca e</context>
<context position="5027" citStr="[120, 96]" startWordPosition="793" endWordPosition="794">chitecture from several viewpoints since the different system stakeholders have different expectations or concerns about the system [64, 52]: View: “a representation of a whole system from the perspective of a related set of concerns.” Viewpoint: “a specification of the conventions for constructing and using a view. A pattern or a template from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis.” Conceptual architecture. It refers to the architecture that exists in human minds or in the software documentation [120, 96]. In the literature, this kind of architecture is also qualified as idealized [43], intended [132, 96], asdesigned [57, 120] or logical [76]. Concrete architecture. It refers to the architecture that can be derived from source code [120, 96]. It is also known as the as-implemented [57, 96], as-built [120, 43], realized [132] or physical [76] architecture. Software architecture reconstruction (SAR). SAR is the reverse engineering approach that aims at reconstructing viable architectural views of a software application. The literature uses several other terms to refer to SAR: reverse architectin</context>
<context position="12643" citStr="[96]" startWordPosition="1898" endWordPosition="1898">products in a line [109, 93, 18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through </context>
<context position="15495" citStr="[131, 21, 87, 96, 36, 106]" startWordPosition="2325" endWordPosition="2330">ssiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstrac</context>
<context position="22086" citStr="[96]" startWordPosition="3327" endWordPosition="3327">d entities. To assess the creation of product lines, Stoermer et al. introduce the MAP method [109]. MAP combines (1) a bottom-up process, to recover the concrete architectures of existing products; (2) a top-down process, to map architectural styles onto recovered architectural views; (3) an approach to analyze commonalities and variabilities among recovered architectures. They stress the ability of architectural styles to act as the structural glue of the components, and to highlight architecture strengths and weaknesses. Other hybrid processes for instance include Focus [16, 76] and Nimeta [96]. 6. SAR Inputs SAR essentially works on source code representations. However, other kinds of information are sometimes considered such as dynamic information extracted from a system as it is running or historical data held by version control system repositories. In addition a few approaches take into account architectural elements such as styles or viewpoints as input to SAR. The current trend is to feed SAR with heterogeneous information of diverse abstraction levels. 6.1. Non-Architectural Inputs Source Code Constructs. The source code is an omnipresent trustworthy source of information tha</context>
<context position="30537" citStr="[96]" startWordPosition="4592" endWordPosition="4592">xist. Moreover, they evolve throughout the process. Chosen viewpoints constrain SAR to provide architectural views compliant to stakeholders’ expectations, ideally allowing an immediate use of these views. For example, Symphony authors highlight through four case studies some SAR motivations such as checking the conformance of family products to architectural rules. To do this they need to provide to reverse engineers architectural views according the viewpoints these reverse engineers typically use during design. Riva proposed a view-based SAR approach called Nimeta based on the Symphony one [96]. Favre outlines a generic SAR metamodel-driven approach called CacOphoNy [26]. Like Symphony, CacOphoNy recognizes the need to identify which viewpoints are relevant for stakeholder concerns and have to be considered in SAR. Contrary to Symphony, CacOphoNy states that metamodels are keys for representing viewpoints. The QADSAR approach both reconstructs the architecture of a system and drives quality attribute analyses on it [110, 111]. To do this, QADSAR allows reverse engineers to formulate their interests in reconstructing the architecture by means of concrete quality attribute scenarios. </context>
<context position="39137" citStr="[28, 57, 18, 61, 91, 100, 96]" startWordPosition="5863" endWordPosition="5869">e clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose </context>
<context position="41907" citStr="[96]" startWordPosition="6282" endWordPosition="6282">al conformance). Horizontal Conformance is checked between two reconstructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview </context>
</contexts>
<marker>[96]</marker>
<rawString>Riva. View-based Software Architecture Reconstruction. PhD thesis, Univ. Vienna, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Riva</author>
<author>Rodriguez</author>
</authors>
<title>Combining static and dynamic views for architecture reconstruction.</title>
<date>2002</date>
<journal>CSMR,</journal>
<volume>00</volume>
<contexts>
<context position="23857" citStr="[54, 94, 97, 126, 69, 51, 89]" startWordPosition="3600" endWordPosition="3606">6]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 1</context>
<context position="39682" citStr="[97]" startWordPosition="5949" endWordPosition="5949">ions of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. De</context>
</contexts>
<marker>[97]</marker>
<rawString>Riva and Rodriguez. Combining static and dynamic views for architecture reconstruction. CSMR, 00, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Robillard</author>
<author>Murphy</author>
</authors>
<title>Concern graphs: finding and describing concerns using structural program dependencies.</title>
<date>2002</date>
<booktitle>In ICSE,</booktitle>
<pages>406--416</pages>
<contexts>
<context position="15382" citStr="[98, 12]" startWordPosition="2310" endWordPosition="2311">s necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start </context>
</contexts>
<marker>[98]</marker>
<rawString>Robillard and Murphy. Concern graphs: finding and describing concerns using structural program dependencies. In ICSE, pp. 406–416, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Salah</author>
</authors>
<title>Mancoridis. A hierarchy of dynamic software views: from object-interactions to feature-interacions. In</title>
<date>2004</date>
<booktitle>ICSM,</booktitle>
<contexts>
<context position="24372" citStr="[21, 99, 36]" startWordPosition="3682" endWordPosition="3684">n only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the devel</context>
</contexts>
<marker>[99]</marker>
<rawString>Salah and Mancoridis. A hierarchy of dynamic software views: from object-interactions to feature-interacions. In ICSM, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sartipi</author>
</authors>
<title>Software Architecture Recovery based on Pattern Matching.</title>
<date>2003</date>
<tech>PhD thesis,</tech>
<institution>Univ.</institution>
<location>Waterloo, CA,</location>
<contexts>
<context position="20243" citStr="[100, 101]" startWordPosition="3047" endWordPosition="3048">ctural erosion by reconciling the conceptual and concrete architectures. Hybrid approaches often use hypothesis recognizers. Recognizerbased tools provide bottom-up reverse engineering strategies to support top-down exploration of architectural hypothesis. ManSART [43, 137], ART [29], X-ray [79], ARM [40] and DiscoTect [136] are examples of this approach. In ManSART, a top-down recognition engine maps a style-compliant conceptual view with a system overview which was defined using a visualization tool in a bottom-up fashion. Examples. Sartipi implemented a pattern-based SAR approach in Alborz [100, 101]. The architecture reconstruction consists of two phases. During the first bottom-up phase, the source code is parsed, presented as a graph, then divided in cohesive graph regions using data mining techniques. This model is at a higher abstraction level than the code. During the second top-down phase, the reverse engineer iteratively specifies his hypothesized views of the architecture in terms of patterns. These patterns are approximately mapped with previous graph regions using graph matching and clustering techniques. Finally, the reverse engineer decides to proceed or not to a new iteratio</context>
<context position="36055" citStr="[100, 101]" startWordPosition="5405" endWordPosition="5406">re orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execution and outputs architectural events when the execution satisfies 8 the state machine description. Maps. SAR approaches based on the Reflexion Model [82] use rules to map hypothesized high-level entities with source code entities. 7.3. Quasi-Automatic Techniques Pure automatic techniques failed in reconstructing software architectures, and even if current techniques tend towards an automatic process, reverse engineers must still steer them.</context>
<context position="39137" citStr="[28, 57, 18, 61, 91, 100, 96]" startWordPosition="5863" endWordPosition="5869">e clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose </context>
<context position="42426" citStr="[100, 101]" startWordPosition="6356" endWordPosition="6357">chitecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we </context>
</contexts>
<marker>[100]</marker>
<rawString>Sartipi. Software Architecture Recovery based on Pattern Matching. PhD thesis, Univ. Waterloo, CA, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Yee Sartipi</author>
<author>Safyallah</author>
</authors>
<title>Alborz: An interactive toolkit to extract static and dynamic views of a software system.</title>
<date>2006</date>
<booktitle>In ICPC,</booktitle>
<note>To appear.</note>
<contexts>
<context position="20243" citStr="[100, 101]" startWordPosition="3047" endWordPosition="3048">ctural erosion by reconciling the conceptual and concrete architectures. Hybrid approaches often use hypothesis recognizers. Recognizerbased tools provide bottom-up reverse engineering strategies to support top-down exploration of architectural hypothesis. ManSART [43, 137], ART [29], X-ray [79], ARM [40] and DiscoTect [136] are examples of this approach. In ManSART, a top-down recognition engine maps a style-compliant conceptual view with a system overview which was defined using a visualization tool in a bottom-up fashion. Examples. Sartipi implemented a pattern-based SAR approach in Alborz [100, 101]. The architecture reconstruction consists of two phases. During the first bottom-up phase, the source code is parsed, presented as a graph, then divided in cohesive graph regions using data mining techniques. This model is at a higher abstraction level than the code. During the second top-down phase, the reverse engineer iteratively specifies his hypothesized views of the architecture in terms of patterns. These patterns are approximately mapped with previous graph regions using graph matching and clustering techniques. Finally, the reverse engineer decides to proceed or not to a new iteratio</context>
<context position="36055" citStr="[100, 101]" startWordPosition="5405" endWordPosition="5406">re orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execution and outputs architectural events when the execution satisfies 8 the state machine description. Maps. SAR approaches based on the Reflexion Model [82] use rules to map hypothesized high-level entities with source code entities. 7.3. Quasi-Automatic Techniques Pure automatic techniques failed in reconstructing software architectures, and even if current techniques tend towards an automatic process, reverse engineers must still steer them.</context>
<context position="42426" citStr="[100, 101]" startWordPosition="6356" endWordPosition="6357">chitecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we </context>
</contexts>
<marker>[101]</marker>
<rawString>Sartipi, Yee, and Safyallah. Alborz: An interactive toolkit to extract static and dynamic views of a software system. In ICPC, 2006. To appear.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shaw</author>
<author>Garlan</author>
</authors>
<title>Software Architecture: Perspectives on an Emerging Discipline.</title>
<date>1996</date>
<publisher>Prentice-Hall,</publisher>
<contexts>
<context position="4084" citStr="[102, 35]" startWordPosition="641" endWordPosition="642"> in the field. Section 3 describes the criteria that we adopted in our taxonomy; sections 4 to 8 then cover each of these criteria, and we conclude. 2. SAR Challenges Before going in more depth into the challenges of SAR, we feel the need to clarify the vocabulary. 2.1. Vocabulary Software architecture. IEEE defines software architecture as “the fundamental organization of a system embodied in its components, their relationships to each other, and to the environment, and the principles guiding its design and 1 evolution”[52]; this is closely related to the definition of Shaw, Perry and Garlan [102, 35]. Architectural style. A software architecture often conforms to an architectural style that is a class of architectures, or a pattern of structural organization: “a vocabulary of components and connector types, and a set of constraints on how they can be combined” [102]. Architectural views and viewpoints. We can view a software architecture from several viewpoints since the different system stakeholders have different expectations or concerns about the system [64, 52]: View: “a representation of a whole system from the perspective of a related set of concerns.” Viewpoint: “a specification of</context>
</contexts>
<marker>[102]</marker>
<rawString>Shaw and Garlan. Software Architecture: Perspectives on an Emerging Discipline. Prentice-Hall, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Shneiderman</author>
</authors>
<title>Software Psychology: Human Factors in Computer and Information Systems.</title>
<date>1980</date>
<publisher>Winthrop Publishers,</publisher>
<contexts>
<context position="17938" citStr="[103, 112]" startWordPosition="2696" endWordPosition="2697"> a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies consistencies and inconsistencies. Like that, the reverse engineer iteratively interprets and computes successive reflexion models until satisfied. Lungu et al. built both a method and a tool called Softwarenaut [71] to interactively explore hierarchical decompositions of softwa</context>
</contexts>
<marker>[103]</marker>
<rawString>Shneiderman. Software Psychology: Human Factors in Computer and Information Systems. Winthrop Publishers, 1980.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Siff</author>
</authors>
<title>Reps. Identifying Modules via Concept Analysis.</title>
<date>1997</date>
<booktitle>In ICSM,</booktitle>
<pages>170--179</pages>
<contexts>
<context position="38194" citStr="[104]" startWordPosition="5720" endWordPosition="5720">ke’s thesis, Trifu unifies cluster and dominance analysis techniques for the recovery of architectural components in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance analysis is not sufficient to recover the complete architecture: it requires other techniques such as concept analysis to take component interactions into account. Concept analysis techniques were explored by Siff et al. [104], van Deursen et al. [125], Arevalo [3, 2] or Eisenbarth et al. [21] and surveyed by Tilley et al. [118]. 8. SAR Outputs While most approaches focus on producing presentations of software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evo</context>
</contexts>
<marker>[104]</marker>
<rawString>Siff and Reps. Identifying Modules via Concept Analysis. In ICSM, pp. 170–179, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Clarke Sim</author>
<author>Holt</author>
<author>Cox</author>
</authors>
<title>Browsing and searching software architectures.</title>
<date>1999</date>
<volume>00</volume>
<pages>381</pages>
<contexts>
<context position="33053" citStr="[105]" startWordPosition="4960" endWordPosition="4960">81, 113], PBS [28], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], SoftArch [37], SoFi [9], LePUS [20] and ArchVis [45]. 7.2. Semi-Automatic Techniques Here the techniques automate repetitive aspects of SAR. The reverse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queri</context>
</contexts>
<marker>[105]</marker>
<rawString>Sim, Clarke, Holt, and Cox. Browsing and searching software architectures. vol. 00, p. 381, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Smith</author>
<author>Munro</author>
</authors>
<title>Identifying structural features of java programs by analysing the interaction of classes at runtime.</title>
<date>2005</date>
<booktitle>In VISSOFT. IEEE CS,</booktitle>
<contexts>
<context position="15495" citStr="[131, 21, 87, 96, 36, 106]" startWordPosition="2325" endWordPosition="2330">ssiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstrac</context>
</contexts>
<marker>[106]</marker>
<rawString>Smith and Munro. Identifying structural features of java programs by analysing the interaction of classes at runtime. In VISSOFT. IEEE CS, Sept. 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hoikka Smolander</author>
<author>Kataikko Isokallio</author>
<author>Mkel</author>
<author>Klviinen</author>
</authors>
<title>Required and optional viewpoints what is included in software architecture?</title>
<date>2001</date>
<tech>Tech. report,</tech>
<institution>Univ.</institution>
<location>Lappeenranta,</location>
<contexts>
<context position="28999" citStr="[52, 107]" startWordPosition="4359" endWordPosition="4360">the traces and uses a state engine that incrementally recognizes interleaved execution patterns. In this way, DiscoTect reconstruct stylecompliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be selected or defined according to the environment and the situation [107]. O’Brien et al. notably present the View-Set Scenar</context>
</contexts>
<marker>[107]</marker>
<rawString>Smolander, Hoikka, Isokallio, Kataikko, Mkel, and Klviinen. Required and optional viewpoints what is included in software architecture? Tech. report, Univ. Lappeenranta, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Nord Soni</author>
<author>Hofmeister</author>
</authors>
<title>Software architecture in industrial applications.</title>
<date>1995</date>
<booktitle>In ICSE,</booktitle>
<pages>196--207</pages>
<contexts>
<context position="29139" citStr="[47, 108]" startWordPosition="4384" endWordPosition="4385">pliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be selected or defined according to the environment and the situation [107]. O’Brien et al. notably present the View-Set Scenario pattern that helps determine which architecture views sufficiently describe the system and cover stakeholder needs [85]. Examples. The Sy</context>
</contexts>
<marker>[108]</marker>
<rawString>Soni, Nord, and Hofmeister. Software architecture in industrial applications. In ICSE, pp. 196–207, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Map</author>
</authors>
<title>Mining architectures for product line evaluations.</title>
<date>2001</date>
<booktitle>In WICSA,</booktitle>
<volume>00</volume>
<pages>35</pages>
<contexts>
<context position="2505" citStr="[109]" startWordPosition="379" endWordPosition="379">often becomes inaccurate with respect to the concrete architecture; this results in architectural erosion [75, 88], drift [88], mismatch [33], or chasm [96]. Software architecture reconstruction (SAR) is the reverse engineering process that aims at reconstructing viable architectural views of a software application. Krikhaar specified five SAR maturity levels [62]. While SAR is rarely an end in itself, it improves software development by providing high-level views of the investigated software application [43]. For example, these views help identify product line commonalities and variabilities [109] or check their conformance to the source code [82]. Several approaches and techniques have been proposed in the literature to support SAR. Mendonca et al. presented a first raw classification of SAR environments based on a few typical scenarios [78]. O’Brien et al. surveyed SAR practice needs and approaches [85]. Still, there is no comprehensive state of the art and it is often difficult to compare the approaches. This article presents a first state of the art in SAR, with the desire to help understand the field and to identify the current approaches, techniques and tools. The presented taxo</context>
<context position="12075" citStr="[109, 93, 18, 23]" startWordPosition="1805" endWordPosition="1808"> al. illustrates this goal [28]. Svetinovic et al. state that not only the recovered architecture is important, but also its rationale, i.e. why it is as it is [114]. They focus on the architecture rationale forces to recover the decisions made, their alternatives, and why each one was or was not chosen. Reuse investigation and product line migration: Systematic reuse has not yet been achieved. Software product lines allow one to share commonalities among products while getting custom products. Architectural views are useful to identify commonalities and variabilities among products in a line [109, 93, 18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76</context>
<context position="21581" citStr="[109]" startWordPosition="3252" endWordPosition="3252">n of the Reflexion Model [11]. They enhance it with automated clustering to facilitate the mapping phase. As in the Reflexion Model, the reverse engineer defines his hypothesized view of the architecture in a top-down process. However, instead of manually mapping hypothetic entities with concrete ones, the new method introduces clustering analysis to partially automate this step. The clustering algorithm groups currently 5 unmapped concrete entities with concrete entities already mapped to hypothesized entities. To assess the creation of product lines, Stoermer et al. introduce the MAP method [109]. MAP combines (1) a bottom-up process, to recover the concrete architectures of existing products; (2) a top-down process, to map architectural styles onto recovered architectural views; (3) an approach to analyze commonalities and variabilities among recovered architectures. They stress the ability of architectural styles to act as the structural glue of the components, and to highlight architecture strengths and weaknesses. Other hybrid processes for instance include Focus [16, 76] and Nimeta [96]. 6. SAR Inputs SAR essentially works on source code representations. However, other kinds of i</context>
<context position="28728" citStr="[109]" startWordPosition="4316" endWordPosition="4316">m, effective compositions of architectural elements, and system qualities that will likely result from the style’s use. Finally, DiscoTect considers architectural styles too [136]. It generates program traces by running the instrumented application. Then, it filters the traces and uses a state engine that incrementally recognizes interleaved execution patterns. In this way, DiscoTect reconstruct stylecompliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only accord</context>
<context position="41674" citStr="[109]" startWordPosition="6246" endWordPosition="6246"> Favre proposed to precisely define viewpoints using metamodels [26]. 9 8.2. Conformance We consider architecture conformance between similar abstraction levels (horizontal conformance) and between different abstraction levels (vertical conformance). Horizontal Conformance is checked between two reconstructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iterativel</context>
</contexts>
<marker>[109]</marker>
<rawString>Stoermer and O’Brien. Map - Mining architectures for product line evaluations. In WICSA, vol. 00, p. 35, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>O’Brien Stoermer</author>
<author>Verhoef</author>
</authors>
<title>Moving towards quality attribute driven software architecture reconstruction.</title>
<date>2003</date>
<volume>0</volume>
<pages>46</pages>
<contexts>
<context position="13476" citStr="[110, 111]" startWordPosition="2016" endWordPosition="2017">itectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should e</context>
<context position="30977" citStr="[110, 111]" startWordPosition="4658" endWordPosition="4659">l views according the viewpoints these reverse engineers typically use during design. Riva proposed a view-based SAR approach called Nimeta based on the Symphony one [96]. Favre outlines a generic SAR metamodel-driven approach called CacOphoNy [26]. Like Symphony, CacOphoNy recognizes the need to identify which viewpoints are relevant for stakeholder concerns and have to be considered in SAR. Contrary to Symphony, CacOphoNy states that metamodels are keys for representing viewpoints. The QADSAR approach both reconstructs the architecture of a system and drives quality attribute analyses on it [110, 111]. To do this, QADSAR allows reverse engineers to formulate their interests in reconstructing the architecture by means of concrete quality attribute scenarios. This results in the definition of relevant architectural viewpoints. ARES [23, 22] and SAR [62] also take viewpoints into account. 7. SAR Techniques Techniques and the data they operate on are often correlated. For example, input information is represented respectively as facts [80] or graphs [19] to use logic or graph queries. 7 SAR approaches use different techniques that we classified according to their automation level: quasi-manual</context>
<context position="42662" citStr="[110, 111]" startWordPosition="6391" endWordPosition="6392">orms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we surveyed research works in the field of software architecture reconstruction (SAR). To structure the paper, we followed the general process of SAR: what are the stakeholders’ goals; how does the general reconstruction proceed; what are </context>
</contexts>
<marker>[110]</marker>
<rawString>Stoermer, O’Brien, and Verhoef. Moving towards quality attribute driven software architecture reconstruction. vol. 0, p. 46, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Rowe Stoermer</author>
<author>O’Brien</author>
<author>Verhoef</author>
</authors>
<title>Model-centric software architecture reconstruction.</title>
<date>2006</date>
<volume>36</volume>
<pages>333--363</pages>
<contexts>
<context position="13476" citStr="[110, 111]" startWordPosition="2016" endWordPosition="2017">itectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support architectural analysis methods like SAAM [56] or ATAM [58] thanks to exportation facilities. Evolution and maintenance: SAR is also a first step towards software evolution and maintenance. Focus is one of these approaches [16, 76]. Its strength is that the SAR scope is reduced to the system part which should e</context>
<context position="30977" citStr="[110, 111]" startWordPosition="4658" endWordPosition="4659">l views according the viewpoints these reverse engineers typically use during design. Riva proposed a view-based SAR approach called Nimeta based on the Symphony one [96]. Favre outlines a generic SAR metamodel-driven approach called CacOphoNy [26]. Like Symphony, CacOphoNy recognizes the need to identify which viewpoints are relevant for stakeholder concerns and have to be considered in SAR. Contrary to Symphony, CacOphoNy states that metamodels are keys for representing viewpoints. The QADSAR approach both reconstructs the architecture of a system and drives quality attribute analyses on it [110, 111]. To do this, QADSAR allows reverse engineers to formulate their interests in reconstructing the architecture by means of concrete quality attribute scenarios. This results in the definition of relevant architectural viewpoints. ARES [23, 22] and SAR [62] also take viewpoints into account. 7. SAR Techniques Techniques and the data they operate on are often correlated. For example, input information is represented respectively as facts [80] or graphs [19] to use logic or graph queries. 7 SAR approaches use different techniques that we classified according to their automation level: quasi-manual</context>
<context position="42662" citStr="[110, 111]" startWordPosition="6391" endWordPosition="6392">orms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural patterns. 9. Conclusions In this paper we surveyed research works in the field of software architecture reconstruction (SAR). To structure the paper, we followed the general process of SAR: what are the stakeholders’ goals; how does the general reconstruction proceed; what are </context>
</contexts>
<marker>[111]</marker>
<rawString>Stoermer, Rowe, O’Brien, and Verhoef. Model-centric software architecture reconstruction. vol. 36, pp. 333–363, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Fracchia Storey</author>
<author>Muller</author>
</authors>
<title>Cognitive Design Elements to Support the Construction of a Mental Model during Software Exploration.</title>
<date>1999</date>
<journal>Journal of Software Systems,</journal>
<volume>44</volume>
<pages>185</pages>
<contexts>
<context position="16177" citStr="[7, 112]" startWordPosition="2431" endWordPosition="2432">act together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system representations, which are then presented in a suitable interactive form to reverse engineers. Examples. Several tools support a bottom-up process characterized by the extract-abstract-present metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted </context>
<context position="17938" citStr="[103, 112]" startWordPosition="2696" endWordPosition="2697"> a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The term architecture discovery often describes such a process. Examples. The Reflexion Model of Murphy et al. falls into this category [82]. First, the reverse engineer defines his high-level hypothesized views of the application. Second, he specifies how his view maps to the source model. Finally, RMTool identifies consistencies and inconsistencies. Like that, the reverse engineer iteratively interprets and computes successive reflexion models until satisfied. Lungu et al. built both a method and a tool called Softwarenaut [71] to interactively explore hierarchical decompositions of softwa</context>
<context position="19444" citStr="[112]" startWordPosition="2928" endWordPosition="2928">ones and on their internal structure. Categorizing such an approach shows the limit of a strict classification. The approach takes into account physical entities such as packages and does not check the conformance to predefined views as in the Reflexion Model. Still, we put it in this category since we considered that it flows from abstract to concrete entities: the exploration activity starts with the most abstract packages and iteratively open subpackages until to reach a relevant box and arrow view of the software application. 5.3. Hybrid Processes Hybrid processes combine the previous two [112]. On the one hand, low-level knowledge is abstracted up using various techniques. On the other hand, high-level knowledge is refined. This kind of process is frequently used to stop architectural erosion by reconciling the conceptual and concrete architectures. Hybrid approaches often use hypothesis recognizers. Recognizerbased tools provide bottom-up reverse engineering strategies to support top-down exploration of architectural hypothesis. ManSART [43, 137], ART [29], X-ray [79], ARM [40] and DiscoTect [136] are examples of this approach. In ManSART, a top-down recognition engine maps a styl</context>
</contexts>
<marker>[112]</marker>
<rawString>Storey, Fracchia, and Müller. Cognitive Design Elements to Support the Construction of a Mental Model during Software Exploration. Journal of Software Systems, 44:171– 185, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Storey</author>
<author>Muller</author>
</authors>
<title>Manipulating and Documenting Software Structures using SHriMP Views. In</title>
<date>1995</date>
<booktitle>ICSM,</booktitle>
<pages>275--284</pages>
<contexts>
<context position="16659" citStr="[81, 113]" startWordPosition="2497" endWordPosition="2498">odels, they pro4 gressively raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system representations, which are then presented in a suitable interactive form to reverse engineers. Examples. Several tools support a bottom-up process characterized by the extract-abstract-present metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engineer can specify patterns using SQL queries and Perl expressions. The former selects a set of source model entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply </context>
<context position="32456" citStr="[81, 113]" startWordPosition="4873" endWordPosition="4874">he tool has the control and the reverse engineer steers the iterative recovery process. Of course, the boundaries between the classifications are not clear-cut. 7.1. Quasi-Manual Techniques SAR is a reverse engineering activity which faces scalability issues in manipulating knowledge. In response to this problem, researchers have proposed slightly assisted SAR approaches; we considered two categories. Construction-based Techniques. These techniques reconstruct the software architecture by manually abstracting low-level knowledge, thanks to interactive and expressive visualization tools — Rigi [81, 113], PBS [28], CodeCrawler [66]. Exploration-based Techniques. These techniques give reverse engineers an architectural view of the system by guiding them through the highest-level artifacts of the implementation, like in Softwarenaut [71]. The architectural view is then closely related to the developer’s view. Instead of providing guidance, the SAB browser [24] allows reverse engineers to assign architectural layers to classes and to navigate the resulting architectural views. Gallagher et al. [30] surveyed other architecture visualization tools: ArchView1 [27], the Searchable Bookshelf [105], S</context>
<context position="33812" citStr="[81, 113]" startWordPosition="5066" endWordPosition="5067">erse engineer steers the iterative refinement or abstraction leading to the identification of architectural elements. Abstraction-based Techniques. These techniques are based on technologies allowing reverse engineers to specify reusable abstraction rules and to execute them automatically. They aim to map low-level concepts with high-level concepts. Explored approaches are: 1Different of Pinzger’s approach [89, 92], though homonymous. Graph queries: Gupro queries graphs using a specialized declarative expression language called GReQL [19]. Rigi is based on graph transformations written in Tcl [81, 113]. Relational queries: Often, relational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code v</context>
<context position="39032" citStr="[81, 113]" startWordPosition="5850" endWordPosition="5851">itional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [</context>
<context position="42383" citStr="[81, 113]" startWordPosition="6348" endWordPosition="6349">d concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software application. Eixelsberger et al. in ARES [23, 22], and Stoermer in QADSAR [110, 111] reconstruct software architectures to highlight properties like safety, concurrency, portability or other high-level statistics [51]. Approaches taking architectural patterns or orthogonal artifacts into consideration highlight them. For instance, ARM [40], Revealer [90, 91] or Alborz [100, 101] highlight architectural</context>
</contexts>
<marker>[113]</marker>
<rawString>Storey and Müller. Manipulating and Documenting Software Structures using SHriMP Views. In ICSM, pp. 275– 284, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Svetinovic</author>
<author>Godfrey</author>
</authors>
<title>A lightweight architecture recovery process.</title>
<date>2001</date>
<booktitle>In WCRE,</booktitle>
<contexts>
<context position="11623" citStr="[114]" startWordPosition="1739" endWordPosition="1739">usiness objectives. It must be considered as a proactive process realized for future forward engineering tasks. SAR approaches match various often interleaved intentions: Redocumentation and understanding: The primary goal of SAR is to re-establish software abstractions. Recovered architectural views document software applications and help reverse engineers understand them. For instance, the software bookshelf introduced by Finningan et al. illustrates this goal [28]. Svetinovic et al. state that not only the recovered architecture is important, but also its rationale, i.e. why it is as it is [114]. They focus on the architecture rationale forces to recover the decisions made, their alternatives, and why each one was or was not chosen. Reuse investigation and product line migration: Systematic reuse has not yet been achieved. Software product lines allow one to share commonalities among products while getting custom products. Architectural views are useful to identify commonalities and variabilities among products in a line [109, 93, 18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect t</context>
<context position="28695" citStr="[114]" startWordPosition="4310" endWordPosition="4310">cisions, the rationale behind them, effective compositions of architectural elements, and system qualities that will likely result from the style’s use. Finally, DiscoTect considers architectural styles too [136]. It generates program traces by running the instrumented application. Then, it filters the traces and uses a state engine that incrementally recognizes interleaved execution patterns. In this way, DiscoTect reconstruct stylecompliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruc</context>
</contexts>
<marker>[114]</marker>
<rawString>Svetinovic and Godfrey. A lightweight architecture recovery process. In WCRE, Oct. 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Holt Synytskyy</author>
<author>Davis</author>
</authors>
<title>Browsing software architectures with lsedit.</title>
<date>2005</date>
<booktitle>In IWPC,</booktitle>
<pages>176--178</pages>
<contexts>
<context position="39893" citStr="[115]" startWordPosition="5984" endWordPosition="5984">on capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [</context>
</contexts>
<marker>[115]</marker>
<rawString>Synytskyy, Holt, and Davis. Browsing software architectures with lsedit. In IWPC, pp. 176–178, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Systa</author>
</authors>
<title>Static and Dynamic Reverse Engineering Techniques for Java Software Systems.</title>
<date>2000</date>
<tech>PhD thesis,</tech>
<institution>Univ.</institution>
<location>Tampere,</location>
<contexts>
<context position="24199" citStr="[54, 116]" startWordPosition="3655" endWordPosition="3656"> the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design </context>
</contexts>
<marker>[116]</marker>
<rawString>Systä. Static and Dynamic Reverse Engineering Techniques for Java Software Systems. PhD thesis, Univ. Tampere, 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Maccari Telea</author>
<author>Riva</author>
</authors>
<title>An open visualization toolkit for reverse architecting. iwpc, 00:3,</title>
<date>2002</date>
<contexts>
<context position="39617" citStr="[117]" startWordPosition="5939" endWordPosition="5939">tion. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying polymetric view technique. Riva [96] takes advantage of the strengths of different target visualization tools: SoftViz [117] and GraphViz [31] for graph browsing and manipulating, Hava [97] for static and dynamic information, and Rational Rose for UML diagrams. Focus [16, 76], Gupro [19], and the SWAGKit pipeline [28] respectively use Rational Rose, GraphViz also used in [74, 79], and LSEdit [115]. The SAB browser is a dedicated graphical editor to navigate layer [24]. Pacione proposed both a software-oriented visualization tool Vanessa, and a taxonomy in which he surveyed related tools [86]. As shown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tool</context>
</contexts>
<marker>[117]</marker>
<rawString>Telea, Maccari, and Riva. An open visualization toolkit for reverse architecting. iwpc, 00:3, 2002.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Cole Tilley</author>
<author>Becker</author>
<author>Eklund</author>
</authors>
<title>A Survey of Formal Concept Analysis Support for Software Engineering Activities. In</title>
<date>2003</date>
<booktitle>ICFCA,</booktitle>
<contexts>
<context position="38299" citStr="[118]" startWordPosition="5741" endWordPosition="5741">mponents in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance analysis is not sufficient to recover the complete architecture: it requires other techniques such as concept analysis to take component interactions into account. Concept analysis techniques were explored by Siff et al. [104], van Deursen et al. [125], Arevalo [3, 2] or Eisenbarth et al. [21] and surveyed by Tilley et al. [118]. 8. SAR Outputs While most approaches focus on producing presentations of software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] sy</context>
</contexts>
<marker>[118]</marker>
<rawString>Tilley, Cole, Becker, and Eklund. A Survey of Formal Concept Analysis Support for Software Engineering Activities. In ICFCA, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Smith Tilley</author>
<author>Paul</author>
</authors>
<title>Towards a framework for program understanding.</title>
<date>1996</date>
<booktitle>In WPC, p. 19,</booktitle>
<contexts>
<context position="16344" citStr="[119]" startWordPosition="2454" endWordPosition="2454">nside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyses populate a repository, which is queried to yield abstract system representations, which are then presented in a suitable interactive form to reverse engineers. Examples. Several tools support a bottom-up process characterized by the extract-abstract-present metaphor: PBS [28], Rigi [81, 113], Gupro [19], Dali [57, 84]. As an example, Dali works as follows: (1) Heterogeneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engi</context>
</contexts>
<marker>[119]</marker>
<rawString>Tilley, Smith, and Paul. Towards a framework for program understanding. In WPC, p. 19, 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tran</author>
<author>Holt</author>
</authors>
<title>Forward and reverse repair of software architecture.</title>
<date>1999</date>
<booktitle>In CASCON,</booktitle>
<contexts>
<context position="5027" citStr="[120, 96]" startWordPosition="793" endWordPosition="794">chitecture from several viewpoints since the different system stakeholders have different expectations or concerns about the system [64, 52]: View: “a representation of a whole system from the perspective of a related set of concerns.” Viewpoint: “a specification of the conventions for constructing and using a view. A pattern or a template from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis.” Conceptual architecture. It refers to the architecture that exists in human minds or in the software documentation [120, 96]. In the literature, this kind of architecture is also qualified as idealized [43], intended [132, 96], asdesigned [57, 120] or logical [76]. Concrete architecture. It refers to the architecture that can be derived from source code [120, 96]. It is also known as the as-implemented [57, 96], as-built [120, 43], realized [132] or physical [76] architecture. Software architecture reconstruction (SAR). SAR is the reverse engineering approach that aims at reconstructing viable architectural views of a software application. The literature uses several other terms to refer to SAR: reverse architectin</context>
<context position="13074" citStr="[120]" startWordPosition="1958" endWordPosition="1958"> system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking </context>
<context position="41798" citStr="[40, 120]" startWordPosition="6265" endWordPosition="6266">mance between similar abstraction levels (horizontal conformance) and between different abstraction levels (vertical conformance). Horizontal Conformance is checked between two reconstructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, </context>
</contexts>
<marker>[120]</marker>
<rawString>Tran and Holt. Forward and reverse repair of software architecture. In CASCON, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Trifu</author>
</authors>
<title>Using Cluster Analysis in the Architecture Recovery of Object-Oriented Systems.</title>
<date>2001</date>
<tech>PhD thesis,</tech>
<institution>Univ.</institution>
<location>Karlsruhe,</location>
<contexts>
<context position="37742" citStr="[121]" startWordPosition="5653" endWordPosition="5653"> techniques applied to dynamic analysis are as efficient as those applied to static analysis, and this research area is promising and unexplored. The Bauhaus environment implements a wide number of clustering techniques [61, 21, 11]. Koschke emphasizes the need to refine existing clustering techniques, first by combining them, and second by integrating the reverse engineer as a conformance supervisor of the reconstruction process. Adhering to Koschke’s thesis, Trifu unifies cluster and dominance analysis techniques for the recovery of architectural components in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance analysis is not sufficient to recover the complete architecture: it requires other techniques such as concept analysis to take component interactions into account. Concept analysis techniques were explored by Siff et al. [104], van Deursen et al. [125], Arevalo [3, 2] or Eisenbarth et al. [21] and surveyed by Tilley et al. [118]. 8. SAR Outputs While most approaches focu</context>
</contexts>
<marker>[121]</marker>
<rawString>Trifu. Using Cluster Analysis in the Architecture Recovery of Object-Oriented Systems. PhD thesis, Univ. Karlsruhe, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Tu</author>
<author>Godfrey</author>
</authors>
<title>The build-time software architecture view.</title>
<date>2001</date>
<booktitle>In ICSM,</booktitle>
<pages>398--407</pages>
<contexts>
<context position="29195" citStr="[122]" startWordPosition="4394" endWordPosition="4394">everse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be selected or defined according to the environment and the situation [107]. O’Brien et al. notably present the View-Set Scenario pattern that helps determine which architecture views sufficiently describe the system and cover stakeholder needs [85]. Examples. The Symphony approach devised by van Deursen et al. aims at re</context>
</contexts>
<marker>[122]</marker>
<rawString>Tu and Godfrey. The build-time software architecture view. In ICSM, pp. 398–407, 2001.</rawString>
</citation>
<citation valid="true">
<title>Unified Modeling Language 1.5 spec.</title>
<date>2003</date>
<tech>Tech. report,</tech>
<contexts>
<context position="29257" citStr="[123]" startWordPosition="4404" endWordPosition="4404">ctural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be selected or defined according to the environment and the situation [107]. O’Brien et al. notably present the View-Set Scenario pattern that helps determine which architecture views sufficiently describe the system and cover stakeholder needs [85]. Examples. The Symphony approach devised by van Deursen et al. aims at reconstructing software architecture using appropriate viewpoint</context>
</contexts>
<marker>[123]</marker>
<rawString>Unified Modeling Language 1.5 spec. Tech. report, Mar. 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Hofmeister van Deursen</author>
<author>Moonen Koschke</author>
<author>Riva</author>
</authors>
<title>Symphony: View-driven software architecture reconstruction.</title>
<date>2004</date>
<booktitle>In WICSA,</booktitle>
<pages>122--134</pages>
<contexts>
<context position="29864" citStr="[124]" startWordPosition="4495" endWordPosition="4495">While most SAR approaches reconstruct architectural views only according to a single viewpoint or according to a few preselected ones, Smolander et al. highlight that viewpoints cannot be standardized but have to be selected or defined according to the environment and the situation [107]. O’Brien et al. notably present the View-Set Scenario pattern that helps determine which architecture views sufficiently describe the system and cover stakeholder needs [85]. Examples. The Symphony approach devised by van Deursen et al. aims at reconstructing software architecture using appropriate viewpoints [124]. Viewpoints are selected from a catalogue or defined if they don’t exist. Moreover, they evolve throughout the process. Chosen viewpoints constrain SAR to provide architectural views compliant to stakeholders’ expectations, ideally allowing an immediate use of these views. For example, Symphony authors highlight through four case studies some SAR motivations such as checking the conformance of family products to architectural rules. To do this they need to provide to reverse engineers architectural views according the viewpoints these reverse engineers typically use during design. Riva propos</context>
</contexts>
<marker>[124]</marker>
<rawString>van Deursen, Hofmeister, Koschke, Moonen, and Riva. Symphony: View-driven software architecture reconstruction. In WICSA, pp. 122–134, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>van Deursen</author>
<author>Kuipers</author>
</authors>
<title>Identifying Objects using Cluster and Concept Analysis.</title>
<date>1999</date>
<booktitle>In ICSE,</booktitle>
<pages>246--255</pages>
<contexts>
<context position="38220" citStr="[125]" startWordPosition="5725" endWordPosition="5725"> cluster and dominance analysis techniques for the recovery of architectural components in object-oriented legacy systems [121]. Similarly, Lundberg et al. outline a unified approach centered around dominance analysis [70]. On one hand, they demonstrate how dominance analysis identifies passive components. On the other hand, they state that dominance analysis is not sufficient to recover the complete architecture: it requires other techniques such as concept analysis to take component interactions into account. Concept analysis techniques were explored by Siff et al. [104], van Deursen et al. [125], Arevalo [3, 2] or Eisenbarth et al. [21] and surveyed by Tilley et al. [118]. 8. SAR Outputs While most approaches focus on producing presentations of software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus</context>
</contexts>
<marker>[125]</marker>
<rawString>van Deursen and Kuipers. Identifying Objects using Cluster and Concept Analysis. In ICSE, pp. 246–255, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Vasconcelos</author>
<author>Werner</author>
</authors>
<title>Software architecture recovery based on dynamic analysis.</title>
<date>2004</date>
<booktitle>In 18th Brazilian Symp. on Softw. Eng.,</booktitle>
<contexts>
<context position="23857" citStr="[54, 94, 97, 126, 69, 51, 89]" startWordPosition="3600" endWordPosition="3606">6]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 1</context>
</contexts>
<marker>[126]</marker>
<rawString>Vasconcelos and Werner. Software architecture recovery based on dynamic analysis. In 18th Brazilian Symp. on Softw. Eng., 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Murphy Walker</author>
<author>Wright Freeman-Benson</author>
<author>Swanson</author>
<author>Isaak</author>
</authors>
<title>Visualizing dynamic software system information through high-level models.</title>
<date>1998</date>
<booktitle>In OOPSLA,</booktitle>
<pages>271--283</pages>
<contexts>
<context position="23781" citStr="[127, 136, 41]" startWordPosition="3589" endWordPosition="3591">is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design </context>
</contexts>
<marker>[127]</marker>
<rawString>Walker, Murphy, Freeman-Benson, Wright, Swanson, and Isaak. Visualizing dynamic software system information through high-level models. In OOPSLA, pp. 271–283, 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wendehals</author>
</authors>
<title>Improving design pattern instance recognition by dynamic analysis.</title>
<date>2003</date>
<booktitle>In WODA,</booktitle>
<contexts>
<context position="15250" citStr="[1, 3, 46, 128, 5, 39]" startWordPosition="2287" endWordPosition="2292">architecture (i.e. view points, architecture), it provides valuable extra information [4]. These approaches consider that higher level knowledge is necessary to extract valuable information at the architectural level and to improve the expressiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processe</context>
<context position="24411" citStr="[128, 46]" startWordPosition="3689" endWordPosition="3690">tic and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership </context>
</contexts>
<marker>[128]</marker>
<rawString>Wendehals. Improving design pattern instance recognition by dynamic analysis. In WODA, 2003.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wiggerts</author>
</authors>
<title>Using Clustering Algorithms in Legacy Systems Remodularization.</title>
<date>1997</date>
<booktitle>In WCRE,</booktitle>
<pages>33--43</pages>
<contexts>
<context position="36884" citStr="[129]" startWordPosition="5525" endWordPosition="5525">the state machine description. Maps. SAR approaches based on the Reflexion Model [82] use rules to map hypothesized high-level entities with source code entities. 7.3. Quasi-Automatic Techniques Pure automatic techniques failed in reconstructing software architectures, and even if current techniques tend towards an automatic process, reverse engineers must still steer them. Concept, dominance, and cluster analysis techniques are often combined. The Bunch tool [73, 74] uses clustering algorithms to automatically partition software products into cohesive clusters that are loosely interconnected [129]. Clustering algorithms, based on hill climbing and genetic algorithms, are applied on module dependency graphs extracted from source code. The Bunch tool was extended to take into account human knowledge [74]. According to Xiao et al. [135], clustering techniques applied to dynamic analysis are as efficient as those applied to static analysis, and this research area is promising and unexplored. The Bauhaus environment implements a wide number of clustering techniques [61, 21, 11]. Koschke emphasizes the need to refine existing clustering techniques, first by combining them, and second by inte</context>
</contexts>
<marker>[129]</marker>
<rawString>Wiggerts. Using Clustering Algorithms in Legacy Systems Remodularization. In WCRE, pp. 33–43, 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wilde</author>
<author>Huitt</author>
</authors>
<title>Maintenance Support for Object-Oriented Programs.</title>
<date>1992</date>
<journal>IEEE TSE,</journal>
<volume>18</volume>
<issue>12</issue>
<contexts>
<context position="7675" citStr="[130, 14]" startWordPosition="1182" endWordPosition="1183">h contains its actual architecture. However, reconstructing the architecture from the source code raises several problems: • The large amount of data held by the source code raises scalability issues. • Since the considered systems are typically large, complex and long-living, SAR should handle development methods, languages and technologies that are often heterogeneous and sometimes interleaved. • Architecture is not explicitly represented at the source code level. In addition, language concepts such as polymorphism, late-binding, delegation, or inheritance make it harder to analyze the code [130, 14]. How to identify the relevant information to reach an architectural level? • The nature of software raises the questions of whether dynamic information should be extracted as the system is running, and then how do the behavioral aspects appear in the architecture. To summarize this section, the major challenge of SAR is in abstracting, identifying and displaying higher-level views from lower-level and often heterogeneous information. 3. SAR Taxonomy Axes Mendonca et al. [78] classified SAR environments and distinguished five families: filtering and clustering, compliance checking, analysers </context>
</contexts>
<marker>[130]</marker>
<rawString>Wilde and Huitt. Maintenance Support for Object-Oriented Programs. IEEE TSE, SE-18(12):1038–1044, 1992.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wilde</author>
<author>Scully</author>
</authors>
<title>Software reconnaisance: Mapping program features to code.</title>
<date>1995</date>
<journal>Software Maintenance: Research and Practice,</journal>
<volume>7</volume>
<issue>1</issue>
<contexts>
<context position="15495" citStr="[131, 21, 87, 96, 36, 106]" startWordPosition="2325" endWordPosition="2330">ssiveness of the reconstructed architectural views. Due to space limitation, this topic is only briefly surveyed in this paper. It is well acknowledged that patterns play a key role in software engineering and this whatever their abstraction level [4, 8]. Some reverse engineering approaches consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstrac</context>
</contexts>
<marker>[131]</marker>
<rawString>Wilde and Scully. Software reconnaisance: Mapping program features to code. Software Maintenance: Research and Practice, 7(1):49–62, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Carriere Woods</author>
<author>Kazman</author>
</authors>
<title>The perils and joys of reconstructing architectures,</title>
<date>1999</date>
<contexts>
<context position="5129" citStr="[132, 96]" startWordPosition="809" endWordPosition="810"> or concerns about the system [64, 52]: View: “a representation of a whole system from the perspective of a related set of concerns.” Viewpoint: “a specification of the conventions for constructing and using a view. A pattern or a template from which to develop individual views by establishing the purposes and audience for a view and the techniques for its creation and analysis.” Conceptual architecture. It refers to the architecture that exists in human minds or in the software documentation [120, 96]. In the literature, this kind of architecture is also qualified as idealized [43], intended [132, 96], asdesigned [57, 120] or logical [76]. Concrete architecture. It refers to the architecture that can be derived from source code [120, 96]. It is also known as the as-implemented [57, 96], as-built [120, 43], realized [132] or physical [76] architecture. Software architecture reconstruction (SAR). SAR is the reverse engineering approach that aims at reconstructing viable architectural views of a software application. The literature uses several other terms to refer to SAR: reverse architecting, or architecture extraction, mining, recovery or discovery. The last two terms are more specific tha</context>
</contexts>
<marker>[132]</marker>
<rawString>Woods, Carrière, and Kazman. The perils and joys of reconstructing architectures, 1999.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sahraoui Wu</author>
<author>Valtchev</author>
</authors>
<title>Program comprehension with dynamic recovery of code collaboration patterns and roles.</title>
<date>2004</date>
<booktitle>In CASCON,</booktitle>
<pages>56--67</pages>
<contexts>
<context position="15765" citStr="[133]" startWordPosition="2370" endWordPosition="2370"> consequently are based on design pattern identification activities [1, 3, 46, 128, 5, 39]. Concerns are the stakeholders’ criterion for modularizing a software application into manageable and comprehensible parts [98, 12]. Features and aspects are more specific kinds of concerns. Features are considered in [131, 21, 87, 96, 36, 106] and aspect mining techniques in [10, 59, 83]. Source code artifacts interact together to fulfill software behaviors. Wu et al. highlight that source code is structured according a design in mind where software artifacts play conceptual roles inside collaborations [133]. The recovery of collaborations and roles was also explored in [95]. 5. SAR Processes SAR follows either a bottom-up, a top-down or an hybrid opportunistic process. 5.1. Bottom-Up Processes Bottom-up processes start with low-level knowledge to recover architecture. From source code models, they pro4 gressively raise the abstraction level until a high-level understanding of the application is reached [7, 112]. Also called architecture recovery processes, bottom-up processes are closely related to the well-known extractabstract-present cycle described by Tilley et al. [119]. Source code analyse</context>
<context position="24460" citStr="[95, 133]" startWordPosition="3695" endWordPosition="3696">1, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software </context>
</contexts>
<marker>[133]</marker>
<rawString>Wu, Sahraoui, and Valtchev. Program comprehension with dynamic recovery of code collaboration patterns and roles. In CASCON, pp. 56–67, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Wuyts</author>
</authors>
<title>A Logic Meta-Programming Approach to Support the Co-Evolution of Object-Oriented Design and Implementation.</title>
<date>2001</date>
<tech>PhD thesis,</tech>
<institution>Vrije Universiteit Brussel,</institution>
<contexts>
<context position="13165" citStr="[134]" startWordPosition="1968" endWordPosition="1968">tructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 80]; Favre promotes metaware [25]; Huang et al. propose a reflection mechanism too [51]. Analysis: In ArchView [89, 92], SAR and evolution analysis activities are interleaved. QADSAR is analysisoriented too [110, 111]. An analysis framework steers a SAR framework so that it provides required architectural views to compute architectural quality analyses. This analysis assists stakeholders in their decisionmaking processes. Moreover, flexible SAR environments such as Dali [57, 84] or Gupro [19] support </context>
<context position="17345" citStr="[134, 80]" startWordPosition="2609" endWordPosition="2610">geneous low-level knowledge is extracted from the software implementation, fused and stored in a relational database. (2) Using Rigi, one visualizes and manually abstracts this information. (3) A reverse engineer can specify patterns using SQL queries and Perl expressions. The former selects a set of source model entities and the latter treats this set to abstract it. To summarize, Dali is a flexible workbench around a central model storage. Based on Dali, Guo et al. proposed ARM [40]. In Intensive, Mens et al. apply logic intension to group related source-code entities structurally in a view [134, 80]. Reverse engineers incrementally define views and relations by means of intensions specified as Smalltalk or Soul queries. Intensive classifies the views and displays consistencies and inconsistencies with the code and between architectural views. Other bottom-up approaches for instance include ArchView [89, 92], Revealer [90, 91] and ARES [23, 22]. 5.2. Top-Down Processes Top-down processes start with high-level knowledge such as requirements or architectural styles and aim to discover architecture by formulating conceptual hypotheses and by matching them to the source code [103, 112]. The t</context>
<context position="34453" citStr="[134, 80]" startWordPosition="5162" endWordPosition="5163">ational algebra engines abstract data of entity-relation databases. Dali uses SQL queries to define grouping rules [57, 84]. Relational algebra is used to define a repeatable set of transformations such as abstraction or decomposition for creating a particular architectural view. Holt et al. propose the Grok relational expression calculator to reason about software facts [48]. Krikhaar presents a SAR approach based on a Relational Algebra extension [62]. Logic queries: Mens and Wuyts uses Prolog as a meta programming language to extract intensional source-code views and relations in Intensive [134, 80]. Richner also chose a logic query based approach to reconstruct architectural views from static and dynamic facts [94]. Programs: Some approaches build analyses as programs. For example, the analyses made in the Moose environment are performed as object-oriented programs that manipulate models representing the various inputs [17]. Lexical and structural queries: Some approaches are directly based on the lexical and structural information in the source code. Pinzger et al. state that some hotspots clearly localize patterns in the source code and consider them as the starting point of SAR [90, </context>
<context position="38896" citStr="[134, 80]" startWordPosition="5829" endWordPosition="5830">et al. [118]. 8. SAR Outputs While most approaches focus on producing presentations of software architectures, some provide valuable additional information, like conformance data. It is not surprising since SAR outputs are clearly related with goals that lead to perform such an activity. In this section we highlight some key aspects of these outputs. 8.1. Architecture Since SAR approaches are understanding-oriented, they tend to present reconstructed architectural views to stakeholders. As the code evolves some approaches focus on the co-evolution of the reconstructed architectures: Intensive [134, 80] synchronizes the architecture with its implementation; Focus [16, 76] or SAR [63] evolve the application. Visualization. Rigi [81, 113] is widely used to visualize graph representations of software static views [28, 57, 18, 61, 91, 100, 96]. Rigi owes its success to its information manipulation features—since it was originally intended to reconstruct architectures—but also to its navigation capabilities and to its RSF exchange format. The SHriMP visualization technique enhances its navigation capabilities [113]. Several recent SAR tools [92, 80, 71] use CodeCrawler [66] and its underlying pol</context>
</contexts>
<marker>[134]</marker>
<rawString>Wuyts. A Logic Meta-Programming Approach to Support the Co-Evolution of Object-Oriented Design and Implementation. PhD thesis, Vrije Universiteit Brussel, 2001.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Xiao</author>
<author>Tzerpos</author>
</authors>
<title>Software clustering based on dynamic dependencies. csmr,</title>
<date>2005</date>
<pages>00--124</pages>
<contexts>
<context position="37125" citStr="[135]" startWordPosition="5564" endWordPosition="5564">ting software architectures, and even if current techniques tend towards an automatic process, reverse engineers must still steer them. Concept, dominance, and cluster analysis techniques are often combined. The Bunch tool [73, 74] uses clustering algorithms to automatically partition software products into cohesive clusters that are loosely interconnected [129]. Clustering algorithms, based on hill climbing and genetic algorithms, are applied on module dependency graphs extracted from source code. The Bunch tool was extended to take into account human knowledge [74]. According to Xiao et al. [135], clustering techniques applied to dynamic analysis are as efficient as those applied to static analysis, and this research area is promising and unexplored. The Bauhaus environment implements a wide number of clustering techniques [61, 21, 11]. Koschke emphasizes the need to refine existing clustering techniques, first by combining them, and second by integrating the reverse engineer as a conformance supervisor of the reconstruction process. Adhering to Koschke’s thesis, Trifu unifies cluster and dominance analysis techniques for the recovery of architectural components in object-oriented leg</context>
</contexts>
<marker>[135]</marker>
<rawString>Xiao and Tzerpos. Software clustering based on dynamic dependencies. csmr, 00:124–133, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Garlan Yan</author>
<author>Aldrich Schmerl</author>
<author>Kazman</author>
</authors>
<title>Discotect: A system for discovering architectures from running systems.</title>
<date>2004</date>
<booktitle>In ICSE,</booktitle>
<pages>470--479</pages>
<contexts>
<context position="12660" citStr="[136]" startWordPosition="1900" endWordPosition="1900">ne [109, 93, 18, 23]. Conformance: To evolve a software application, it seems hazardous to use the conceptual architecture because it is often inaccurate with respect to the concrete one. In this case, SAR is a means to check conformance between the conceptual and the concrete architectures. Murphy et al. introduced the reflexion model and RMTool to bridge the gap between high-level architectural models and the system’s source code [82]. Using SAR, reverse engineer can check conformance of the reconstructed architecture against rules or styles like in the SAR tool [62], Nimeta [96], DiscoTect [136], Focus [16, 76] and DAMRAM [75]. Co-evolution: Architecture and implementation are two levels of abstraction that evolve at different speeds. Ideally these abstractions should be synchronized to avoid architectural drift. Tran et al. propose a method to repair evolution anomalies between the conceptual and the concrete architectures, possibly altering either the conceptual architecture or the source code [120]. To dynamically maintain this synchronization, Wuyts promotes logic meta-programming [134], and Mens et al. exploit intensional source-code views and relations through Intensive [134, 8</context>
<context position="19959" citStr="[136]" startWordPosition="3004" endWordPosition="3004">oftware application. 5.3. Hybrid Processes Hybrid processes combine the previous two [112]. On the one hand, low-level knowledge is abstracted up using various techniques. On the other hand, high-level knowledge is refined. This kind of process is frequently used to stop architectural erosion by reconciling the conceptual and concrete architectures. Hybrid approaches often use hypothesis recognizers. Recognizerbased tools provide bottom-up reverse engineering strategies to support top-down exploration of architectural hypothesis. ManSART [43, 137], ART [29], X-ray [79], ARM [40] and DiscoTect [136] are examples of this approach. In ManSART, a top-down recognition engine maps a style-compliant conceptual view with a system overview which was defined using a visualization tool in a bottom-up fashion. Examples. Sartipi implemented a pattern-based SAR approach in Alborz [100, 101]. The architecture reconstruction consists of two phases. During the first bottom-up phase, the source code is parsed, presented as a graph, then divided in cohesive graph regions using data mining techniques. This model is at a higher abstraction level than the code. During the second top-down phase, the reverse e</context>
<context position="23781" citStr="[127, 136, 41]" startWordPosition="3589" endWordPosition="3591">is used in ArchView [92, 89], Softwarenaut [71] and Nimeta [96]. Other metamodels such as the Dagstuhl Middle Metamodel [68] or GXL [50] have been proposed. Symbolic Textual Information. Some approaches consider the symbolic information available in the comments [90, 91] or in the name of the methods [65]. Dynamic Information. Static information is often insufficient for SAR since it only provides a limited insight into the run-time nature of the analyzed software; dynamic information is more relevant to understand behavioral system properties. Some SAR approaches use dynamic information only [127, 136, 41] while others mix static and dynamic knowledge [54, 94, 97, 126, 69, 51, 89]. DiscoTect uses runtime events such as method calls, CPU utilization or network bandwidth consumption [136]. Huang et al. also considered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design </context>
<context position="28302" citStr="[136]" startWordPosition="4255" endWordPosition="4255">ecture. Both the conceptual and the concrete architectures are incrementally built. The reverse engineer reconciles the two architectures, based on architectural styles. To select the most appropriate one, they characterize each architectural style according to several criteria. Their approach considers architectural styles as key design idioms since they capture a large number of design decisions, the rationale behind them, effective compositions of architectural elements, and system qualities that will likely result from the style’s use. Finally, DiscoTect considers architectural styles too [136]. It generates program traces by running the instrumented application. Then, it filters the traces and uses a state engine that incrementally recognizes interleaved execution patterns. In this way, DiscoTect reconstruct stylecompliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholder</context>
<context position="36158" citStr="[136]" startWordPosition="5420" endWordPosition="5420">). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execution and outputs architectural events when the execution satisfies 8 the state machine description. Maps. SAR approaches based on the Reflexion Model [82] use rules to map hypothesized high-level entities with source code entities. 7.3. Quasi-Automatic Techniques Pure automatic techniques failed in reconstructing software architectures, and even if current techniques tend towards an automatic process, reverse engineers must still steer them. Concept, dominance, and cluster analysis techniques are often combined. The Bunch tool [73, 74] uses c</context>
<context position="40702" citStr="[136]" startWordPosition="6108" endWordPosition="6108">hown in Section 6, some SAR approaches focus on the behavior of software. Hamou-Lhadj et al. surveyed some of these tools dealing with visualization among others considerations [42]. Description. Architecture Description Languages (ADLs) have been proposed both to formally define architectures and to support architecture-centric development activities [77]. In the scope of this paper, Darwin [72] serves in X-ray [79] to define reconstructed architectural views. It was also extended by Eixelsberger et al. for their SAR approach [23, 22]. Acme [34] has ADL-like features and is used in DiscoTect [136]. Huang et al. specify architectures with the ABC ADL [51]. As said in Section 6.2, the notion of software architecture heavily depends on the stakeholders’ interests. Since ADLs have difficulty in taking different viewpoints into account and focus on the module viewpoint, they are rarely used to express reconstructed architectural views. To drive SAR in CacOphoNy, Favre proposed to precisely define viewpoints using metamodels [26]. 9 8.2. Conformance We consider architecture conformance between similar abstraction levels (horizontal conformance) and between different abstraction levels (verti</context>
<context position="41978" citStr="[136]" startWordPosition="6295" endWordPosition="6295">ructed views, or between a conceptual and a concrete architecture, or between a product line reference architecture and the architecture of a given product. For example, SAR approaches oriented towards a product line migration identify commonalities and variabilities among products, like in MAP [109]. Sometimes SAR requires to define a conceptual architecture and to compare it with the reconstructed concrete one [40, 120]. Sometimes, an architecture must conform to architectural rules or styles; this was discussed in Nimeta [96], the SAR tool [62], Focus [16, 76] and DAMRAM [75] and DiscoTect [136]. Vertical Conformance assesses whether the recontructed architecture conforms to the implementation. Both Reflexion Model-based [82] and co-evolution-oriented [80] approaches revolve around vertical conformance. 8.3. Analysis Reverse engineers use modularity quality metrics either to iteratively assess current results and steer the process, or to get cues about reuse, system improvement Rigi [81, 113], Bauhaus [61, 21, 11] or Alborz [100, 101] provide such results. A few SAR approaches are more analysis-oriented. Archview [89, 92] provides structural and evolutionary properties of a software </context>
</contexts>
<marker>[136]</marker>
<rawString>Yan, Garlan, Schmerl, Aldrich, and Kazman. Discotect: A system for discovering architectures from running systems. In ICSE, pp. 470–479, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Harris Yeh</author>
<author>Chase</author>
</authors>
<title>Manipulating recovered software architecture views.</title>
<date>1997</date>
<booktitle>In ICSE,</booktitle>
<pages>184--194</pages>
<contexts>
<context position="19907" citStr="[43, 137]" startWordPosition="2994" endWordPosition="2995">es until to reach a relevant box and arrow view of the software application. 5.3. Hybrid Processes Hybrid processes combine the previous two [112]. On the one hand, low-level knowledge is abstracted up using various techniques. On the other hand, high-level knowledge is refined. This kind of process is frequently used to stop architectural erosion by reconciling the conceptual and concrete architectures. Hybrid approaches often use hypothesis recognizers. Recognizerbased tools provide bottom-up reverse engineering strategies to support top-down exploration of architectural hypothesis. ManSART [43, 137], ART [29], X-ray [79], ARM [40] and DiscoTect [136] are examples of this approach. In ManSART, a top-down recognition engine maps a style-compliant conceptual view with a system overview which was defined using a visualization tool in a bottom-up fashion. Examples. Sartipi implemented a pattern-based SAR approach in Alborz [100, 101]. The architecture reconstruction consists of two phases. During the first bottom-up phase, the source code is parsed, presented as a graph, then divided in cohesive graph regions using data mining techniques. This model is at a higher abstraction level than the c</context>
<context position="24598" citStr="[43, 137]" startWordPosition="3714" endWordPosition="3715">idered this kind of information because it may inform reverse engineers on system security properties or system performance aspects. Some works focus more on dynamic software information visualization [54, 116]; Hamou-Lhadj et al. present a deeper survey of this domain [42]. There are approaches based on dynamic information in areas adjacent to SAR: feature extraction [21, 99, 36], design pattern localization [128, 46], collaboration and role identification [95, 133]. Most of the time, dynamic information is generated from instrumented source code and use-cases. Physical Organization. ManSART [43, 137] and Softwarenaut [71] take into account the structural organization of physical elements such as files, folders, or packages. Human Organization. According to Conway [13]: “Organizations which design systems are constrained to produce designs which are copies of the communication structures of these organizations”. Inspired by Conway’s thesis, Bowman et al. use the developer organization to form an ownership architecture that helps reconstruct the software architecture [6]. Historical Information. Historical information is rarely used in SAR. Still ArchView is a recent approach that exploits </context>
<context position="28714" citStr="[43, 137]" startWordPosition="4312" endWordPosition="4313">tionale behind them, effective compositions of architectural elements, and system qualities that will likely result from the style’s use. Finally, DiscoTect considers architectural styles too [136]. It generates program traces by running the instrumented application. Then, it filters the traces and uses a state engine that incrementally recognizes interleaved execution patterns. In this way, DiscoTect reconstruct stylecompliant architecture since by choosing a state machine, the reverse engineer defines and refines which hypothesized architectural style the tool should look for [114]. ManSART [43, 137] and MAP [109] are other stylebased SAR approaches. Viewpoints. As Holt states it: the architecture of a system acts as a mental model shared among stakeholders [49]. Since the stakeholders’ interests in reverse engineering diverge, we must consider various viewpoints in SAR [52, 107]. Viewpoint catalogues were built to address this issue: the 4 + 1 viewpoints of Kruchten [64]; the four viewpoints of Soni et al. [47, 108], the build-time viewpoint introduced by Tu et al. [122] or the implicit viewpoints inherent to the UML standard [123]. While most SAR approaches reconstruct architectural vie</context>
<context position="35611" citStr="[43, 137]" startWordPosition="5334" endWordPosition="5335">nd consider them as the starting point of SAR [90, 91]. To drive a pattern-supported architecture recovery, they introduce a pattern specification language and the Revealer tool. Investigation-based Techniques. These techniques map high-level concepts with low-level concepts. The high-level concepts considered cover a wide area from architectural descriptions, styles, and patterns to design patterns, concerns, aspects, and features, that are orthogonal concepts to architecture and that we do not treat in this paper for space reasons (Section 4.2). Explored approaches are: Recognizers. ManSART [43, 137], ART [29], X-ray [79] and ARM [40] are based on a set of architectural style or pattern recognizers written in a query language. More precisely, pattern definitions in ARM are progressively refined and finally transformed in SQL queries exploitable in Dali [57, 84]. Graph pattern matching. In ARM, pattern definitions can also be transformed into pattern graphs to match with a graph-based source code representation like in Alborz [100, 101]. State engine. In DiscoTect state machines are defined to check architectural styles conformance [136]. A state engine tracks at run-time the system execut</context>
</contexts>
<marker>[137]</marker>
<rawString>Yeh, Harris, and Chase. Manipulating recovered software architecture views. In ICSE, pp. 184–194, 1997.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>