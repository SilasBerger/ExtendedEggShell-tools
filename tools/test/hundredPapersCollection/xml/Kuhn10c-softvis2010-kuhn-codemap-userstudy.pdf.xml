<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000000">
<title confidence="0.7814525">
Embedding Spatial Software Visualization
in the IDE: an Exploratory Study
</title>
<author confidence="0.959776">
Adrian Kuhn
</author>
<affiliation confidence="0.920129">
Software Composition Group
University of Bern
</affiliation>
<email confidence="0.985584">
akuhn@iam.unibe.com
</email>
<author confidence="0.858886">
David Erni
</author>
<affiliation confidence="0.879609">
Software Composition Group
University of Bern
</affiliation>
<email confidence="0.9728">
deif@students.unibe.com
</email>
<author confidence="0.717245">
Oscar Nierstrasz
</author>
<affiliation confidence="0.82863">
Software Composition Group
University of Bern
</affiliation>
<email confidence="0.992098">
oscar@iam.unibe.com
</email>
<sectionHeader confidence="0.928738" genericHeader="abstract">
ABSTRACT
</sectionHeader>
<bodyText confidence="0.999218823529412">
Software visualization can be of great use for understand-
ing and exploring a software system in an intuitive manner.
Spatial representation of software is a promising approach of
increasing interest. However, little is known about how de-
velopers interact with spatial visualizations that are embed-
ded in the IDE. In this paper, we present a pilot study that
explores the use of Software Cartography for program com-
prehension of an unknown system. We investigated whether
developers establish a spatial memory of the system, whether
clustering by topic offers a sound base layout, and how de-
velopers interact with maps. We report our results in the
form of observations, hypotheses, and implications. Key
findings are a) that developers made good use of the map
to inspect search results and call graphs, and b) that devel-
opers found the base layout surprising and often confusing.
We conclude with concrete advice for the design of embedded
software maps.
</bodyText>
<sectionHeader confidence="0.994789" genericHeader="categories and subject descriptors">
Categories and Subject Descriptors
</sectionHeader>
<category confidence="0.662189">
D.2.6 [Software Engineering]: Programming Environments
</category>
<sectionHeader confidence="0.875163" genericHeader="general terms">
General Terms
Human Factors
Keywords
</sectionHeader>
<title confidence="0.539659">
Software Development Tools, Software Cartography, Spatial
Software Representation, User Study
</title>
<sectionHeader confidence="0.996641" genericHeader="method">
1. INTRODUCTION
</sectionHeader>
<bodyText confidence="0.995570714285714">
Software visualization can be of great use for understand-
ing and exploring a software system in an intuitive manner.
In the past decade the software visualization community has
developed a rich wealth of visualization approaches [12] and
provided evidence of their usefulness for expert tasks, such
as reverse engineering, release management or dynamic anal-
ysis (e.g., [37, 8, 32, 29]). Typically, these visualization
</bodyText>
<copyright confidence="0.997709333333333">
Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for profit or commercial advantage and that copies
bear this notice and the full citation on the first page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior specific
permission and/or a fee.
</copyright>
<note confidence="0.967481">
SOFTVIS’10, October 25–26, 2010, Salt Lake City, Utah, USA.
</note>
<copyright confidence="0.985983">
Copyright 2010 ACM 978-1-4503-0028-5/10/10 ...$10.00.
</copyright>
<bodyText confidence="0.9977581">
approaches had been implemented in interactive tools [33].
However most of these tools are stand-alone prototypes that
have never been integrated in an IDE (integrated develop-
ment environment). Little is thus known about the benefits
of software visualization for the “end users” in software engi-
neering, that is for everyday programmers. What is lacking
is how these techniques support the day to day activities of
software developers [36].
In this paper, we report on a pilot study of a spatial soft-
ware visualization that is embedded in the IDE. The spatial
visualization is based on the Software Cartography approach
that has been presented and introduced in previous work
[22, 20, 15]. Spatial representation of software is a promis-
ing research field of increasing interest [39, 11, 5, 35, 24, 27],
however the respective tools are either not tightly integrated
in an IDE or have not yet been evaluated in a user study.
Spatial representation of software is supposed to support de-
velopers in establishing a long term, spatial memory of the
software system. Developers may use spatial memory to re-
call the location of software artifacts, and to put thematic
map overlays in relation with each other [20].
The scenario of our user study is first contact with an un-
known closed-source system. Our main question was whether
and how developers make use of the embedded visualization
and if our initial assumptions made when designing the vi-
sualization (as for example the choice of lexical similarity as
the map’s base layout [20, Sec 3]) are based on a valid model
of developer needs. Participants had 90 minutes to solve 5
exploratory tasks and to fix one bug report. We used the
think-aloud protocol and recorded the voices of the partic-
ipants together with a screen capture of their IDE interac-
tions. We took manual notes of IDE interaction sequences
and annotated the sequences with the recorded think-aloud
transcripts.
Results are mixed—some support and some challenge our
assumptions on how developers would use the embedded vi-
sualization. Participants found the map most useful to ex-
plore search results and call graphs, but only rarely used the
map for direct navigation as we would have expected.
Contributions of this paper are as follows:
</bodyText>
<listItem confidence="0.915331222222222">
• We embedded the stand-alone Codemap prototype in
the Eclipse IDE, and added novel thematic overlays
that support the most important development tasks
with visual feedback (see Section 2 and Section 3).
• We performed a think-aloud user study to evaluate the
use of spatial visualization in the IDE. We discuss and
comment on our results, and conclude with practical
design implications (see Section 6 and Section 7).
• We provide suggestions on how to improve Software
</listItem>
<bodyText confidence="0.948958142857143">
Cartography and the Codemap tool (see Section 8).
The remainder of this paper is structured as follows: Sec-
tion 2 and Section 3 present the new Codemap prototype;
Section 4 and Section 5 describes design and data analysis of
the study; Section 6 is the main part that presents and dis-
cusses the results; Section 7 explains threats to the validity;
Section 8 discusses related work; Section 9 concludes.
</bodyText>
<sectionHeader confidence="0.999318" genericHeader="method">
2. SOFTWARE CARTOGRAPHY
</sectionHeader>
<bodyText confidence="0.990569421052631">
Software Cartography uses a spatial visualization of soft-
ware systems to provide software development teams with
a stable and shared mental model. The basic idea of carto-
graphic visualization is to apply thematic cartography [34]
on software visualization. That is, to show thematic over-
lays on top of a stable, spatial base layout. Features on a
thematic map are either point-based, arrow-based or con-
tinuous. For software this could be the dispersion of design
flaws as visualized using icons; a call graph is visualized as
a flow map (as illustrated on Figure 1); and test coverage is
visualized as a choropleth map, i.e., a heat map.
Software Cartography is most useful when it supports as
many development tasks with spatial location awareness as
possible. We therefore integrated our prototype into the
Eclipse IDE so that a map of the software system may al-
ways be present. This helps developers to correlate as many
development tasks as possible with their spatial location.
At the moment, the Codemap plug-in for Eclipse supports
the following tasks:1
</bodyText>
<listItem confidence="0.901429">
• Navigation within a software system, be it for devel-
opment or analysis. Codemap is integrated with the
</listItem>
<bodyText confidence="0.928323">
package explorer and editor of Eclipse. The selection
in the package explorer and the selection on the map
are linked. Open files are marked with an icon on the
map. Double clicking on the map opens the closest file
in the editor. When using heat map mode, recently
visited classes are highlighted on the map.
</bodyText>
<listItem confidence="0.963217">
• Comparing software metrics to each other, e.g., to
</listItem>
<bodyText confidence="0.9386764">
compare bug density with code coverage. The map
displays search results, compiler errors, and (given the
Eclemma plug-in is installed) test coverage informa-
tion. More information can be added through an plug-
in extension point.
</bodyText>
<listItem confidence="0.7893915">
• Social awareness of collaboration in the development
team. Codemap can connect two or more Eclipse in-
</listItem>
<bodyText confidence="0.77999075">
stances to show open files of other developers. Colored
icons are used to show the currently open files of all
developers. Icons are colored by user and updated in
real time.
</bodyText>
<listItem confidence="0.97231875">
• Understand a software system’s domain. The layout of
Codemap is based on clustering software by topic [19],
as it has been shown that, over time, the lexicon of
source code is more stable than its structure [1]. Labels
on the map are not limited to class names, but include
automatically retrieved keywords and topics.
• Exploring a system during reverse engineering. Code-
map is integrated with Eclipse’s structural navigation
</listItem>
<footnote confidence="0.979764">
1http://scg.unibe.ch/codemap
</footnote>
<figureCaption confidence="0.997016">
Figure 1: Thematic codemap of a software sys-
</figureCaption>
<bodyText confidence="0.995002">
tem. Here the Codemap tool itself is shown. Arrow
edges show incoming calls to the #getSettingOrDefault
method in the MenuAction class, which is currently ac-
tive in the editor and thus labeled with a pop-up.
features, such as search for callers, implementers, and
references. Arrows are shown for search results. We
apply the Flow Map algorithm [30] to avoid visual
clutter by merging parallel arrow edges. Figure 1 shows
the result of searching for calls to the #getSettin-
gOrDefault method in the MenuAction class .
</bodyText>
<sectionHeader confidence="0.997138" genericHeader="method">
3. THE CODEMAP ALGORITHM
</sectionHeader>
<bodyText confidence="0.973815222222222">
Figure 2 illustrates the construction of a software map.
The sequence of the construction is basically the same as
presented in previous work [21, 20].
2-Dimensional Embedding.
A distance metric is used to compute the pair-wise dissim-
ilarity of software artifacts (typically source code files). A
combination of the Isomap algorithm [38] and Multidimen-
sional Scaling (MDS) [4] is used to embed all software arti-
facts into the visualization pane. The application of Isomap
is an improvement over previous work in order to assist MDS
with the global layout. In contrast to our previous work, La-
tent Semantic Indexing (LSI) is not applied anymore, it has
been found to have little impact on the final embedding.
Digital Elevation Model.
In the next step, a digital elevation model is created. Each
software artifact contributes a Gaussian shaped basis func-
tion to the elevation model according to its KLOC size. The
contributions of all software artifacts are summed up and
</bodyText>
<figureCaption confidence="0.8332725">
normalized.
Figure 2: Construction steps of a software map, from left to right: 1) 2-dimensional embedding of files on the
</figureCaption>
<bodyText confidence="0.9543433">
visualization pane; 2.a) circles around each file’s location, based on class size in KLOC; 2.b) each file contributes
a Gaussian shaped basis function to the elevation model according to its KLOC size; the contributions of all
files are summed up; 3) fully rendered map with hill-shading, contour lines, and filename labels.
Cartographic rendering.
In the final step, hill-shading is used to render the land-
scape of the software map. Please refer to previous work
for full details [21, 20]. Metrics and markers are rendered in
transparent layers on top of the landscape. Users can tog-
gle separate layers on/off and thus customize the codemap
display to their needs.
</bodyText>
<sectionHeader confidence="0.997553" genericHeader="method">
4. METHODOLOGY
</sectionHeader>
<bodyText confidence="0.999851947368421">
We evaluated our approach in a pilot study with profes-
sional developers and students. The scenario investigated
by the experiment is first contact with an unknown software
system. Participants have 90 minutes to solve 5 program
comprehension tasks and to fix one bug report. After the
experiment, participants are asked to sketch a drawing of
their mental map of the system.
Our goal for the present pilot study was to learn about
the usability of Codemap for program comprehension. We
have been seeking to answer several questions. How can
we support developers in establishing a spatial memory of
software systems? How do we best support the developers
spatial memory using software visualization? How to best
embed spatial software visualization in the IDE? When pro-
vided with spatial representation of search results and call
graphs, how do developers make use of them?
Not covered in this study, and thus open for future user
studies, are the shared team awareness and long term mem-
ory claims of the Software Cartography approach [20].
</bodyText>
<subsectionHeader confidence="0.999163">
4.1 Design of the Study
</subsectionHeader>
<bodyText confidence="0.988866788461539">
The study consists of six programming tasks. The train-
ing task introduced the participants to the Codemap plug-
in. The first five tasks were program comprehension tasks,
starting with general questions and then going into more
and more detailed questions. Eventually, the last task was
to fix an actual bug in the system. Participants were asked
to use the map whenever they saw fit, but otherwise they
were free to use any other feature of Eclipse they wanted.
Task 1, Domain and Collaborators.
“Find the purpose of the given application and identify the
main collaborators. Explore the system, determine its do-
main, and fulfil the following tasks: a) describe the domain,
b) list the main collaborators, c) draw a simple collaboration
diagram, d) identify the main feature of the application.”
Task 2, Technologies.
“In this task we are interested in the technologies used in
the application. List the main technologies, such as for ex-
ample Ajax, XML, or unit testing.”
Task 3, Architecture.
“In this task we are going to take a look at the architec-
ture of the application. Reverse engineer the architecture
by answering the following questions: a) which architectural
paradigm is used (as for example pipes and filters, layers, big
ball of mud, etc)? b) what are the main architectural compo-
nents? c) how are those components related to one another?
d) draw a UML diagram at the level of components.”
Task 4, Feature Location.
“In this task we are interested in classes that collaborate
in a given feature. Please locate the following features: a)
Interactive users are reminded after some months, and even-
tually deleted if they do not log in after a certain number of
months, b) Depending on the kind of user, a user can see
and edit more or less data. There are permission settings for
each kind of user that are checked whenever data is accesses,
and c) Active search: the system compares the curriculum
vitae of the users with stored searches of the companies and
mails new matches to the companies.”
Task 5, Code Assessment.
“In this task we want to assess the code quality of the
application. Please answer the following questions: a) what
is the degree of test coverage? b) are there any god classes?
c) are the classes organized in their proper packages? Should
certain classes be moved to other packages? Please list two
to three examples.”
We provided a code coverage plug-in with the experiment,
as well as a definition of what constitutes a god class [23].
Task 6, Bug Fixing.
In this task we provided an actual bug report and asked
“Describe how you would handle the bug report, that is how
and where you would change the system and which classes
are involved in the bug fix. You are not asked to actually fix
the bug, but just to describe how you would fix it.”
</bodyText>
<subsectionHeader confidence="0.9977">
4.2 Participant Selection
</subsectionHeader>
<bodyText confidence="0.998578142857143">
Participants were selected through an open call for partic-
ipation on Twitter2 as well as through flyers distributed at
a local Eclipse event. Subjects were required to be medium
level Java programmers with at least one year of experi-
ence with both Java and Eclipse programming. The six
tasks had been designed so that the participants did not
need to be knowledgeable with the provided application, but
rather that they explore it as they go along. Seven partic-
ipants took part in the experiment: 4 graduate students
and 3 professional developers from industry. None of the
participants was familiar with the provided application or
with the Codemap plugin; even though some had attended
a 15 minute presentation about the Codemap plugin at the
Eclipse event mentioned above.
</bodyText>
<subsectionHeader confidence="0.999615">
4.3 Study Setting
</subsectionHeader>
<bodyText confidence="0.999657380952381">
The study consisted of three main parts. The first part
was the training task in which the participants were given a
short presentation of Codemap and a tutorial document that
explained all features of the Codemap plug-in. The tutorial
explained all features mentioned in Section 2 using walk-
through descriptions of their use. The participants were
given 20 minutes to explore a small example program using
the Codemap plug-in. When they felt ready, we started part
two of the experiment.
The second part consisted of the actual programming tasks.
A fixed amount of time was allotted to each task. Partici-
pants were asked to spend no more than 15 minutes on each
task. All subjects had access to the Codemap plugin as our
aim was to explore their use of the plugin rather than to
compare a controlled parameter against the baseline.
Eventually, in a third part we held a debriefing session.
We asked participants to draw a map (with any layout or
diagram language whatsoever) of how they would explain
the system under study to another developer. We asked the
participants for feedback regarding their use of the Codemap
plugin and how the plugin could be improved.
</bodyText>
<sectionHeader confidence="0.997079" genericHeader="method">
5. DATA COLLECTION
</sectionHeader>
<bodyText confidence="0.992588666666667">
We asked the participants to think aloud, and recorded
their voice together with a captured video of their computer
screen using the Camtasia software3. We reminded the par-
ticipants to think aloud whenever they fell silent: we told
them to imagine a junior programmer sitting beside them to
whom they are to explain their actions (Master/Apprentice
[2]). The participants were asked to respond to a survey
while performing the study. The survey consisted of their
answers to the tasks, as well as the perceived difficulty of
</bodyText>
<footnote confidence="0.996827">
2http://twitter.com/codemap
3http://www.techsmith.com/camtasia
</footnote>
<bodyText confidence="0.995934888888889">
the tasks and whether they found the Codemap plugin use-
ful for the task at hand. We used a combination of semantic
differential statements and Likert scales with a 5 point scale.
We measured whether or not subjects were successful in
completing a programming task. We used three success lev-
els to measure the success and failure of tasks: a task could
be a success, a partial success or a failure. We further subdi-
vided tasks 4 and 5 into three subtasks and recorded success
levels for each individual subtask. We asked one of the orig-
inal authors of the system to assess the success levels. As
this was a think-aloud study, we did not measure time, but
alloted a fixed 15 minute slot to each task.
Our main interest was focused on how the participants
used the IDE to solve the tasks, independent of their success
level. To do this, we transcribed important quotes from the
recorded participant voices and screen captures and took
notes of the actions that the participants did during the
tasks. For each task we tracked the use of the following IDE
</bodyText>
<listItem confidence="0.970123529411765">
elements:
• Browsing the system using the Package Explorer and
Outline view. This includes both drill-down as well as
linear browsing of package, class and method names.
• Browsing the system using the spatial visualization of
the Codemap plugin. This includes both opening sin-
gle classes, selecting a whole cluster of classes on the
map, as well as reading class name labels on the map.
• Reading source code in the editor pane, including doc-
umentation in the comments of class and method head-
ers.
• Navigating the structure of the system using the Type
Hierarchy and Call Hierarchy view. We tracked whether
they explored the results of these searches in Eclipse’s
tabular result view or using the flow-map arrows dis-
played on the spatial visualization of Codemap.
• Searching the structure of the system with either the
</listItem>
<bodyText confidence="0.8774832">
Open Type or Java Search dialog. This allows users to
search for specific structural elements such as classes,
methods or fields. Again, we tracked whether they
explored the results in Eclipse’s result view or on the
visualization of Codemap.
</bodyText>
<listItem confidence="0.9853">
• Searching the system with the unstructured text search,
</listItem>
<bodyText confidence="0.919180666666667">
either through the Java Search dialog or the immedi-
ate search bar of the Codemap plugin. Also here, we
tracked whether they explored the results in Eclipse’s
result view or on the visualization of Codemap.
Replicability: the raw data of our analysis is available on
the Codemap website at http://scg.unibe.ch/codemap.
</bodyText>
<sectionHeader confidence="0.981511" genericHeader="method">
6. RESULTS
</sectionHeader>
<bodyText confidence="0.999884333333333">
After analyzing our data, we observed different degrees
of interaction with the Codemap plug-in. We focused our
analysis on interaction sequences that included interaction
with the Codemap plug-in, but also on those interaction
sequences that challenged our assumptions about how de-
velopers would make use of the plug-in.
The presentation of results is structured as follows. First,
we briefly cover how each task was solved. Then present an
in-depth analysis of our observations, structured by triples
of observation, hypothesis, and implication. Implications are
directed at improving the design and usability of spatial vi-
sualizations that are embedded in an IDE.
</bodyText>
<subsectionHeader confidence="0.7080875">
6.1 Task Performance
Task 1, Domain and Collaborators.
</subsectionHeader>
<bodyText confidence="0.984629622641509">
Participants used an approach best described as a“reverse
Booch method” [3]. Given a two-sentence description of the
system that we’ve provided, they searched for nouns and
verbs using Eclipse’s full text search. Most participants used
Codemap to assess quantity and dispersion of search results,
and also to directly select and inspect large classes. Then
they looked at the class names of the matches to learn about
the domain and collaborators of the system. Students also
read source code, whereas professional participants limited
their investigation to using the package explorer and class
outline.
Task 2, Technologies.
This task showed the most uniform behavior from both
student and professional participants. They inspected the
build path node and opened all included JAR libraries. Pro-
fessional developers typically raised the concern that possi-
bly not all of these libraries were (still) used and started to
explore whether they were used. Typically they would carry
out a search to do so, but one developer showed a very in-
teresting pattern: He would remove the libary “on purpose”
and then look for compile errors as an indicator of its use.
Students seems to implicitly assume that all libraries were
actually used, at least they never raised such a concern. We
interpret this as a sign that professionals are more cautious
[18] and thus more aware of the typical decay caused by
software evolution, which may include dead libraries.
Task 3, Architecture.
Typically participants drilled-down with the package ex-
plorer and read all package names. All professionals started
out by formulating the hypothesis of a layered three-tier ar-
chitecture, and then start fitting the packages to the different
layers. Most participants used Codemap to look at the dis-
persion of a package’s classes (when selecting a package in
the package explorer, the contained classes are highlighted
on the map).
To learn about the architectural constraints, professionals,
for the first time in the experiment, started reading source
code. They also did so quite differently from the way that
students did. Whereas students typically read code line by
line, trying to understand what it does, the professionals
rather used the scroll-wheel to skim over the code as it flies
by on the screen, thereby looking for “landmarks” such as
constructor calls, method signatures and field definitions.
Professionals made much more use of “open call hierarchy”
and “open type hierarchy”. Interestingly enough, only one
participant opened a type hierarchy of the whole project.
Task 4, Feature Location.
For this task, participants made most frequent and more
interesting use of Codemap than for any other task. Same of
for task 1, participants used a reversal of the Booch method.
They searched for nouns and verbs found in the feature de-
scription. Again, they used the map to assess quantity and
dispersion of search results. Also two participants used the
</bodyText>
<figureCaption confidence="0.686971">
Figure 3: Screen capture of “Aha moment” as en-
</figureCaption>
<bodyText confidence="0.996701859375">
countered by participant T during task 4-b (location
of security features): Upon opening the call hierarchy
of Grant’s constructor, a huge call-arrow appeared on
the map: indicating dozens of individual calls that
connect the security-related archipelago in the south-
west with the TreeFactory island in the east. Given
the visual evidence of this arrow, participant T solved
the task without further investigation.
map to select and inspect search matches based on their
context in the map.
Participants now began to read more source code than
before. In particular, when they found a promising search
result they used the“open call hierarchy”feature to locate re-
lated classes. All participants reported that Codemap flow-
map overlay helped them to work with the call graph. For
some developers there was an actual “Aha moment” where
one glance at the Codemap helped them to solve the current
subtask immediately without further investigation. Figure 3
illustrates one particular moment as encountered by partic-
ipant T during the location of the security feature.
Task 5, Code Assesment.
This set of tasks made it most obvious that Codemap’s
layout was not based on package structure. Participants re-
ported that they had a hard time to interpret the thematic
maps as they could not map locations on the map to pack-
ages. In particular the professional participants expressed
concerns regarding the use of KLOC for hill size. They ex-
pressed concerns that this might be misleading since lines of
code is not always an indicator of importance or centrality
on the system’s design.
Task 6, Bug Fixing.
Participants mainly used the same approach as for the fea-
ture location tasks. They first located the implementation
of the feature in which the bug occurs, and then fixed the
bug. Professional participants did so successfully, whereas
student participants did not manage to find the correct lo-
cation in the source code.
Wrap-up session.
In general, participants reported that Codemap was most
useful when it displayed search results, callers, implementers,
and references. A participant reported: “I found it very help-
ful that you get a visual clue of quantity and distribution of
your search results”. In fact, we observed that that partic-
ipants rarely used the map for direct navigation but often
for search and reverse engineering tasks.
Another observation was that inexperienced developers
(i.e., students) are more likely to find the map useful than
professional developers. This might be explained by the hy-
pothesis that to power users any new way of using the IDE
is likely to slow them down, and conversely to beginners any
way of using the IDE is novel. The only exception to this ob-
servation was Codemap’s search bar, a one-click interface to
Eclipse’s native search, that was appreciated and used by all
participants but one that preferred to use the search dialog.
One Participant also provided us feedback comparing his
experience with Codemap to that with the Moose analysis
tool [26]. He uses Moose at work after having attended a
tutorial by a consultant. He said he prefers the immediate
feedback of Codemap, and reported that “the gap between
Moose and IDE is just too large, not to mention the struggle
of importing Java code. Moose helps you to e.g., find god-
classes but this is typically not new to developers that know
a system. Codemap seems more interesting as it integrates
with what you actually do in the IDE as you program.”
</bodyText>
<subsectionHeader confidence="0.961352">
6.2 Observations, Hypotheses, Implications
</subsectionHeader>
<bodyText confidence="0.9996219">
In this section, we present an in-depth analysis of our ob-
servations, structured by triples of observation, hypothesis,
and implication. Implications are directed at improving the
design and usability of spatial visualizations that are em-
bedded in an IDE.
Observation 6.1: When thinking aloud, developers did
speak of the system’s architecture in spatial terms.
The think-aloud protocol revealed that participants refer
to the system’s architecture in spatial terms. Professional
participants referred to packages as being above, below, or
at the some level as one another. Some of them even did
so before recovering the system’s 3-tier architecture in task
#3. Most professionals referred to utility packages a being
spatially beside or outside the layered architecture.
For example, participant T located all utility packages in
the upper left corner, separated by a jagged line. While
doing so, he made a gesture as if pushing the utility classes
away and stated, “I am putting them up here because to me
they are somehow beside the system.”
Students on the other hand made much fewer references
to the system’s architecture, both spatial as well as in gen-
eral. They were typically reasoning about the system at the
level of classes and source lines, rather than in architectural
terms. The maps drawn by students in the wrap-up phase,
however, showed similar spatial structure to those of the
professionals. It remains thus open whether students estab-
lished a genuine spatial model while working with the code
(as we observed for professionals) or only because they were
asked to draw the wrap-up maps.
Hypothesis 6.1: Professional developers do establish a
spatial mental model of the system’s architecture.
Based on above observations there is evidence to assume
that professional developers establish a spatial mental model
of the system’s architecture as they work with code. Fur-
thermore, they do so even without visual aids, since they
use spatial terms and thinking even before being asked to
draw a diagram of the system’s architecture.
Implication 6.1: Developers should be able to arrange
the layout according to their mental model.
This has implications on the design of a system’s spatial
visualization. Developers should be able to arrange the lay-
out according to their mental model. Developers should be
able to drag and move parts of the map around as they
wish, rather than having to stick with the automatically es-
tablished layout. Code Canvas [11] and Code Bubbles [5]
both already address this implication. In those tools, the
user may drag individual elements around and arrange them
according to his mental model.
We observed that developers referred to architectural com-
ponents, but not classes, in spatial terms. The needs of de-
velopers might thus be even better served by providing them
more high-level means of arranging the map. Our next pro-
totype will use anchored multidimensional scaling such that
developers may initialize the map to their mental model.
Anchored MDS allows the developer to define anchors which
influence the layout of the map [6, Sec 4.4]. Any software
artifact can be used as an anchor (as long as we can compute
a its distance to artifacts on the map), even for example ex-
ternal libraries. In this way, developers might e.g., arrange
the database layer in the south and the UI layer in the north
using the respective libraries as anchors.
Observation 6.2: Participants used Codemap to as-
sess quantity and dispersion of search results and call
graphs.
The feature of Codemap that was used most often, by both
professionals and students, was the illustration of search re-
sults and call graphs. Participants reported that they liked
the search-result support of the map, explaining that it gives
them much faster initial feedback than Eclipse’s tabular pre-
sentation of search results. Many participants reported that
it was “as if you could feel the search results,” and that “you
get an immediate estimate how much was found, whether it
is all one place or scattered all over the place.”
Figure 3 illustrates one particular “Aha moment” as en-
countered by participant T during task 4-b, i.e., location of
security features: Upon opening the call hierarchy, a huge
call-arrow appeared on the map: indicating dozens of in-
dividual calls that connect the security-related archipelago
in the south-west with the TreeFactory island in the east.
Given the visual evidence of this arrow, the participant solved
the task immediately without further investigation of the
system.
Hypothesis 6.2: Intuitive visualization to show quantity
and dispersion of search results (as well as call graphs)
address an important need of developers.
Given the above observation it seems clear that devel-
opers have urgent needs for better representation of search
results than tabular lists. We found that both students and
professionals used the map to get an immediate estimation
of search results. This is most interesting since otherwise
their use of the tabular search results differed: Professionals
glanced at the results, inspected one or maybe two results,
and then either accepted or rejected their hypothesis about
the system, while students would resort to a linear search
through all search results, not daring to reject a hypothesis
on the grounds of one or two inspected results only.
Given the map’s illustration of search results however, the
behavior of both groups changed. Students dared to take
quick decisions from a mere glance at the map, whereas pro-
fessionals were more likely to inspect several results. One
professional reported that he “inspected more results than
usual, because the map shows them in their context and that
this helps him to take a more informed choice on which re-
sults are worth inspection and which ones not.”
Implication 6.2: Tools should put search results into a
meaningful context, so developers can take both quicker
and better-informed decisions.
The need for better presentation of search results has im-
plications beyond the design of spatial visualizations. Work
on presentation of search results goes beyond spatial maps
[16], for example results can be presented as a graph. Poshy-
vanyk and Marcus [31] have taken one such approach (rep-
resenting search results as a lattice) and applied it to source
code search with promising results.
For our next prototype we plan to integrate search results
into the package explorer view, just as is already done with
compile errors (which are, from this point of view, just like
the search results of a complex query that is run to find
syntax errors). This planned feature addresses another im-
plication of our study as well, as we have found that some
developers establish a spatial memory of the package ex-
plorer view. It therefore makes sense to mark search results
both on our map as well as in the explorer view.
Observation 6.3: When interacting with the map, par-
ticipants were attracted to isolated elements, rather than
exploring clusters of closely related elements.
We found that participants are more likely to inspect eas-
ily discernible elements on the map. They are more likely
to notice and interact with an isolated island rather than
with elements that are part of a larger continent. Unfor-
tunately, it is exactly dense and strongly correlated clusters
that contain the most interesting parts of the system! When
investigating this issue, participants answered that “those
(isolated) elements looked more important as they visually
stick out of the rest of the map.”
Also, when working with another system that had (unlike
the present study) a large cluster in the middle surrounded
by archipelagos on the periphery, we found that users started
their exploration with isolated hills in the periphery, only
then working their way towards the more dense cluster in
the middle.
Hypothesis 6.3/a: Developers avoided clusters of closely
relates elements because they are difficult to identify
and select on the map.
All participants had difficulties to open files by clicking on
the map. They had difficulties to select classes on the map
when they are in a crowded cluster. They would click in
the middle of a label, but often the labels are not centered,
which is an unavoidable artifact of any labeling algorithm,
and thus the clicks would open a different (unlabeled) class.
Codemap does provide tooltips, however participants did
not use them. From observing their work it was obvious
why: both students and professionals were working at such a
speed that waiting for a tooltip to appear would have totally
taken them out of their workflow.
Observation 6.3/b: Participants rarely used Codemap
to return to previously visited locations, instead using
package explorer and “Open Type” to do so.
Contrary to our assumptions, participants did not use the
map to return to previously visited locations by recalling
them from spatial memory. Some would use the map, but
only for exposed classes that are easily recognizable and
clickable. This observation is related to the previous one.
We found however some participants established a spatial
memory of the package explore—and did so in addition to
their spatial model of the system’s architecture! For exam-
ple, participant S would drill down with the explorer saying
“let’s open that class down there” or “there was this class up
here.” Over the course of the experiment he got quicker at
navigating back to previously visited classes in the package
explorer. Other participants, as for example participant T,
relied on lexical clues and made extensive use of Eclipse’s
“Open Type” dialog to find their way back to previously
visited classes.
Usability glitches will of course worsen the effect of (or
might even be the main cause of) not using the map for
navigation and revisiting classes. From this it follows that:
Implication 6.3: The map’s layout should be such that
all elements are easily discernable and easy to click.
Real estate on a computer screen is limited, and even more
so in an IDE with all its views and panels. As tool builders
we have limited space available for an embedded visualiza-
tion. Given our goal of establishing a global layout we face
the challenge of having to visualize all elements of a system
in that very limited space.
The current implementation of Codemap has one level of
scale only, which may yield crowded clusters where elements
are placed just pixels apart. A zoomable map as provided
by Code Canvas [11] addresses this issue.
The fact that we are attracted by elements that visually
detach from other has two impacts: one is that we tend
to look at isolated elements as being of low significance, the
other being that it is hard to identify elements in the cluster.
These impacts are very different, but can both be addressed
in a common way. For instance, a threshold could be used to
not show isolated elements at all, but only significant clus-
ters. Alternatively, colors may be used to display isolated
elements so that they do not draw our attention so readily.
Observation 6.5: Participants used Codemap as if its
layout were based on package structure — even though
they were aware of the underlying topic-based layout.
Developers assume that packages are a valid decomposi-
tion of the system and expect that the layout of the spa-
tial visualization corresponds to the package structure. We
found that clustering classes by topic rather than packages
violates the “principle of least surprise.” We observed that
participants tended to interpret visual distance as a measure
of structural dependencies—even though they were aware
of the underlying lexical implementation!
Participants expected the layout to reflect at least some
structural property. Most of them reacted surprised or con-
fused when for example the classes of a package were not
mostly in the same place. For example, Participant S re-
ported in the wrap-up, “this is a very useful tool but the
layout does not make sense”. Another participant stated
during task 3 (i.e., the architecture recovery) with confu-
sion that “the classes contained in packages are scattered on
the map, it is not obvious what their spatial connection is.”
Hypothesis 6.5: From the developers view, the pre-
dominant mental decomposition of a system is package
structure.
Given our reverse engineering background [26, 19, 13]
we had come to distrust package decomposition, however
it seems that developers like to rely on the packaging that
other developers have made when designing the system.
One problem raised by research in re-packaging legacy sys-
tems is that packages play too many roles: as distribution
units, as units of namespacing, as working sets, as topics,
as unit of architectural components, etc. However, as an
opposing point of view, we can relate packaging to the folk-
sonomies of the Web 2.0, where users label elements with
unstructured tags that are then exploited by other users to
search for elements. In the same way, we could say that
putting trust into a given package structure is a way of col-
laborative filtering. Developers assume that other develop-
ers had made the same choice as they would when packaging
the system.
Implication 6.5: The map layout should be based on
code structure rather than latent topics only. However,
non-structural data should be used to enrich the lay-
out.
When running the user study, it became quickly apparent
that we should revise our initial assumption that lexical sim-
ilarity is a valid dissimilarity metric for the spatial layout.
This was the strongest feedback, and as is often the case in
exploratory user studies, already obvious from watching the
first professional participant for five minutes only. From all
participants we got the feedback that they expect the lay-
out to be structural and that our clustering by topics kept
surprising them even after working with the map for almost
two hours.
Still we think that spatial layouts that go beyond package
structure are worthwhile. Therefore, we propose to enrich
structure-based layout with non-structural data, such as de-
sign flaws. For future work, we are about to refine our layout
algorithm based on that conclusion. The new layout is based
on both lexical similarity and the ideal structural proximity
proposed by the “Law of Demeter” (LOD). This is a design
guideline that states that each method should only talk to
its friends, which are defined as its class’s fields, its local
variables and its method arguments. Based on this we can
defined an idealized call-based distance between software ar-
tifacts. Given a LOD-based layout, software artifacts are
close to one another if they are supposed to call one another
and far apart if they better should not call one another.
Thus we get the desired property that visualizing call-graphs
conveys meaningful arrow distances. On a LOD-based map,
any long-distance-call has a diagnostic interpretation that
helps developers to take actions: Long flow-map arrows in-
dicate calls that possibly violate the “Law of Demeter”.
</bodyText>
<sectionHeader confidence="0.736583" genericHeader="method">
7. THREATS TO VALIDITY
</sectionHeader>
<bodyText confidence="0.999174">
This section summarizes threats to validity. The study
had a small sample size (3 students, 4 professionals) and
might thus not be representative. We manually evaluated
the data, results might thus be biased. Nevertheless, results
are promising and running a pilot think-aloud study with a
small user group is a state-of-the-art technique in usability
engineering to learn learn about the reactions of users. Such
pilot studies are typically used as feedback for further itera-
tion of the tool and to assess the usefulness of its application
[25].
</bodyText>
<sectionHeader confidence="0.929052" genericHeader="related work">
8. RELATED WORK
</sectionHeader>
<bodyText confidence="0.99937350617284">
In this section we discuss related tools and user studies.
We selected tools that embed a spatial visualization of soft-
ware in the IDE, and user studies that study how developers
navigate in the IDE as well as studies of tools that group
software artifacts by topic rather than structure.
Most closely related to the spatial approach studied in this
paper is the work on spatial representation by DeLine [11,
7, 9, 10].
CodeCanvas by DeLine and Rowan [11] is a zoomable
source editor that drops levels of details as you zoom out,
up to the level of a UML diagram. CodeCanvas allows de-
velopers to rearrange the layout, to tear classes apart into
smaller parts, and to filter by working sets and stack traces.
CodeCanvas features two thematic maps, an interactive vi-
sualization of debug traces and spatial search results. A user
study is not yet available.
Cherubini, Venolia et al. studied how developers use spa-
tial representation of their code [7]. They asked a team
to set up a wall-sized spatial map of their system, and ob-
served them for three weeks. They found that developers
use horizontal rows to lay out diagrams by layers, and ver-
tical columns to group it by domain topic. These are the
same two spatial decompositions we found in our study, i.e.,
conceptual and structural. Also, they found that developers
put utility classes aside, just as our study revealed.
CodeBubbles by Bragdon and Reiss et al. [5] breaks code
into method fragments (called bubbles) and allows develop-
ers to arrange the code fragments spatially on a larger-than-
screen map. Fragments do not overlap, and can be grouped
into persistent working sets. The authors had been running
a pilot study and reported that developers did not express
concern over the absence of files, but rather felt that bubbles
offer better editing. And further, that developers felt that
spatial representation was very close to what is needed for
visual explanation.
CodeBubbles differs from our approach in a fundamental
aspect: developers create the spatial layout themselves as
they add methods to the current working set. As a con-
sequence there are as many spatial layouts of the system
as there are working sets. By contrast our Codemap plug-
in, as well as the CodeCanvas tool of DeLine [11], relies on
one global layout for all programming tasks. In our present
study we observed that some developers maintained more
than one spatial model of the same system (one conceptual,
one structural), we consider it thus promising future work
to combine both approaches.
TeamTracks by Deline, Czerwinski and Robertson [10] as-
sists developers using collaborative filtering of navigation
history. They ran a user study where professional devel-
opers had to fix bugs. Developers that used TeamTracks
showed better task completion. Moreover, they found that
performance was better for locally focused features rather
widely disperse features. This issue is addressed on our tool
where we give visual evidence of quantity and dispersion of
search results and call graphs, of which participants made
good use in the feature location task.
CodeThumbnails by DeLine and Czerwinski et al. [9] em-
beds a global navigation map in the IDE. The map consists
of a zoomed-out view of the source code text, similar to
Eick’s Seesoft [14]. In a user study they found that devel-
opers quickly established a spatial memory of the system.
Results from our study confirm this observation.
Mylar (now known as Mylyn) by Kersten and Murphy [17]
integrates a degree-of-interest (DOI) model in the IDE. My-
lyn extends the IDE with a task view, and maintains a DOI
model per task. Developers can this model to filter views
by working set. This is similar to the clustering by topic on
our spatial map, elements are grouped by conceptual rather
than structural relation. They measured the approach in
a user study and report an 15% productivity improvement,
measured as“the number of keystrokes in the editor over the
number of selections made in editor and views.”
War Room Command Console by O’Reilly et al. [28] is
a shared software visualization for team coordination. The
system highlights individual team efforts by combining sys-
tem structure and ongoing developer activity in order to re-
port progress to management. They did a survey, and found
that users felt the system was useful but found it hard to
translate between viewpoints using the given spatial layout.
Based on that, they propose a set of visualization techniques
to overcome this limitation.
</bodyText>
<sectionHeader confidence="0.997669" genericHeader="conclusions">
9. CONCLUSION
</sectionHeader>
<bodyText confidence="0.9515945">
In this paper we presented an evaluation of spatial soft-
ware visualization in the IDE. We embedded a prototype of
the Software Cartography approach [22, 15, 20], the Code-
map plug-in, in the Eclipse IDE and ran an exploratory user
study which included both students and professionals.
Software maps are supposed to help developers with a vi-
sual representation of their software systems that addresses
their spatial thinking and memory. The scenario of our user
study was first contact with an unknown closed-source sys-
tem. Results were as follows:
• Participants made good us of the map to inspect search
results and call graph, they reported that the spatial
visualization provided them with an immediate esti-
mate of quantity and dispersion of search results.
</bodyText>
<listItem confidence="0.675435">
• Participants found the layout of the map (which uses
</listItem>
<bodyText confidence="0.981146666666667">
lexical information to cluster classes by topic) surpris-
ing and often confusing. This led to the revision of our
initial assumption that lexical similarity is sufficient to
lay out the cartographic map.
We made the following four main observations, and con-
cluded from these the following implications:
</bodyText>
<listItem confidence="0.997858">
• All participants used a form of spacial thinking to un-
derstand the system. It would be best to allow devel-
opers to rearrange the initial layout according to their
spatial memory.
• Immediate estimate of quantity and dispersion of search
results is useful and the map suits this well.
• Participants are distracted by isolated elements, which
</listItem>
<bodyText confidence="0.941704538461539">
does not happen in textual/tabular representation. This
is the drawback of visualization, which must find the
right balance between the power of visualization and
the pitfall of visualization. The map should be im-
proved to mitigate that.
• The coexistence of two models for the software (one
structural, one conceptual) causes some confusion. With
the present map and implementation, participants were
puzzled by non-structural nature of the map.
Developers intuitively expect that the map meets their
mental model of the system’s architecture. We observed
that if this is not given, developers are not able to take ad-
vantage of the map’s consistent layout. So for example, even
though north/south and east/west directions had clear (se-
mantic) interpretations in the map used for the user study,
developers did not navigate along these axes.
However, even with the most perfect layout, developers
might not be able to take advantage of the map if it elements
are barely discernable, and thus difficult to inspect.
Based on the results of our user study, we conclude with
the working hypothesis that the map should incorporate struc-
tural information and be improved from point of usability
and that we need more work to make two models (one struc-
tural, one conceptual) coexists without creating confusion.
In order to achieve this, we propose the following changes
to the Software Cartography approach:
</bodyText>
<listItem confidence="0.9707805">
• Compute the initial layout such that distance reflects
structural correlation, since this is what the developers
expect (i.e., “principle of least astonishment”).
• Use anchored multi-dimensional scaling for the layout
</listItem>
<bodyText confidence="0.7275595">
such that developers may rearrange the map according
to their spatial model of the system.
</bodyText>
<listItem confidence="0.932699166666667">
• To use architectural components as anchors for rear-
rangement of the map, since spatial thinking of devel-
opers is strongest at the architectural level.
• Improve the usability experience of inspecting and se-
lecting of elements on the map, possibly using a zoom-
able user interface.
</listItem>
<sectionHeader confidence="0.973293" genericHeader="acknowledgments">
Acknowledgements
</sectionHeader>
<bodyText confidence="0.994967285714286">
We are grateful to Niko Schwarz and Erwann Wernli for
their constructive comments that considerably contributed
to this paper. We also express our thanks to all the fellow
researchers that provided feedback on this work at the ICSE
conference in Cape Town, 2010. We gratefully acknowledge
the financial support of the Swiss National Science Founda-
tion for the project “Bringing Models Closer to Code” (SNF
</bodyText>
<reference confidence="0.997586268656717">
Project No. 200020-121594, Oct. 2008–Sept. 2010).
10. REFERENCES
[1] G. Antoniol, Y.-G. Gueheneuc, E. Merlo, and P. Tonella.
Mining the lexicon used by programmers during sofware
evolution. ICSM 2007, pages 14–23, Oct. 2007.
[2] H. Beyer and K. Holtzblatt. Contextual Design: Defining
Customer-Centered Systems (Interactive Technologies).
Morgan Kaufmann, 1st edition, September 1997.
[3] G. Booch. Object Oriented Analysis and Design with
Applications. The Benjamin Cummings Publishing Co.
Inc., 2nd edition, 1994.
[4] I. Borg and P. J. F. Groenen. Modern Multidimensional
Scaling: Theory and Applications. Springer, 2005.
[5] A. Bragdon, S. P. Reiss, R. Zeleznik, S. Karumuri,
W. Cheung, J. Kaplan, C. Coleman, F. Adeputra, and
J. J. L. Jr. Code bubbles: Rethinking the user interface
paradigm of integrated development environments. ICSE
(2010). ACM, 2010.
[6] A. Buja, D. F. Swayne, M. L. Littman, N. Dean,
H. Hofmann, and L. Chen. Data visualization with
multidimensional scaling. Journal of Computational and
Graphical Statistics, 17(2):444–472, June 2008.
[7] M. Cherubini, G. Venolia, R. DeLine, and A. J. Ko. Let’s
go to the whiteboard: how and why software developers use
drawings. CHI ’07, pages 557–566, New York, NY, USA,
2007. ACM.
[8] W. De Pauw, H. Andrade, and L. Amini. Streamsight: a
visualization tool for large-scale streaming applications.
SoftVis 2008, pages 125–134, New York, NY, USA, 2008.
ACM.
[9] R. DeLine, M. Czerwinski, B. Meyers, G. Venolia, S. M.
Drucker, and G. G. Robertson. Code thumbnails: Using
spatial memory to navigate source code. VL/HCC, pages
11–18, 2006.
[10] R. DeLine, A. Khella, M. Czerwinski, and G. G. Robertson.
Towards understanding programs through wear-based
filtering. SOFTVIS 2005, pages 183–192, 2005.
[11] R. DeLine and K. Rowan. Code canvas: Zooming towards
better development environments. ICSE (NIER track)
2010. ACM, 2010.
[12] S. Diehl. Software Visualization. Springer-Verlag, Berlin
Heidelberg, 2007.
[13] S. Ducasse and D. Pollet. Software architecture
reconstruction: A process-oriented taxonomy. IEEE
Transactions on Software Engineering, 35(4):573–591, July
2009.
[14] S. G. Eick, J. L. Steffen, and S. Eric E., Jr. SeeSoft—a tool
for visualizing line oriented software statistics. IEEE
Transactions on Software Engineering, 18(11):957–968,
Nov. 1992. Depth.
[15] D. Erni. Codemap—improving the mental model of
software developers through cartographic visualization.
Master’s thesis, University of Bern, Jan. 2010.
[16] M. A. Hearst. Search User Interfaces. Cambridge
University Press, 1 edition, September 2009.
[17] M. Kersten and G. C. Murphy. Mylar: a degree-of-interest
model for ides. AOSD 2005, pages 159–168, New York, NY,
USA, 2005. ACM Press.
[18] A. J. Ko and B. A. Myers. Designing the whyline: a
debugging interface for asking questions about program
behavior. 2004 conference on Human factors in computing
systems, pages 151–158. ACM Press, 2004.
[19] A. Kuhn, S. Ducasse, and T. Gı̂rba. Semantic clustering:
Identifying topics in source code. Information and Software
Technology, 49(3):230–243, Mar. 2007.
[20] A. Kuhn, D. Erni, P. Loretan, and O. Nierstrasz. Software
cartography: Thematic software visualization with
consistent layout. Journal of Software Maintenance and
Evolution (JSME), 22(3):191–210, Apr. 2010.
[21] A. Kuhn, P. Loretan, and O. Nierstrasz. Consistent layout
for thematic software maps. WCRE 2008, pages 209–218,
Los Alamitos CA, Oct. 2008. IEEE Computer Society
Press.
[22] A. Kuhn, B. V. Rompaey, L. Hänsenberger, O. Nierstrasz,
S. Demeyer, M. Gaelli, and K. V. Leemput. JExample:
Exploiting dependencies between tests to improve defect
localization. In P. Abrahamsson, editor, Extreme
Programming and Agile Processes in Software Engineering,
9th International Conference, XP 2008, Lecture Notes in
Computer Science, pages 73–82. Springer, 2008.
[23] M. Lanza and R. Marinescu. Object-Oriented Metrics in
Practice. Springer-Verlag, 2006.
[24] A. A. Martinez, J. D. Cosin, and C. P. Garcia. A metro
map metaphor for visualization of software projects. SoftVis
2008, pages 199–200, New York, NY, USA, 2008. ACM.
[25] J. Nielsen. Usability Engineering. Morgan Kaufmann, 1st
edition, Sept. 1993.
[26] O. Nierstrasz, S. Ducasse, and T. Gı̂rba. The story of
Moose: an agile reengineering environment. ESEC/FSE
2005, pages 1–10, New York NY, 2005. ACM Press. Invited
paper.
[27] A. Noack and C. Lewerentz. A space of layout styles for
hierarchical graph models of software systems. SoftVis
2005, pages 155–164, New York, NY, USA, 2005. ACM.
[28] C. O’Reilly, D. Bustard, and P. Morrow. The war room
command console — shared visualizations for inclusive
team coordination. Softviz 2005, pages 57–65, St. Louis,
Missouri, USA, May 2005.
[29] A. Orso, J. Jones, and M. J. Harrold. Visualization of
program-execution data for deployed software. SoftVis
2003, pages 67–ff, New York, NY, USA, 2003. ACM.
[30] D. Phan, L. Xiao, R. B. Yeh, P. Hanrahan, and
T. Winograd. Flow map layout. INFOVIS 2005, page 29,
2005.
[31] D. Poshyvanyk and A. Marcus. Combining formal concept
analysis with information retrieval for concept location in
source code. ICPC 2007, pages 37–48, Washington, DC,
USA, 2007. IEEE Computer Society.
[32] S. P. Reiss. JOVE: Java as it happens. SoftVis 2005, pages
115–124, 2005.
[33] M. Sensalire, P. Ogao, and A. Telea. Classifying desirable
features of software visualization tools for corrective
maintenance. SoftVis 2008, pages 87–90, New York, NY,
USA, 2008. ACM.
[34] T. A. Slocum, R. B. McMaster, F. C. Kessler, and H. H.
Howard. Thematic Carthography and Geographic
Visualization. Pearson Prentice Hall, Upper Saddle River,
New Jersey, 2005.
[35] F. Steinbrückner. Layout stability of software cities.
http://seal.ifi.uzh.ch/uploads/media/16_frank_
steinbrueckner.pdf.
[36] M.-A. D. Storey, D. Čubranić, and D. M. German. On the
use of visualization to support awareness of human
activities in software development: a survey and a
framework. SoftVis 2005, pages 193–202. ACM Press, 2005.
[37] A. Telea and L. Voinea. An interactive reverse engineering
environment for large-scale c++ code. SoftVis 2008, pages
67–76, New York, NY, USA, 2008. ACM.
[38] J. B. Tenenbaum, V. Silva, and J. C. Langford. A global
geometric framework for nonlinear dimensionality
reduction. Science, 290(5500):2319–2323, Dec. 2000.
[39] R. Wettel and M. Lanza. Visual exploration of large-scale
system evolution. Softvis 2008, pages 155 – 164. IEEE CS
Press, 2008.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.169816">
<title confidence="0.9991105">Embedding Spatial Software Visualization in the IDE: an Exploratory Study</title>
<author confidence="0.999995">Adrian Kuhn</author>
<affiliation confidence="0.99992">Software Composition Group University of Bern</affiliation>
<email confidence="0.997412">akuhn@iam.unibe.com</email>
<author confidence="0.999903">David Erni</author>
<affiliation confidence="0.999848">Software Composition Group University of Bern</affiliation>
<email confidence="0.9989">deif@students.unibe.com</email>
<author confidence="0.991969">Oscar Nierstrasz</author>
<affiliation confidence="0.999709">Software Composition Group University of Bern</affiliation>
<email confidence="0.998733">oscar@iam.unibe.com</email>
<abstract confidence="0.999826722222222">Software visualization can be of great use for understanding and exploring a software system in an intuitive manner. Spatial representation of software is a promising approach of increasing interest. However, little is known about how developers interact with spatial visualizations that are embedded in the IDE. In this paper, we present a pilot study that explores the use of Software Cartography for program comprehension of an unknown system. We investigated whether developers establish a spatial memory of the system, whether clustering by topic offers a sound base layout, and how developers interact with maps. We report our results in the form of observations, hypotheses, and implications. Key findings are a) that developers made good use of the map to inspect search results and call graphs, and b) that developers found the base layout surprising and often confusing. We conclude with concrete advice for the design of embedded software maps.</abstract>
<title confidence="0.85349875">Categories and Subject Descriptors D.2.6 [Software Engineering]: Programming Environments General Terms Human Factors</title>
<keyword confidence="0.378569">Keywords Software Development Tools, Software Cartography, Spatial</keyword>
<intro confidence="0.580281">Software Representation, User Study</intro>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="true">
<authors>
<author>Project No</author>
</authors>
<date>2000</date>
<pages>10</pages>
<publisher>REFERENCES</publisher>
<marker>No, 2000</marker>
<rawString> Project No. 200020-121594, Oct. 2008–Sept. 2010). 10. REFERENCES</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Antoniol</author>
<author>Y-G Gueheneuc</author>
<author>E Merlo</author>
<author>P Tonella</author>
</authors>
<title>Mining the lexicon used by programmers during sofware evolution. ICSM</title>
<date>2007</date>
<pages>14--23</pages>
<contexts>
<context position="7857" citStr="[1]" startWordPosition="1262" endWordPosition="1262">lug-in is installed) test coverage information. More information can be added through an plugin extension point. • Social awareness of collaboration in the development team. Codemap can connect two or more Eclipse instances to show open files of other developers. Colored icons are used to show the currently open files of all developers. Icons are colored by user and updated in real time. • Understand a software system’s domain. The layout of Codemap is based on clustering software by topic [19], as it has been shown that, over time, the lexicon of source code is more stable than its structure [1]. Labels on the map are not limited to class names, but include automatically retrieved keywords and topics. • Exploring a system during reverse engineering. Codemap is integrated with Eclipse’s structural navigation 1http://scg.unibe.ch/codemap Figure 1: Thematic codemap of a software system. Here the Codemap tool itself is shown. Arrow edges show incoming calls to the #getSettingOrDefault method in the MenuAction class, which is currently active in the editor and thus labeled with a pop-up. features, such as search for callers, implementers, and references. Arrows are shown for search result</context>
</contexts>
<marker>[1]</marker>
<rawString>G. Antoniol, Y.-G. Gueheneuc, E. Merlo, and P. Tonella. Mining the lexicon used by programmers during sofware evolution. ICSM 2007, pages 14–23, Oct. 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>H Beyer</author>
<author>K Holtzblatt</author>
</authors>
<title>Contextual Design: Defining Customer-Centered Systems (Interactive Technologies).</title>
<date>1997</date>
<publisher>Morgan Kaufmann,</publisher>
<note>1st edition,</note>
<contexts>
<context position="16664" citStr="[2]" startWordPosition="2726" endWordPosition="2726">ny layout or diagram language whatsoever) of how they would explain the system under study to another developer. We asked the participants for feedback regarding their use of the Codemap plugin and how the plugin could be improved. 5. DATA COLLECTION We asked the participants to think aloud, and recorded their voice together with a captured video of their computer screen using the Camtasia software3. We reminded the participants to think aloud whenever they fell silent: we told them to imagine a junior programmer sitting beside them to whom they are to explain their actions (Master/Apprentice [2]). The participants were asked to respond to a survey while performing the study. The survey consisted of their answers to the tasks, as well as the perceived difficulty of 2http://twitter.com/codemap 3http://www.techsmith.com/camtasia the tasks and whether they found the Codemap plugin useful for the task at hand. We used a combination of semantic differential statements and Likert scales with a 5 point scale. We measured whether or not subjects were successful in completing a programming task. We used three success levels to measure the success and failure of tasks: a task could be a success</context>
</contexts>
<marker>[2]</marker>
<rawString>H. Beyer and K. Holtzblatt. Contextual Design: Defining Customer-Centered Systems (Interactive Technologies). Morgan Kaufmann, 1st edition, September 1997.</rawString>
</citation>
<citation valid="true">
<authors>
<author>G Booch</author>
</authors>
<title>Object Oriented Analysis and Design with Applications.</title>
<date>1994</date>
<booktitle>The Benjamin Cummings Publishing Co. Inc., 2nd edition,</booktitle>
<contexts>
<context position="20200" citStr="[3]" startWordPosition="3301" endWordPosition="3301">in, but also on those interaction sequences that challenged our assumptions about how developers would make use of the plug-in. The presentation of results is structured as follows. First, we briefly cover how each task was solved. Then present an in-depth analysis of our observations, structured by triples of observation, hypothesis, and implication. Implications are directed at improving the design and usability of spatial visualizations that are embedded in an IDE. 6.1 Task Performance Task 1, Domain and Collaborators. Participants used an approach best described as a“reverse Booch method” [3]. Given a two-sentence description of the system that we’ve provided, they searched for nouns and verbs using Eclipse’s full text search. Most participants used Codemap to assess quantity and dispersion of search results, and also to directly select and inspect large classes. Then they looked at the class names of the matches to learn about the domain and collaborators of the system. Students also read source code, whereas professional participants limited their investigation to using the package explorer and class outline. Task 2, Technologies. This task showed the most uniform behavior from </context>
</contexts>
<marker>[3]</marker>
<rawString>G. Booch. Object Oriented Analysis and Design with Applications. The Benjamin Cummings Publishing Co. Inc., 2nd edition, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>I Borg</author>
<author>P J F Groenen</author>
</authors>
<title>Modern Multidimensional Scaling: Theory and Applications.</title>
<date>2005</date>
<publisher>Springer,</publisher>
<contexts>
<context position="9065" citStr="[4]" startWordPosition="1450" endWordPosition="1450"> apply the Flow Map algorithm [30] to avoid visual clutter by merging parallel arrow edges. Figure 1 shows the result of searching for calls to the #getSettingOrDefault method in the MenuAction class . 3. THE CODEMAP ALGORITHM Figure 2 illustrates the construction of a software map. The sequence of the construction is basically the same as presented in previous work [21, 20]. 2-Dimensional Embedding. A distance metric is used to compute the pair-wise dissimilarity of software artifacts (typically source code files). A combination of the Isomap algorithm [38] and Multidimensional Scaling (MDS) [4] is used to embed all software artifacts into the visualization pane. The application of Isomap is an improvement over previous work in order to assist MDS with the global layout. In contrast to our previous work, Latent Semantic Indexing (LSI) is not applied anymore, it has been found to have little impact on the final embedding. Digital Elevation Model. In the next step, a digital elevation model is created. Each software artifact contributes a Gaussian shaped basis function to the elevation model according to its KLOC size. The contributions of all software artifacts are summed up and norma</context>
</contexts>
<marker>[4]</marker>
<rawString>I. Borg and P. J. F. Groenen. Modern Multidimensional Scaling: Theory and Applications. Springer, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Bragdon</author>
<author>S P Reiss</author>
<author>R Zeleznik</author>
<author>S Karumuri</author>
<author>W Cheung</author>
<author>J Kaplan</author>
<author>C Coleman</author>
<author>F Adeputra</author>
<author>J J L Jr</author>
</authors>
<title>Code bubbles: Rethinking the user interface paradigm of integrated development environments. ICSE</title>
<date>2010</date>
<publisher>ACM,</publisher>
<contexts>
<context position="3263" citStr="[39, 11, 5, 35, 24, 27]" startWordPosition="491" endWordPosition="496"> environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of the software system. Developers may use spatial memory to recall the location of software artifacts, and to put thematic map overlays in relation with each other [20]. The scenario of our user study is first contact with an unknown closed-source system. Our main question was whether and how developers make use of the embedded visualization and if our initial </context>
<context position="29090" citStr="[5]" startWordPosition="4738" endWordPosition="4738">rthermore, they do so even without visual aids, since they use spatial terms and thinking even before being asked to draw a diagram of the system’s architecture. Implication 6.1: Developers should be able to arrange the layout according to their mental model. This has implications on the design of a system’s spatial visualization. Developers should be able to arrange the layout according to their mental model. Developers should be able to drag and move parts of the map around as they wish, rather than having to stick with the automatically established layout. Code Canvas [11] and Code Bubbles [5] both already address this implication. In those tools, the user may drag individual elements around and arrange them according to his mental model. We observed that developers referred to architectural components, but not classes, in spatial terms. The needs of developers might thus be even better served by providing them more high-level means of arranging the map. Our next prototype will use anchored multidimensional scaling such that developers may initialize the map to their mental model. Anchored MDS allows the developer to define anchors which influence the layout of the map [6, Sec 4.4]</context>
<context position="43563" citStr="[5]" startWordPosition="7121" endWordPosition="7121">sults. A user study is not yet available. Cherubini, Venolia et al. studied how developers use spatial representation of their code [7]. They asked a team to set up a wall-sized spatial map of their system, and observed them for three weeks. They found that developers use horizontal rows to lay out diagrams by layers, and vertical columns to group it by domain topic. These are the same two spatial decompositions we found in our study, i.e., conceptual and structural. Also, they found that developers put utility classes aside, just as our study revealed. CodeBubbles by Bragdon and Reiss et al. [5] breaks code into method fragments (called bubbles) and allows developers to arrange the code fragments spatially on a larger-thanscreen map. Fragments do not overlap, and can be grouped into persistent working sets. The authors had been running a pilot study and reported that developers did not express concern over the absence of files, but rather felt that bubbles offer better editing. And further, that developers felt that spatial representation was very close to what is needed for visual explanation. CodeBubbles differs from our approach in a fundamental aspect: developers create the spati</context>
</contexts>
<marker>[5]</marker>
<rawString>A. Bragdon, S. P. Reiss, R. Zeleznik, S. Karumuri, W. Cheung, J. Kaplan, C. Coleman, F. Adeputra, and J. J. L. Jr. Code bubbles: Rethinking the user interface paradigm of integrated development environments. ICSE (2010). ACM, 2010.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Buja</author>
<author>D F Swayne</author>
<author>M L Littman</author>
<author>N Dean</author>
<author>H Hofmann</author>
<author>L Chen</author>
</authors>
<title>Data visualization with multidimensional scaling.</title>
<date>2008</date>
<journal>Journal of Computational and Graphical Statistics,</journal>
<volume>17</volume>
<issue>2</issue>
<marker>[6]</marker>
<rawString>A. Buja, D. F. Swayne, M. L. Littman, N. Dean, H. Hofmann, and L. Chen. Data visualization with multidimensional scaling. Journal of Computational and Graphical Statistics, 17(2):444–472, June 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Cherubini</author>
<author>G Venolia</author>
<author>R DeLine</author>
<author>A J Ko</author>
</authors>
<title>Let’s go to the whiteboard: how and why software developers use drawings.</title>
<date>2007</date>
<journal>CHI</journal>
<volume>07</volume>
<pages>557--566</pages>
<publisher>ACM.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="42565" citStr="[11, 7, 9, 10]" startWordPosition="6946" endWordPosition="6949">learn learn about the reactions of users. Such pilot studies are typically used as feedback for further iteration of the tool and to assess the usefulness of its application [25]. 8. RELATED WORK In this section we discuss related tools and user studies. We selected tools that embed a spatial visualization of software in the IDE, and user studies that study how developers navigate in the IDE as well as studies of tools that group software artifacts by topic rather than structure. Most closely related to the spatial approach studied in this paper is the work on spatial representation by DeLine [11, 7, 9, 10]. CodeCanvas by DeLine and Rowan [11] is a zoomable source editor that drops levels of details as you zoom out, up to the level of a UML diagram. CodeCanvas allows developers to rearrange the layout, to tear classes apart into smaller parts, and to filter by working sets and stack traces. CodeCanvas features two thematic maps, an interactive visualization of debug traces and spatial search results. A user study is not yet available. Cherubini, Venolia et al. studied how developers use spatial representation of their code [7]. They asked a team to set up a wall-sized spatial map of their system</context>
</contexts>
<marker>[7]</marker>
<rawString>M. Cherubini, G. Venolia, R. DeLine, and A. J. Ko. Let’s go to the whiteboard: how and why software developers use drawings. CHI ’07, pages 557–566, New York, NY, USA, 2007. ACM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>W De Pauw</author>
<author>H Andrade</author>
<author>L Amini</author>
</authors>
<title>Streamsight: a visualization tool for large-scale streaming applications. SoftVis</title>
<date>2008</date>
<pages>125--134</pages>
<publisher>ACM.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="1902" citStr="[37, 8, 32, 29]" startWordPosition="275" endWordPosition="278">ries and Subject Descriptors D.2.6 [Software Engineering]: Programming Environments General Terms Human Factors Keywords Software Development Tools, Software Cartography, Spatial Software Representation, User Study 1. INTRODUCTION Software visualization can be of great use for understanding and exploring a software system in an intuitive manner. In the past decade the software visualization community has developed a rich wealth of visualization approaches [12] and provided evidence of their usefulness for expert tasks, such as reverse engineering, release management or dynamic analysis (e.g., [37, 8, 32, 29]). Typically, these visualization Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SOFTVIS’10, October 25–26, 2010, Salt Lake City, Utah, USA. Copyright 2010 ACM 978-1-4503-0028-5/10/10 ...$10.00. approaches had been implemented in intera</context>
</contexts>
<marker>[8]</marker>
<rawString>W. De Pauw, H. Andrade, and L. Amini. Streamsight: a visualization tool for large-scale streaming applications. SoftVis 2008, pages 125–134, New York, NY, USA, 2008. ACM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R DeLine</author>
<author>M Czerwinski</author>
<author>B Meyers</author>
<author>G Venolia</author>
<author>S M Drucker</author>
<author>G G Robertson</author>
</authors>
<title>Code thumbnails: Using spatial memory to navigate source code. VL/HCC,</title>
<date>2006</date>
<pages>11--18</pages>
<contexts>
<context position="42565" citStr="[11, 7, 9, 10]" startWordPosition="6946" endWordPosition="6949">learn learn about the reactions of users. Such pilot studies are typically used as feedback for further iteration of the tool and to assess the usefulness of its application [25]. 8. RELATED WORK In this section we discuss related tools and user studies. We selected tools that embed a spatial visualization of software in the IDE, and user studies that study how developers navigate in the IDE as well as studies of tools that group software artifacts by topic rather than structure. Most closely related to the spatial approach studied in this paper is the work on spatial representation by DeLine [11, 7, 9, 10]. CodeCanvas by DeLine and Rowan [11] is a zoomable source editor that drops levels of details as you zoom out, up to the level of a UML diagram. CodeCanvas allows developers to rearrange the layout, to tear classes apart into smaller parts, and to filter by working sets and stack traces. CodeCanvas features two thematic maps, an interactive visualization of debug traces and spatial search results. A user study is not yet available. Cherubini, Venolia et al. studied how developers use spatial representation of their code [7]. They asked a team to set up a wall-sized spatial map of their system</context>
<context position="45285" citStr="[9]" startWordPosition="7395" endWordPosition="7395">ks by Deline, Czerwinski and Robertson [10] assists developers using collaborative filtering of navigation history. They ran a user study where professional developers had to fix bugs. Developers that used TeamTracks showed better task completion. Moreover, they found that performance was better for locally focused features rather widely disperse features. This issue is addressed on our tool where we give visual evidence of quantity and dispersion of search results and call graphs, of which participants made good use in the feature location task. CodeThumbnails by DeLine and Czerwinski et al. [9] embeds a global navigation map in the IDE. The map consists of a zoomed-out view of the source code text, similar to Eick’s Seesoft [14]. In a user study they found that developers quickly established a spatial memory of the system. Results from our study confirm this observation. Mylar (now known as Mylyn) by Kersten and Murphy [17] integrates a degree-of-interest (DOI) model in the IDE. Mylyn extends the IDE with a task view, and maintains a DOI model per task. Developers can this model to filter views by working set. This is similar to the clustering by topic on our spatial map, elements a</context>
</contexts>
<marker>[9]</marker>
<rawString>R. DeLine, M. Czerwinski, B. Meyers, G. Venolia, S. M. Drucker, and G. G. Robertson. Code thumbnails: Using spatial memory to navigate source code. VL/HCC, pages 11–18, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R DeLine</author>
<author>A Khella</author>
<author>M Czerwinski</author>
<author>G G Robertson</author>
</authors>
<title>Towards understanding programs through wear-based filtering. SOFTVIS</title>
<date>2005</date>
<pages>183--192</pages>
<contexts>
<context position="42565" citStr="[11, 7, 9, 10]" startWordPosition="6946" endWordPosition="6949">learn learn about the reactions of users. Such pilot studies are typically used as feedback for further iteration of the tool and to assess the usefulness of its application [25]. 8. RELATED WORK In this section we discuss related tools and user studies. We selected tools that embed a spatial visualization of software in the IDE, and user studies that study how developers navigate in the IDE as well as studies of tools that group software artifacts by topic rather than structure. Most closely related to the spatial approach studied in this paper is the work on spatial representation by DeLine [11, 7, 9, 10]. CodeCanvas by DeLine and Rowan [11] is a zoomable source editor that drops levels of details as you zoom out, up to the level of a UML diagram. CodeCanvas allows developers to rearrange the layout, to tear classes apart into smaller parts, and to filter by working sets and stack traces. CodeCanvas features two thematic maps, an interactive visualization of debug traces and spatial search results. A user study is not yet available. Cherubini, Venolia et al. studied how developers use spatial representation of their code [7]. They asked a team to set up a wall-sized spatial map of their system</context>
<context position="44725" citStr="[10]" startWordPosition="7309" endWordPosition="7309">mental aspect: developers create the spatial layout themselves as they add methods to the current working set. As a consequence there are as many spatial layouts of the system as there are working sets. By contrast our Codemap plugin, as well as the CodeCanvas tool of DeLine [11], relies on one global layout for all programming tasks. In our present study we observed that some developers maintained more than one spatial model of the same system (one conceptual, one structural), we consider it thus promising future work to combine both approaches. TeamTracks by Deline, Czerwinski and Robertson [10] assists developers using collaborative filtering of navigation history. They ran a user study where professional developers had to fix bugs. Developers that used TeamTracks showed better task completion. Moreover, they found that performance was better for locally focused features rather widely disperse features. This issue is addressed on our tool where we give visual evidence of quantity and dispersion of search results and call graphs, of which participants made good use in the feature location task. CodeThumbnails by DeLine and Czerwinski et al. [9] embeds a global navigation map in the I</context>
</contexts>
<marker>[10]</marker>
<rawString>R. DeLine, A. Khella, M. Czerwinski, and G. G. Robertson. Towards understanding programs through wear-based filtering. SOFTVIS 2005, pages 183–192, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R DeLine</author>
<author>K Rowan</author>
</authors>
<title>Code canvas: Zooming towards better development environments.</title>
<date>2010</date>
<journal>ICSE (NIER track)</journal>
<publisher>ACM,</publisher>
<contexts>
<context position="3263" citStr="[39, 11, 5, 35, 24, 27]" startWordPosition="491" endWordPosition="496"> environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of the software system. Developers may use spatial memory to recall the location of software artifacts, and to put thematic map overlays in relation with each other [20]. The scenario of our user study is first contact with an unknown closed-source system. Our main question was whether and how developers make use of the embedded visualization and if our initial </context>
<context position="29069" citStr="[11]" startWordPosition="4734" endWordPosition="4734">hey work with code. Furthermore, they do so even without visual aids, since they use spatial terms and thinking even before being asked to draw a diagram of the system’s architecture. Implication 6.1: Developers should be able to arrange the layout according to their mental model. This has implications on the design of a system’s spatial visualization. Developers should be able to arrange the layout according to their mental model. Developers should be able to drag and move parts of the map around as they wish, rather than having to stick with the automatically established layout. Code Canvas [11] and Code Bubbles [5] both already address this implication. In those tools, the user may drag individual elements around and arrange them according to his mental model. We observed that developers referred to architectural components, but not classes, in spatial terms. The needs of developers might thus be even better served by providing them more high-level means of arranging the map. Our next prototype will use anchored multidimensional scaling such that developers may initialize the map to their mental model. Anchored MDS allows the developer to define anchors which influence the layout of</context>
<context position="37031" citStr="[11]" startWordPosition="6040" endWordPosition="6040">’s layout should be such that all elements are easily discernable and easy to click. Real estate on a computer screen is limited, and even more so in an IDE with all its views and panels. As tool builders we have limited space available for an embedded visualization. Given our goal of establishing a global layout we face the challenge of having to visualize all elements of a system in that very limited space. The current implementation of Codemap has one level of scale only, which may yield crowded clusters where elements are placed just pixels apart. A zoomable map as provided by Code Canvas [11] addresses this issue. The fact that we are attracted by elements that visually detach from other has two impacts: one is that we tend to look at isolated elements as being of low significance, the other being that it is hard to identify elements in the cluster. These impacts are very different, but can both be addressed in a common way. For instance, a threshold could be used to not show isolated elements at all, but only significant clusters. Alternatively, colors may be used to display isolated elements so that they do not draw our attention so readily. Observation 6.5: Participants used Co</context>
<context position="42565" citStr="[11, 7, 9, 10]" startWordPosition="6946" endWordPosition="6949">learn learn about the reactions of users. Such pilot studies are typically used as feedback for further iteration of the tool and to assess the usefulness of its application [25]. 8. RELATED WORK In this section we discuss related tools and user studies. We selected tools that embed a spatial visualization of software in the IDE, and user studies that study how developers navigate in the IDE as well as studies of tools that group software artifacts by topic rather than structure. Most closely related to the spatial approach studied in this paper is the work on spatial representation by DeLine [11, 7, 9, 10]. CodeCanvas by DeLine and Rowan [11] is a zoomable source editor that drops levels of details as you zoom out, up to the level of a UML diagram. CodeCanvas allows developers to rearrange the layout, to tear classes apart into smaller parts, and to filter by working sets and stack traces. CodeCanvas features two thematic maps, an interactive visualization of debug traces and spatial search results. A user study is not yet available. Cherubini, Venolia et al. studied how developers use spatial representation of their code [7]. They asked a team to set up a wall-sized spatial map of their system</context>
<context position="44401" citStr="[11]" startWordPosition="7259" endWordPosition="7259">een running a pilot study and reported that developers did not express concern over the absence of files, but rather felt that bubbles offer better editing. And further, that developers felt that spatial representation was very close to what is needed for visual explanation. CodeBubbles differs from our approach in a fundamental aspect: developers create the spatial layout themselves as they add methods to the current working set. As a consequence there are as many spatial layouts of the system as there are working sets. By contrast our Codemap plugin, as well as the CodeCanvas tool of DeLine [11], relies on one global layout for all programming tasks. In our present study we observed that some developers maintained more than one spatial model of the same system (one conceptual, one structural), we consider it thus promising future work to combine both approaches. TeamTracks by Deline, Czerwinski and Robertson [10] assists developers using collaborative filtering of navigation history. They ran a user study where professional developers had to fix bugs. Developers that used TeamTracks showed better task completion. Moreover, they found that performance was better for locally focused fe</context>
</contexts>
<marker>[11]</marker>
<rawString>R. DeLine and K. Rowan. Code canvas: Zooming towards better development environments. ICSE (NIER track) 2010. ACM, 2010.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Diehl</author>
</authors>
<title>Software Visualization.</title>
<date>2007</date>
<publisher>Springer-Verlag,</publisher>
<location>Berlin Heidelberg,</location>
<contexts>
<context position="1751" citStr="[12]" startWordPosition="254" endWordPosition="254">pers found the base layout surprising and often confusing. We conclude with concrete advice for the design of embedded software maps. Categories and Subject Descriptors D.2.6 [Software Engineering]: Programming Environments General Terms Human Factors Keywords Software Development Tools, Software Cartography, Spatial Software Representation, User Study 1. INTRODUCTION Software visualization can be of great use for understanding and exploring a software system in an intuitive manner. In the past decade the software visualization community has developed a rich wealth of visualization approaches [12] and provided evidence of their usefulness for expert tasks, such as reverse engineering, release management or dynamic analysis (e.g., [37, 8, 32, 29]). Typically, these visualization Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SOFT</context>
</contexts>
<marker>[12]</marker>
<rawString>S. Diehl. Software Visualization. Springer-Verlag, Berlin Heidelberg, 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S Ducasse</author>
<author>D Pollet</author>
</authors>
<title>Software architecture reconstruction: A process-oriented taxonomy.</title>
<date>2009</date>
<journal>IEEE Transactions on Software Engineering,</journal>
<volume>35</volume>
<issue>4</issue>
<contexts>
<context position="38894" citStr="[26, 19, 13]" startWordPosition="6343" endWordPosition="6345">Most of them reacted surprised or confused when for example the classes of a package were not mostly in the same place. For example, Participant S reported in the wrap-up, “this is a very useful tool but the layout does not make sense”. Another participant stated during task 3 (i.e., the architecture recovery) with confusion that “the classes contained in packages are scattered on the map, it is not obvious what their spatial connection is.” Hypothesis 6.5: From the developers view, the predominant mental decomposition of a system is package structure. Given our reverse engineering background [26, 19, 13] we had come to distrust package decomposition, however it seems that developers like to rely on the packaging that other developers have made when designing the system. One problem raised by research in re-packaging legacy systems is that packages play too many roles: as distribution units, as units of namespacing, as working sets, as topics, as unit of architectural components, etc. However, as an opposing point of view, we can relate packaging to the folksonomies of the Web 2.0, where users label elements with unstructured tags that are then exploited by other users to search for elements. </context>
</contexts>
<marker>[13]</marker>
<rawString>S. Ducasse and D. Pollet. Software architecture reconstruction: A process-oriented taxonomy. IEEE Transactions on Software Engineering, 35(4):573–591, July 2009.</rawString>
</citation>
<citation valid="true">
<authors>
<author>S G Eick</author>
<author>J L Steffen</author>
<author>S Eric E</author>
</authors>
<title>SeeSoft—a tool for visualizing line oriented software statistics.</title>
<date>1992</date>
<journal>IEEE Transactions on Software Engineering,</journal>
<volume>18</volume>
<issue>11</issue>
<publisher>Depth.</publisher>
<contexts>
<context position="45422" citStr="[14]" startWordPosition="7421" endWordPosition="7421">y where professional developers had to fix bugs. Developers that used TeamTracks showed better task completion. Moreover, they found that performance was better for locally focused features rather widely disperse features. This issue is addressed on our tool where we give visual evidence of quantity and dispersion of search results and call graphs, of which participants made good use in the feature location task. CodeThumbnails by DeLine and Czerwinski et al. [9] embeds a global navigation map in the IDE. The map consists of a zoomed-out view of the source code text, similar to Eick’s Seesoft [14]. In a user study they found that developers quickly established a spatial memory of the system. Results from our study confirm this observation. Mylar (now known as Mylyn) by Kersten and Murphy [17] integrates a degree-of-interest (DOI) model in the IDE. Mylyn extends the IDE with a task view, and maintains a DOI model per task. Developers can this model to filter views by working set. This is similar to the clustering by topic on our spatial map, elements are grouped by conceptual rather than structural relation. They measured the approach in a user study and report an 15% productivity impro</context>
</contexts>
<marker>[14]</marker>
<rawString>S. G. Eick, J. L. Steffen, and S. Eric E., Jr. SeeSoft—a tool for visualizing line oriented software statistics. IEEE Transactions on Software Engineering, 18(11):957–968, Nov. 1992. Depth.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Erni</author>
</authors>
<title>Codemap—improving the mental model of software developers through cartographic visualization. Master’s thesis,</title>
<date>2010</date>
<institution>University of Bern,</institution>
<contexts>
<context position="3150" citStr="[22, 20, 15]" startWordPosition="475" endWordPosition="477">ese tools are stand-alone prototypes that have never been integrated in an IDE (integrated development environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of the software system. Developers may use spatial memory to recall the location of software artifacts, and to put thematic map overlays in relation with each other [20]. The scenario of our user study is first contact with an unknown closed-source sy</context>
<context position="46809" citStr="[22, 15, 20]" startWordPosition="7649" endWordPosition="7651">d software visualization for team coordination. The system highlights individual team efforts by combining system structure and ongoing developer activity in order to report progress to management. They did a survey, and found that users felt the system was useful but found it hard to translate between viewpoints using the given spatial layout. Based on that, they propose a set of visualization techniques to overcome this limitation. 9. CONCLUSION In this paper we presented an evaluation of spatial software visualization in the IDE. We embedded a prototype of the Software Cartography approach [22, 15, 20], the Codemap plug-in, in the Eclipse IDE and ran an exploratory user study which included both students and professionals. Software maps are supposed to help developers with a visual representation of their software systems that addresses their spatial thinking and memory. The scenario of our user study was first contact with an unknown closed-source system. Results were as follows: • Participants made good us of the map to inspect search results and call graph, they reported that the spatial visualization provided them with an immediate estimate of quantity and dispersion of search results. </context>
</contexts>
<marker>[15]</marker>
<rawString>D. Erni. Codemap—improving the mental model of software developers through cartographic visualization. Master’s thesis, University of Bern, Jan. 2010.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M A Hearst</author>
</authors>
<title>Search User Interfaces.</title>
<date>2009</date>
<volume>1</volume>
<pages>edition,</pages>
<publisher>Cambridge University Press,</publisher>
<contexts>
<context position="32707" citStr="[16]" startWordPosition="5321" endWordPosition="5321">ionals were more likely to inspect several results. One professional reported that he “inspected more results than usual, because the map shows them in their context and that this helps him to take a more informed choice on which results are worth inspection and which ones not.” Implication 6.2: Tools should put search results into a meaningful context, so developers can take both quicker and better-informed decisions. The need for better presentation of search results has implications beyond the design of spatial visualizations. Work on presentation of search results goes beyond spatial maps [16], for example results can be presented as a graph. Poshyvanyk and Marcus [31] have taken one such approach (representing search results as a lattice) and applied it to source code search with promising results. For our next prototype we plan to integrate search results into the package explorer view, just as is already done with compile errors (which are, from this point of view, just like the search results of a complex query that is run to find syntax errors). This planned feature addresses another implication of our study as well, as we have found that some developers establish a spatial me</context>
</contexts>
<marker>[16]</marker>
<rawString>M. A. Hearst. Search User Interfaces. Cambridge University Press, 1 edition, September 2009.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Kersten</author>
<author>G C Murphy</author>
</authors>
<title>Mylar: a degree-of-interest model for ides. AOSD</title>
<date>2005</date>
<pages>159--168</pages>
<publisher>ACM Press.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="45621" citStr="[17]" startWordPosition="7455" endWordPosition="7455">dely disperse features. This issue is addressed on our tool where we give visual evidence of quantity and dispersion of search results and call graphs, of which participants made good use in the feature location task. CodeThumbnails by DeLine and Czerwinski et al. [9] embeds a global navigation map in the IDE. The map consists of a zoomed-out view of the source code text, similar to Eick’s Seesoft [14]. In a user study they found that developers quickly established a spatial memory of the system. Results from our study confirm this observation. Mylar (now known as Mylyn) by Kersten and Murphy [17] integrates a degree-of-interest (DOI) model in the IDE. Mylyn extends the IDE with a task view, and maintains a DOI model per task. Developers can this model to filter views by working set. This is similar to the clustering by topic on our spatial map, elements are grouped by conceptual rather than structural relation. They measured the approach in a user study and report an 15% productivity improvement, measured as“the number of keystrokes in the editor over the number of selections made in editor and views.” War Room Command Console by O’Reilly et al. [28] is a shared software visualization</context>
</contexts>
<marker>[17]</marker>
<rawString>M. Kersten and G. C. Murphy. Mylar: a degree-of-interest model for ides. AOSD 2005, pages 159–168, New York, NY, USA, 2005. ACM Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A J Ko</author>
<author>B A Myers</author>
</authors>
<title>Designing the whyline: a debugging interface for asking questions about program behavior.</title>
<date>2004</date>
<pages>151--158</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="21468" citStr="[18]" startWordPosition="3505" endWordPosition="3505">uild path node and opened all included JAR libraries. Professional developers typically raised the concern that possibly not all of these libraries were (still) used and started to explore whether they were used. Typically they would carry out a search to do so, but one developer showed a very interesting pattern: He would remove the libary “on purpose” and then look for compile errors as an indicator of its use. Students seems to implicitly assume that all libraries were actually used, at least they never raised such a concern. We interpret this as a sign that professionals are more cautious [18] and thus more aware of the typical decay caused by software evolution, which may include dead libraries. Task 3, Architecture. Typically participants drilled-down with the package explorer and read all package names. All professionals started out by formulating the hypothesis of a layered three-tier architecture, and then start fitting the packages to the different layers. Most participants used Codemap to look at the dispersion of a package’s classes (when selecting a package in the package explorer, the contained classes are highlighted on the map). To learn about the architectural constrai</context>
</contexts>
<marker>[18]</marker>
<rawString>A. J. Ko and B. A. Myers. Designing the whyline: a debugging interface for asking questions about program behavior. 2004 conference on Human factors in computing systems, pages 151–158. ACM Press, 2004.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kuhn</author>
<author>S Ducasse</author>
<author>T Gırba</author>
</authors>
<title>Semantic clustering: Identifying topics in source code.</title>
<date>2007</date>
<booktitle>Information and Software Technology,</booktitle>
<volume>49</volume>
<issue>3</issue>
<contexts>
<context position="7753" citStr="[19]" startWordPosition="1242" endWordPosition="1242">ug density with code coverage. The map displays search results, compiler errors, and (given the Eclemma plug-in is installed) test coverage information. More information can be added through an plugin extension point. • Social awareness of collaboration in the development team. Codemap can connect two or more Eclipse instances to show open files of other developers. Colored icons are used to show the currently open files of all developers. Icons are colored by user and updated in real time. • Understand a software system’s domain. The layout of Codemap is based on clustering software by topic [19], as it has been shown that, over time, the lexicon of source code is more stable than its structure [1]. Labels on the map are not limited to class names, but include automatically retrieved keywords and topics. • Exploring a system during reverse engineering. Codemap is integrated with Eclipse’s structural navigation 1http://scg.unibe.ch/codemap Figure 1: Thematic codemap of a software system. Here the Codemap tool itself is shown. Arrow edges show incoming calls to the #getSettingOrDefault method in the MenuAction class, which is currently active in the editor and thus labeled with a pop-up</context>
<context position="38894" citStr="[26, 19, 13]" startWordPosition="6343" endWordPosition="6345">Most of them reacted surprised or confused when for example the classes of a package were not mostly in the same place. For example, Participant S reported in the wrap-up, “this is a very useful tool but the layout does not make sense”. Another participant stated during task 3 (i.e., the architecture recovery) with confusion that “the classes contained in packages are scattered on the map, it is not obvious what their spatial connection is.” Hypothesis 6.5: From the developers view, the predominant mental decomposition of a system is package structure. Given our reverse engineering background [26, 19, 13] we had come to distrust package decomposition, however it seems that developers like to rely on the packaging that other developers have made when designing the system. One problem raised by research in re-packaging legacy systems is that packages play too many roles: as distribution units, as units of namespacing, as working sets, as topics, as unit of architectural components, etc. However, as an opposing point of view, we can relate packaging to the folksonomies of the Web 2.0, where users label elements with unstructured tags that are then exploited by other users to search for elements. </context>
</contexts>
<marker>[19]</marker>
<rawString>A. Kuhn, S. Ducasse, and T. Gı̂rba. Semantic clustering: Identifying topics in source code. Information and Software Technology, 49(3):230–243, Mar. 2007.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kuhn</author>
<author>D Erni</author>
<author>P Loretan</author>
<author>O Nierstrasz</author>
</authors>
<title>Software cartography: Thematic software visualization with consistent layout.</title>
<date>2010</date>
<journal>Journal of Software Maintenance and Evolution (JSME),</journal>
<volume>22</volume>
<issue>3</issue>
<contexts>
<context position="3150" citStr="[22, 20, 15]" startWordPosition="475" endWordPosition="477">ese tools are stand-alone prototypes that have never been integrated in an IDE (integrated development environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of the software system. Developers may use spatial memory to recall the location of software artifacts, and to put thematic map overlays in relation with each other [20]. The scenario of our user study is first contact with an unknown closed-source sy</context>
<context position="8839" citStr="[21, 20]" startWordPosition="1416" endWordPosition="1417">getSettingOrDefault method in the MenuAction class, which is currently active in the editor and thus labeled with a pop-up. features, such as search for callers, implementers, and references. Arrows are shown for search results. We apply the Flow Map algorithm [30] to avoid visual clutter by merging parallel arrow edges. Figure 1 shows the result of searching for calls to the #getSettingOrDefault method in the MenuAction class . 3. THE CODEMAP ALGORITHM Figure 2 illustrates the construction of a software map. The sequence of the construction is basically the same as presented in previous work [21, 20]. 2-Dimensional Embedding. A distance metric is used to compute the pair-wise dissimilarity of software artifacts (typically source code files). A combination of the Isomap algorithm [38] and Multidimensional Scaling (MDS) [4] is used to embed all software artifacts into the visualization pane. The application of Isomap is an improvement over previous work in order to assist MDS with the global layout. In contrast to our previous work, Latent Semantic Indexing (LSI) is not applied anymore, it has been found to have little impact on the final embedding. Digital Elevation Model. In the next step</context>
<context position="10272" citStr="[21, 20]" startWordPosition="1648" endWordPosition="1649">alized. Figure 2: Construction steps of a software map, from left to right: 1) 2-dimensional embedding of files on the visualization pane; 2.a) circles around each file’s location, based on class size in KLOC; 2.b) each file contributes a Gaussian shaped basis function to the elevation model according to its KLOC size; the contributions of all files are summed up; 3) fully rendered map with hill-shading, contour lines, and filename labels. Cartographic rendering. In the final step, hill-shading is used to render the landscape of the software map. Please refer to previous work for full details [21, 20]. Metrics and markers are rendered in transparent layers on top of the landscape. Users can toggle separate layers on/off and thus customize the codemap display to their needs. 4. METHODOLOGY We evaluated our approach in a pilot study with professional developers and students. The scenario investigated by the experiment is first contact with an unknown software system. Participants have 90 minutes to solve 5 program comprehension tasks and to fix one bug report. After the experiment, participants are asked to sketch a drawing of their mental map of the system. Our goal for the present pilot st</context>
<context position="11503" citStr="[20]" startWordPosition="1850" endWordPosition="1850">usability of Codemap for program comprehension. We have been seeking to answer several questions. How can we support developers in establishing a spatial memory of software systems? How do we best support the developers spatial memory using software visualization? How to best embed spatial software visualization in the IDE? When provided with spatial representation of search results and call graphs, how do developers make use of them? Not covered in this study, and thus open for future user studies, are the shared team awareness and long term memory claims of the Software Cartography approach [20]. 4.1 Design of the Study The study consists of six programming tasks. The training task introduced the participants to the Codemap plugin. The first five tasks were program comprehension tasks, starting with general questions and then going into more and more detailed questions. Eventually, the last task was to fix an actual bug in the system. Participants were asked to use the map whenever they saw fit, but otherwise they were free to use any other feature of Eclipse they wanted. Task 1, Domain and Collaborators. “Find the purpose of the given application and identify the main collaborators.</context>
<context position="46809" citStr="[22, 15, 20]" startWordPosition="7649" endWordPosition="7651">d software visualization for team coordination. The system highlights individual team efforts by combining system structure and ongoing developer activity in order to report progress to management. They did a survey, and found that users felt the system was useful but found it hard to translate between viewpoints using the given spatial layout. Based on that, they propose a set of visualization techniques to overcome this limitation. 9. CONCLUSION In this paper we presented an evaluation of spatial software visualization in the IDE. We embedded a prototype of the Software Cartography approach [22, 15, 20], the Codemap plug-in, in the Eclipse IDE and ran an exploratory user study which included both students and professionals. Software maps are supposed to help developers with a visual representation of their software systems that addresses their spatial thinking and memory. The scenario of our user study was first contact with an unknown closed-source system. Results were as follows: • Participants made good us of the map to inspect search results and call graph, they reported that the spatial visualization provided them with an immediate estimate of quantity and dispersion of search results. </context>
</contexts>
<marker>[20]</marker>
<rawString>A. Kuhn, D. Erni, P. Loretan, and O. Nierstrasz. Software cartography: Thematic software visualization with consistent layout. Journal of Software Maintenance and Evolution (JSME), 22(3):191–210, Apr. 2010.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kuhn</author>
<author>P Loretan</author>
<author>O Nierstrasz</author>
</authors>
<title>Consistent layout for thematic software maps. WCRE</title>
<date>2008</date>
<pages>209--218</pages>
<publisher>IEEE Computer Society Press.</publisher>
<location>Los Alamitos CA,</location>
<contexts>
<context position="8839" citStr="[21, 20]" startWordPosition="1416" endWordPosition="1417">getSettingOrDefault method in the MenuAction class, which is currently active in the editor and thus labeled with a pop-up. features, such as search for callers, implementers, and references. Arrows are shown for search results. We apply the Flow Map algorithm [30] to avoid visual clutter by merging parallel arrow edges. Figure 1 shows the result of searching for calls to the #getSettingOrDefault method in the MenuAction class . 3. THE CODEMAP ALGORITHM Figure 2 illustrates the construction of a software map. The sequence of the construction is basically the same as presented in previous work [21, 20]. 2-Dimensional Embedding. A distance metric is used to compute the pair-wise dissimilarity of software artifacts (typically source code files). A combination of the Isomap algorithm [38] and Multidimensional Scaling (MDS) [4] is used to embed all software artifacts into the visualization pane. The application of Isomap is an improvement over previous work in order to assist MDS with the global layout. In contrast to our previous work, Latent Semantic Indexing (LSI) is not applied anymore, it has been found to have little impact on the final embedding. Digital Elevation Model. In the next step</context>
<context position="10272" citStr="[21, 20]" startWordPosition="1648" endWordPosition="1649">alized. Figure 2: Construction steps of a software map, from left to right: 1) 2-dimensional embedding of files on the visualization pane; 2.a) circles around each file’s location, based on class size in KLOC; 2.b) each file contributes a Gaussian shaped basis function to the elevation model according to its KLOC size; the contributions of all files are summed up; 3) fully rendered map with hill-shading, contour lines, and filename labels. Cartographic rendering. In the final step, hill-shading is used to render the landscape of the software map. Please refer to previous work for full details [21, 20]. Metrics and markers are rendered in transparent layers on top of the landscape. Users can toggle separate layers on/off and thus customize the codemap display to their needs. 4. METHODOLOGY We evaluated our approach in a pilot study with professional developers and students. The scenario investigated by the experiment is first contact with an unknown software system. Participants have 90 minutes to solve 5 program comprehension tasks and to fix one bug report. After the experiment, participants are asked to sketch a drawing of their mental map of the system. Our goal for the present pilot st</context>
</contexts>
<marker>[21]</marker>
<rawString>A. Kuhn, P. Loretan, and O. Nierstrasz. Consistent layout for thematic software maps. WCRE 2008, pages 209–218, Los Alamitos CA, Oct. 2008. IEEE Computer Society Press.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Kuhn</author>
<author>B V Rompaey</author>
<author>L Hansenberger</author>
<author>O Nierstrasz</author>
<author>S Demeyer</author>
<author>M Gaelli</author>
<author>K V Leemput</author>
</authors>
<title>JExample: Exploiting dependencies between tests to improve defect localization.</title>
<date>2008</date>
<booktitle>Extreme Programming and Agile Processes in Software Engineering, 9th International Conference, XP 2008, Lecture Notes in Computer Science,</booktitle>
<pages>73--82</pages>
<editor>In P. Abrahamsson, editor,</editor>
<publisher>Springer,</publisher>
<contexts>
<context position="3150" citStr="[22, 20, 15]" startWordPosition="475" endWordPosition="477">ese tools are stand-alone prototypes that have never been integrated in an IDE (integrated development environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of the software system. Developers may use spatial memory to recall the location of software artifacts, and to put thematic map overlays in relation with each other [20]. The scenario of our user study is first contact with an unknown closed-source sy</context>
<context position="46809" citStr="[22, 15, 20]" startWordPosition="7649" endWordPosition="7651">d software visualization for team coordination. The system highlights individual team efforts by combining system structure and ongoing developer activity in order to report progress to management. They did a survey, and found that users felt the system was useful but found it hard to translate between viewpoints using the given spatial layout. Based on that, they propose a set of visualization techniques to overcome this limitation. 9. CONCLUSION In this paper we presented an evaluation of spatial software visualization in the IDE. We embedded a prototype of the Software Cartography approach [22, 15, 20], the Codemap plug-in, in the Eclipse IDE and ran an exploratory user study which included both students and professionals. Software maps are supposed to help developers with a visual representation of their software systems that addresses their spatial thinking and memory. The scenario of our user study was first contact with an unknown closed-source system. Results were as follows: • Participants made good us of the map to inspect search results and call graph, they reported that the spatial visualization provided them with an immediate estimate of quantity and dispersion of search results. </context>
</contexts>
<marker>[22]</marker>
<rawString>A. Kuhn, B. V. Rompaey, L. Hänsenberger, O. Nierstrasz, S. Demeyer, M. Gaelli, and K. V. Leemput. JExample: Exploiting dependencies between tests to improve defect localization. In P. Abrahamsson, editor, Extreme Programming and Agile Processes in Software Engineering, 9th International Conference, XP 2008, Lecture Notes in Computer Science, pages 73–82. Springer, 2008.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Lanza</author>
<author>R Marinescu</author>
</authors>
<title>Object-Oriented Metrics in Practice.</title>
<date>2006</date>
<publisher>Springer-Verlag,</publisher>
<contexts>
<context position="13998" citStr="[23]" startWordPosition="2275" endWordPosition="2275"> search: the system compares the curriculum vitae of the users with stored searches of the companies and mails new matches to the companies.” Task 5, Code Assessment. “In this task we want to assess the code quality of the application. Please answer the following questions: a) what is the degree of test coverage? b) are there any god classes? c) are the classes organized in their proper packages? Should certain classes be moved to other packages? Please list two to three examples.” We provided a code coverage plug-in with the experiment, as well as a definition of what constitutes a god class [23]. Task 6, Bug Fixing. In this task we provided an actual bug report and asked “Describe how you would handle the bug report, that is how and where you would change the system and which classes are involved in the bug fix. You are not asked to actually fix the bug, but just to describe how you would fix it.” 4.2 Participant Selection Participants were selected through an open call for participation on Twitter2 as well as through flyers distributed at a local Eclipse event. Subjects were required to be medium level Java programmers with at least one year of experience with both Java and Eclipse </context>
</contexts>
<marker>[23]</marker>
<rawString>M. Lanza and R. Marinescu. Object-Oriented Metrics in Practice. Springer-Verlag, 2006.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A A Martinez</author>
<author>J D Cosin</author>
<author>C P Garcia</author>
</authors>
<title>A metro map metaphor for visualization of software projects. SoftVis</title>
<date>2008</date>
<pages>199--200</pages>
<publisher>ACM.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="3263" citStr="[39, 11, 5, 35, 24, 27]" startWordPosition="491" endWordPosition="496"> environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of the software system. Developers may use spatial memory to recall the location of software artifacts, and to put thematic map overlays in relation with each other [20]. The scenario of our user study is first contact with an unknown closed-source system. Our main question was whether and how developers make use of the embedded visualization and if our initial </context>
</contexts>
<marker>[24]</marker>
<rawString>A. A. Martinez, J. D. Cosin, and C. P. Garcia. A metro map metaphor for visualization of software projects. SoftVis 2008, pages 199–200, New York, NY, USA, 2008. ACM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J Nielsen</author>
</authors>
<title>Usability Engineering.</title>
<date></date>
<publisher>Morgan Kaufmann,</publisher>
<contexts>
<context position="42129" citStr="[25]" startWordPosition="6873" endWordPosition="6873">sibly violate the “Law of Demeter”. 7. THREATS TO VALIDITY This section summarizes threats to validity. The study had a small sample size (3 students, 4 professionals) and might thus not be representative. We manually evaluated the data, results might thus be biased. Nevertheless, results are promising and running a pilot think-aloud study with a small user group is a state-of-the-art technique in usability engineering to learn learn about the reactions of users. Such pilot studies are typically used as feedback for further iteration of the tool and to assess the usefulness of its application [25]. 8. RELATED WORK In this section we discuss related tools and user studies. We selected tools that embed a spatial visualization of software in the IDE, and user studies that study how developers navigate in the IDE as well as studies of tools that group software artifacts by topic rather than structure. Most closely related to the spatial approach studied in this paper is the work on spatial representation by DeLine [11, 7, 9, 10]. CodeCanvas by DeLine and Rowan [11] is a zoomable source editor that drops levels of details as you zoom out, up to the level of a UML diagram. CodeCanvas allows </context>
</contexts>
<marker>[25]</marker>
<rawString>J. Nielsen. Usability Engineering. Morgan Kaufmann, 1st edition, Sept. 1993.</rawString>
</citation>
<citation valid="true">
<authors>
<author>O Nierstrasz</author>
<author>S Ducasse</author>
<author>T Gırba</author>
</authors>
<title>The story of Moose: an agile reengineering environment. ESEC/FSE</title>
<date>2005</date>
<pages>1--10</pages>
<publisher>ACM Press.</publisher>
<location>New York NY,</location>
<note>Invited paper.</note>
<contexts>
<context position="26103" citStr="[26]" startWordPosition="4253" endWordPosition="4253">(i.e., students) are more likely to find the map useful than professional developers. This might be explained by the hypothesis that to power users any new way of using the IDE is likely to slow them down, and conversely to beginners any way of using the IDE is novel. The only exception to this observation was Codemap’s search bar, a one-click interface to Eclipse’s native search, that was appreciated and used by all participants but one that preferred to use the search dialog. One Participant also provided us feedback comparing his experience with Codemap to that with the Moose analysis tool [26]. He uses Moose at work after having attended a tutorial by a consultant. He said he prefers the immediate feedback of Codemap, and reported that “the gap between Moose and IDE is just too large, not to mention the struggle of importing Java code. Moose helps you to e.g., find godclasses but this is typically not new to developers that know a system. Codemap seems more interesting as it integrates with what you actually do in the IDE as you program.” 6.2 Observations, Hypotheses, Implications In this section, we present an in-depth analysis of our observations, structured by triples of observa</context>
<context position="38894" citStr="[26, 19, 13]" startWordPosition="6343" endWordPosition="6345">Most of them reacted surprised or confused when for example the classes of a package were not mostly in the same place. For example, Participant S reported in the wrap-up, “this is a very useful tool but the layout does not make sense”. Another participant stated during task 3 (i.e., the architecture recovery) with confusion that “the classes contained in packages are scattered on the map, it is not obvious what their spatial connection is.” Hypothesis 6.5: From the developers view, the predominant mental decomposition of a system is package structure. Given our reverse engineering background [26, 19, 13] we had come to distrust package decomposition, however it seems that developers like to rely on the packaging that other developers have made when designing the system. One problem raised by research in re-packaging legacy systems is that packages play too many roles: as distribution units, as units of namespacing, as working sets, as topics, as unit of architectural components, etc. However, as an opposing point of view, we can relate packaging to the folksonomies of the Web 2.0, where users label elements with unstructured tags that are then exploited by other users to search for elements. </context>
</contexts>
<marker>[26]</marker>
<rawString>O. Nierstrasz, S. Ducasse, and T. Gı̂rba. The story of Moose: an agile reengineering environment. ESEC/FSE 2005, pages 1–10, New York NY, 2005. ACM Press. Invited paper.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Noack</author>
<author>C Lewerentz</author>
</authors>
<title>A space of layout styles for hierarchical graph models of software systems. SoftVis</title>
<date>2005</date>
<pages>155--164</pages>
<publisher>ACM.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="3263" citStr="[39, 11, 5, 35, 24, 27]" startWordPosition="491" endWordPosition="496"> environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of the software system. Developers may use spatial memory to recall the location of software artifacts, and to put thematic map overlays in relation with each other [20]. The scenario of our user study is first contact with an unknown closed-source system. Our main question was whether and how developers make use of the embedded visualization and if our initial </context>
</contexts>
<marker>[27]</marker>
<rawString>A. Noack and C. Lewerentz. A space of layout styles for hierarchical graph models of software systems. SoftVis 2005, pages 155–164, New York, NY, USA, 2005. ACM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C O’Reilly</author>
<author>D Bustard</author>
<author>P Morrow</author>
</authors>
<title>The war room command console — shared visualizations for inclusive team coordination. Softviz</title>
<date>2005</date>
<pages>57--65</pages>
<location>St. Louis, Missouri, USA,</location>
<contexts>
<context position="46186" citStr="[28]" startWordPosition="7551" endWordPosition="7551">wn as Mylyn) by Kersten and Murphy [17] integrates a degree-of-interest (DOI) model in the IDE. Mylyn extends the IDE with a task view, and maintains a DOI model per task. Developers can this model to filter views by working set. This is similar to the clustering by topic on our spatial map, elements are grouped by conceptual rather than structural relation. They measured the approach in a user study and report an 15% productivity improvement, measured as“the number of keystrokes in the editor over the number of selections made in editor and views.” War Room Command Console by O’Reilly et al. [28] is a shared software visualization for team coordination. The system highlights individual team efforts by combining system structure and ongoing developer activity in order to report progress to management. They did a survey, and found that users felt the system was useful but found it hard to translate between viewpoints using the given spatial layout. Based on that, they propose a set of visualization techniques to overcome this limitation. 9. CONCLUSION In this paper we presented an evaluation of spatial software visualization in the IDE. We embedded a prototype of the Software Cartograph</context>
</contexts>
<marker>[28]</marker>
<rawString>C. O’Reilly, D. Bustard, and P. Morrow. The war room command console — shared visualizations for inclusive team coordination. Softviz 2005, pages 57–65, St. Louis, Missouri, USA, May 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Orso</author>
<author>J Jones</author>
<author>M J Harrold</author>
</authors>
<title>Visualization of program-execution data for deployed software. SoftVis</title>
<date>2003</date>
<pages>67</pages>
<publisher>ACM.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="1902" citStr="[37, 8, 32, 29]" startWordPosition="275" endWordPosition="278">ries and Subject Descriptors D.2.6 [Software Engineering]: Programming Environments General Terms Human Factors Keywords Software Development Tools, Software Cartography, Spatial Software Representation, User Study 1. INTRODUCTION Software visualization can be of great use for understanding and exploring a software system in an intuitive manner. In the past decade the software visualization community has developed a rich wealth of visualization approaches [12] and provided evidence of their usefulness for expert tasks, such as reverse engineering, release management or dynamic analysis (e.g., [37, 8, 32, 29]). Typically, these visualization Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SOFTVIS’10, October 25–26, 2010, Salt Lake City, Utah, USA. Copyright 2010 ACM 978-1-4503-0028-5/10/10 ...$10.00. approaches had been implemented in intera</context>
</contexts>
<marker>[29]</marker>
<rawString>A. Orso, J. Jones, and M. J. Harrold. Visualization of program-execution data for deployed software. SoftVis 2003, pages 67–ff, New York, NY, USA, 2003. ACM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Phan</author>
<author>L Xiao</author>
<author>R B Yeh</author>
<author>P Hanrahan</author>
<author>T Winograd</author>
</authors>
<title>Flow map layout. INFOVIS</title>
<date>2005</date>
<pages>29</pages>
<contexts>
<context position="8496" citStr="[30]" startWordPosition="1360" endWordPosition="1360"> to class names, but include automatically retrieved keywords and topics. • Exploring a system during reverse engineering. Codemap is integrated with Eclipse’s structural navigation 1http://scg.unibe.ch/codemap Figure 1: Thematic codemap of a software system. Here the Codemap tool itself is shown. Arrow edges show incoming calls to the #getSettingOrDefault method in the MenuAction class, which is currently active in the editor and thus labeled with a pop-up. features, such as search for callers, implementers, and references. Arrows are shown for search results. We apply the Flow Map algorithm [30] to avoid visual clutter by merging parallel arrow edges. Figure 1 shows the result of searching for calls to the #getSettingOrDefault method in the MenuAction class . 3. THE CODEMAP ALGORITHM Figure 2 illustrates the construction of a software map. The sequence of the construction is basically the same as presented in previous work [21, 20]. 2-Dimensional Embedding. A distance metric is used to compute the pair-wise dissimilarity of software artifacts (typically source code files). A combination of the Isomap algorithm [38] and Multidimensional Scaling (MDS) [4] is used to embed all software </context>
</contexts>
<marker>[30]</marker>
<rawString>D. Phan, L. Xiao, R. B. Yeh, P. Hanrahan, and T. Winograd. Flow map layout. INFOVIS 2005, page 29, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>D Poshyvanyk</author>
<author>A Marcus</author>
</authors>
<title>Combining formal concept analysis with information retrieval for concept location in source code. ICPC</title>
<date>2007</date>
<pages>37--48</pages>
<publisher>IEEE Computer Society.</publisher>
<location>Washington, DC, USA,</location>
<contexts>
<context position="32784" citStr="[31]" startWordPosition="5335" endWordPosition="5335"> that he “inspected more results than usual, because the map shows them in their context and that this helps him to take a more informed choice on which results are worth inspection and which ones not.” Implication 6.2: Tools should put search results into a meaningful context, so developers can take both quicker and better-informed decisions. The need for better presentation of search results has implications beyond the design of spatial visualizations. Work on presentation of search results goes beyond spatial maps [16], for example results can be presented as a graph. Poshyvanyk and Marcus [31] have taken one such approach (representing search results as a lattice) and applied it to source code search with promising results. For our next prototype we plan to integrate search results into the package explorer view, just as is already done with compile errors (which are, from this point of view, just like the search results of a complex query that is run to find syntax errors). This planned feature addresses another implication of our study as well, as we have found that some developers establish a spatial memory of the package explorer view. It therefore makes sense to mark search re</context>
</contexts>
<marker>[31]</marker>
<rawString>D. Poshyvanyk and A. Marcus. Combining formal concept analysis with information retrieval for concept location in source code. ICPC 2007, pages 37–48, Washington, DC, USA, 2007. IEEE Computer Society.</rawString>
</citation>
<citation valid="true">
<authors>
<author>JOVE</author>
</authors>
<title>Java as it happens. SoftVis</title>
<date>2005</date>
<pages>115--124</pages>
<contexts>
<context position="1902" citStr="[37, 8, 32, 29]" startWordPosition="275" endWordPosition="278">ries and Subject Descriptors D.2.6 [Software Engineering]: Programming Environments General Terms Human Factors Keywords Software Development Tools, Software Cartography, Spatial Software Representation, User Study 1. INTRODUCTION Software visualization can be of great use for understanding and exploring a software system in an intuitive manner. In the past decade the software visualization community has developed a rich wealth of visualization approaches [12] and provided evidence of their usefulness for expert tasks, such as reverse engineering, release management or dynamic analysis (e.g., [37, 8, 32, 29]). Typically, these visualization Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SOFTVIS’10, October 25–26, 2010, Salt Lake City, Utah, USA. Copyright 2010 ACM 978-1-4503-0028-5/10/10 ...$10.00. approaches had been implemented in intera</context>
</contexts>
<marker>[32]</marker>
<rawString>S. P. Reiss. JOVE: Java as it happens. SoftVis 2005, pages 115–124, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M Sensalire</author>
<author>P Ogao</author>
<author>A Telea</author>
</authors>
<title>Classifying desirable features of software visualization tools for corrective maintenance. SoftVis</title>
<date>2008</date>
<pages>87--90</pages>
<publisher>ACM.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="2518" citStr="[33]" startWordPosition="374" endWordPosition="374">, these visualization Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SOFTVIS’10, October 25–26, 2010, Salt Lake City, Utah, USA. Copyright 2010 ACM 978-1-4503-0028-5/10/10 ...$10.00. approaches had been implemented in interactive tools [33]. However most of these tools are stand-alone prototypes that have never been integrated in an IDE (integrated development environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduc</context>
</contexts>
<marker>[33]</marker>
<rawString>M. Sensalire, P. Ogao, and A. Telea. Classifying desirable features of software visualization tools for corrective maintenance. SoftVis 2008, pages 87–90, New York, NY, USA, 2008. ACM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>T A Slocum</author>
<author>R B McMaster</author>
<author>F C Kessler</author>
<author>H H Howard</author>
</authors>
<title>Thematic Carthography and Geographic Visualization. Pearson Prentice Hall, Upper Saddle River,</title>
<date>2005</date>
<location>New Jersey,</location>
<contexts>
<context position="5840" citStr="[34]" startWordPosition="921" endWordPosition="921">e remainder of this paper is structured as follows: Section 2 and Section 3 present the new Codemap prototype; Section 4 and Section 5 describes design and data analysis of the study; Section 6 is the main part that presents and discusses the results; Section 7 explains threats to the validity; Section 8 discusses related work; Section 9 concludes. 2. SOFTWARE CARTOGRAPHY Software Cartography uses a spatial visualization of software systems to provide software development teams with a stable and shared mental model. The basic idea of cartographic visualization is to apply thematic cartography [34] on software visualization. That is, to show thematic overlays on top of a stable, spatial base layout. Features on a thematic map are either point-based, arrow-based or continuous. For software this could be the dispersion of design flaws as visualized using icons; a call graph is visualized as a flow map (as illustrated on Figure 1); and test coverage is visualized as a choropleth map, i.e., a heat map. Software Cartography is most useful when it supports as many development tasks with spatial location awareness as possible. We therefore integrated our prototype into the Eclipse IDE so that </context>
</contexts>
<marker>[34]</marker>
<rawString>T. A. Slocum, R. B. McMaster, F. C. Kessler, and H. H. Howard. Thematic Carthography and Geographic Visualization. Pearson Prentice Hall, Upper Saddle River, New Jersey, 2005.</rawString>
</citation>
<citation valid="false">
<authors>
<author>F Steinbruckner</author>
</authors>
<title>Layout stability of software cities.</title>
<note>http://seal.ifi.uzh.ch/uploads/media/16_frank_ steinbrueckner.pdf.</note>
<contexts>
<context position="3263" citStr="[39, 11, 5, 35, 24, 27]" startWordPosition="491" endWordPosition="496"> environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of the software system. Developers may use spatial memory to recall the location of software artifacts, and to put thematic map overlays in relation with each other [20]. The scenario of our user study is first contact with an unknown closed-source system. Our main question was whether and how developers make use of the embedded visualization and if our initial </context>
</contexts>
<marker>[35]</marker>
<rawString>F. Steinbrückner. Layout stability of software cities. http://seal.ifi.uzh.ch/uploads/media/16_frank_ steinbrueckner.pdf.</rawString>
</citation>
<citation valid="true">
<authors>
<author>M-A D Storey</author>
<author>D Cubranic</author>
<author>D M German</author>
</authors>
<title>On the use of visualization to support awareness of human activities in software development: a survey and a framework. SoftVis</title>
<date>2005</date>
<pages>193--202</pages>
<publisher>ACM Press,</publisher>
<contexts>
<context position="2901" citStr="[36]" startWordPosition="434" endWordPosition="434"> requires prior specific permission and/or a fee. SOFTVIS’10, October 25–26, 2010, Salt Lake City, Utah, USA. Copyright 2010 ACM 978-1-4503-0028-5/10/10 ...$10.00. approaches had been implemented in interactive tools [33]. However most of these tools are stand-alone prototypes that have never been integrated in an IDE (integrated development environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of</context>
</contexts>
<marker>[36]</marker>
<rawString>M.-A. D. Storey, D. Čubranić, and D. M. German. On the use of visualization to support awareness of human activities in software development: a survey and a framework. SoftVis 2005, pages 193–202. ACM Press, 2005.</rawString>
</citation>
<citation valid="true">
<authors>
<author>A Telea</author>
<author>L Voinea</author>
</authors>
<title>An interactive reverse engineering environment for large-scale c++ code. SoftVis</title>
<date>2008</date>
<pages>67--76</pages>
<publisher>ACM.</publisher>
<location>New York, NY, USA,</location>
<contexts>
<context position="1902" citStr="[37, 8, 32, 29]" startWordPosition="275" endWordPosition="278">ries and Subject Descriptors D.2.6 [Software Engineering]: Programming Environments General Terms Human Factors Keywords Software Development Tools, Software Cartography, Spatial Software Representation, User Study 1. INTRODUCTION Software visualization can be of great use for understanding and exploring a software system in an intuitive manner. In the past decade the software visualization community has developed a rich wealth of visualization approaches [12] and provided evidence of their usefulness for expert tasks, such as reverse engineering, release management or dynamic analysis (e.g., [37, 8, 32, 29]). Typically, these visualization Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, to republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. SOFTVIS’10, October 25–26, 2010, Salt Lake City, Utah, USA. Copyright 2010 ACM 978-1-4503-0028-5/10/10 ...$10.00. approaches had been implemented in intera</context>
</contexts>
<marker>[37]</marker>
<rawString>A. Telea and L. Voinea. An interactive reverse engineering environment for large-scale c++ code. SoftVis 2008, pages 67–76, New York, NY, USA, 2008. ACM.</rawString>
</citation>
<citation valid="true">
<authors>
<author>J B Tenenbaum</author>
<author>V Silva</author>
<author>J C Langford</author>
</authors>
<title>A global geometric framework for nonlinear dimensionality reduction.</title>
<date>2000</date>
<journal>Science,</journal>
<volume>290</volume>
<issue>5500</issue>
<contexts>
<context position="9026" citStr="[38]" startWordPosition="1444" endWordPosition="1444"> Arrows are shown for search results. We apply the Flow Map algorithm [30] to avoid visual clutter by merging parallel arrow edges. Figure 1 shows the result of searching for calls to the #getSettingOrDefault method in the MenuAction class . 3. THE CODEMAP ALGORITHM Figure 2 illustrates the construction of a software map. The sequence of the construction is basically the same as presented in previous work [21, 20]. 2-Dimensional Embedding. A distance metric is used to compute the pair-wise dissimilarity of software artifacts (typically source code files). A combination of the Isomap algorithm [38] and Multidimensional Scaling (MDS) [4] is used to embed all software artifacts into the visualization pane. The application of Isomap is an improvement over previous work in order to assist MDS with the global layout. In contrast to our previous work, Latent Semantic Indexing (LSI) is not applied anymore, it has been found to have little impact on the final embedding. Digital Elevation Model. In the next step, a digital elevation model is created. Each software artifact contributes a Gaussian shaped basis function to the elevation model according to its KLOC size. The contributions of all sof</context>
</contexts>
<marker>[38]</marker>
<rawString>J. B. Tenenbaum, V. Silva, and J. C. Langford. A global geometric framework for nonlinear dimensionality reduction. Science, 290(5500):2319–2323, Dec. 2000.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Wettel</author>
<author>M Lanza</author>
</authors>
<title>Visual exploration of large-scale system evolution. Softvis</title>
<date>2008</date>
<pages>155--164</pages>
<publisher>IEEE CS Press,</publisher>
<contexts>
<context position="3263" citStr="[39, 11, 5, 35, 24, 27]" startWordPosition="491" endWordPosition="496"> environment). Little is thus known about the benefits of software visualization for the “end users” in software engineering, that is for everyday programmers. What is lacking is how these techniques support the day to day activities of software developers [36]. In this paper, we report on a pilot study of a spatial software visualization that is embedded in the IDE. The spatial visualization is based on the Software Cartography approach that has been presented and introduced in previous work [22, 20, 15]. Spatial representation of software is a promising research field of increasing interest [39, 11, 5, 35, 24, 27], however the respective tools are either not tightly integrated in an IDE or have not yet been evaluated in a user study. Spatial representation of software is supposed to support developers in establishing a long term, spatial memory of the software system. Developers may use spatial memory to recall the location of software artifacts, and to put thematic map overlays in relation with each other [20]. The scenario of our user study is first contact with an unknown closed-source system. Our main question was whether and how developers make use of the embedded visualization and if our initial </context>
</contexts>
<marker>[39]</marker>
<rawString>R. Wettel and M. Lanza. Visual exploration of large-scale system evolution. Softvis 2008, pages 155 – 164. IEEE CS Press, 2008.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>