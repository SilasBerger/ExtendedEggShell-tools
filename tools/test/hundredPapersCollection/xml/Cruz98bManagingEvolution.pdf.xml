<?xml version="1.0" encoding="UTF-8"?>
<algorithms version="110505">
<algorithm name="SectLabel" version="110505">
<variant no="0" confidence="0.000490">
<title confidence="0.937958">
Managing Evolution of Coordination Aspects in Open Systems
</title>
<author confidence="0.972455">
Juan Carlos Cruz, Sander Tichelaar
</author>
<affiliation confidence="0.914871">
Software Composition Group, University of Berne
</affiliation>
<email confidence="0.43691">
E-mail: {cruz,tichel}@iam.unibe.ch. WWW: http://www.iam.unibe.ch/~scg.
</email>
<sectionHeader confidence="0.973988" genericHeader="abstract">
Abstract
</sectionHeader>
<bodyText confidence="0.982100821428572">
Most of the work on coordination technology
so far has focused on the development of spe-
cial coordination languages and environments
that provide the basic mechanisms for realiz-
ing the coordination layer of an open system. It
is clear that the idea of managing separately
the coordination aspect from the computation
in a language has a lot of advantages in the de-
velopment of those systems. Nevertheless,
most of the coordination languages do not take
care that additionally to managing coordina-
tion requirements, they must manage other
kinds of “openness” related requirements in
Open Systems. The most important require-
ment being to support the evolution of the co-
ordination requirements themselves. This
problem manifests during the software devel-
opment process by the development over and
over again of solutions to similar coordination
problems. To tackle this problem, and instead
of proposing a new language, we are attempt-
ing to develop an open set of adaptable and re-
usable software components that realize vari-
ous useful coordination abstractions. With
these components we provide explicit separa-
tion of coordination from computation, and fa-
cilitate reuse and evolution of coordination as-
pects in Open Systems.
</bodyText>
<sectionHeader confidence="0.997954" genericHeader="introduction">
1 Introduction
</sectionHeader>
<bodyText confidence="0.994476421875">
Over the last two decades software development has changed sig-
nificantly. Its evolution has been motivated by the goal of produc-
ing open rather than closed, proprietary systems. Open Systems
are basically “open” in terms of topology, platform and evolution
[18]: they run on networks which are continuously changing and
expanding, they are built on the top of a heterogeneous platform
of hardware and software pieces, and their requirements are con-
tinuously evolving. Evolution is the most difficult requirement to
meet, since not all the application requirements can be known in
advance[12].
Development of Open Systems is a difficult task, because in
addition to requirements concerning openness, they have special
computational constraints. One of the most important constraints
concerns the coordination of the interaction of the different soft-
ware entities that compose those systems. Coordination in this
context concerns the management of possible interdependencies
between the activities performed by the entities of the system.
Carriero and Gelernter [3] have proposed to manage separately
the coordination aspect from the computation in the development
of Open Systems. They propose to use what they call Coordina-
tion Languages. The idea of separating these two aspects during
the system development seems to have a lot of advantages, main-
ly related with a simplification in the complexity of the develop-
ment. Nevertheless, most of the coordination languages do not
take care of satisfying the “openness” related requirements Open
Systems have to. This is particularly true in which concerns the
management of the evolution of the coordination aspect itself.
This problem manifest during the software development process
by the development of over and over again of solutions to similar
coordination problems. How to manage in a single approach the
complexity of the coordination aspect and its evolution is not still
clear. To tackle this problem, and instead of proposing a new Co-
ordination Language, we propose to use a component-base ap-
proach. We will develop an open set of adaptable and reusable
coordination components that will realize solutions to standard
coordination problems. They can be specialized and parameter-
ized to solve specific coordination problems. With these compo-
nents, we provide explicit separation of coordination from
computation, and facilitate reuse and evolution of coordination
aspects.
We are developing a prototype of this set of coordination com-
ponents using the Java language, an object oriented language
well-suited to modelling software entities in a distributed setting.
We are validating our approach by using those components in
building a set of sample applications that characterize Open Sys-
tems. Our initial experiences in building this set of components
has shown us, that coordination solutions are not easily shrink-
wrapped into off-the shelf components. One reason is that coor-
dination solutions affect typically more than one component. A
second is that the coordination solutions are subject to a complex
set of requirements for Open Systems like [8]: interoperability,
concurrency, distribution, reliability, security, etc. A systems de-
veloper who develops coordination solutions, therefore has to
deal with many of the above requirements. And every application
has its own unique mix of interacting components and specific re-
quirements.
In this paper we present some results of our experimental work
building a such set of coordination components. Section 2, dis-
cusses coordination aspects in Open Systems. Section 3, intro-
duces an example of a coordination component, and explains how
this component was designed using a component-based ap-
proach. Section 4 gives an overview of related work. Finally, Sec-
tion 5 concludes with a discussion: evaluating our contributions
and pointing-out lessons learned in this experimental work.
</bodyText>
<sectionHeader confidence="0.956873" genericHeader="method">
2 Coordination Aspects in Open
</sectionHeader>
<bodyText confidence="0.996085571428571">
Systems.
Coordination problems arise in the organisation of interac-
tions of a group of entities that collaborate and cooperate to ac-
complish some task and to satisfy some goals. It is because
entities cooperate that they can accomplish more elaborated ac-
tions, but it is also because of their multiplicity that they must co-
ordinate their actions and resolve conflicts.
Malone and Crowston [10][11] have defined coordination as:
The act of managing interdependencies between activ-
ities performed by entities in order to achieve some
goals.
They have identified three kinds of dependencies out of which
all other important dependencies can be expressed, either by their
specialization or by their combination. They are:
</bodyText>
<listItem confidence="0.839289">
• Flow: occurs when an activity produces something that is
</listItem>
<bodyText confidence="0.904740571428571">
used by another one. Flow dependencies can be viewed as
a combination of three other kind of dependencies: Pre-
requisite constraints (an item must be produced before it
can be used), Accessibility constraints (an item that is pro-
duced must be available for use), and Usability constraints
(an item that is produced should be “usable” by the activ-
ity that uses it).
</bodyText>
<listItem confidence="0.999990333333333">
• Sharing: occurs when multiple activities all need the same
(limited) resource
• Fit: occurs when multiple activities produce things that
</listItem>
<bodyText confidence="0.956629">
have to fit together.
Some dependencies can be viewed as specialization of others.
For instance Task assignment can be seen as an special case of
Sharing, where the “resource” being shared is the time of the en-
tities that do the tasks.
This list of interdependencies is not intended to be exhaustive.
To our viewpoint the importance of Malone’s work is that it can
be used to propose a systematic approach to identify coordination
problems in open systems. The main idea consists to identify the
existence of these interdependencies between the multiple activ-
ities that the system realizes [5] (e.g.communication, manage-
ment of resources and services, task assignments etc.).
</bodyText>
<subsectionHeader confidence="0.994829">
2.1 Coordination Problems
</subsectionHeader>
<bodyText confidence="0.99514675">
We have selected a representative set of coordination problems
that we have yet identified. For each one we give some hints about
how these problems can be managed using a coordination proc-
ess.
</bodyText>
<subsubsectionHeader confidence="0.716803">
2.1.1 Management of Shared Resources
</subsubsectionHeader>
<bodyText confidence="0.999831">
Managing shared resources is one of the most common coordina-
tion problems that occurs in open systems. Whenever multiple
activities share some limited resource (e.g. storage space, an ac-
tor’s time, etc.), a coordination process which controls the alloca-
tion of and/or access to, the resource is needed. The coordination
process must: serialize the incoming concurrent requests, select
(by using a pre-defined allocation and/or access policy like for
example: first-come/first serve, priorities, etc.) the request to be
served, control that all clients will eventually obtain the resource,
control security aspects (access rights, etc.), take care of possible
software and hardware failures during the allocation process, etc.
A particular situation in which this coordination problem occurs
is when multiple processes share a unique disk space.
</bodyText>
<subsubsectionHeader confidence="0.671291">
2.1.2 Transfer of Information Between
Activities
</subsubsectionHeader>
<bodyText confidence="0.9948787">
Producer/consumer relationships occur in software systems
whenever one activity produces some information that is used by
another activity. A coordination process which controls the trans-
fer of information between activities is needed. The coordination
process must: guarantee the physical transfer of information be-
tween the entities (from one entity space to another), control their
synchronization, and eventually control the replication of infor-
mation in case of a replicated transfer (multicast or broadcast). A
particular situation in which this coordination problem occurs is
when computing the topology of a system.
</bodyText>
<subsubsectionHeader confidence="0.891915">
2.1.3 Activity Synchronization
</subsubsectionHeader>
<bodyText confidence="0.99929468">
Execution of activities in a concurrent setting must be synchro-
nized in order to either communicate, or to perform some com-
mon operations (i.e accessing shared resources). A coordination
process controlling the synchronization must constraint the order
of execution of these activities so that only acceptable execution
sequences can ever be used. Two basic forms of synchronization
are necessary when working with concurrent activities: 1) Condi-
tion-Synchronization (needed when an activity wishes to perform
an operation that can only safely be performed if another activity
has itself taken some action or is in some defined state) and 2) Mu-
tual Exclusion (needed to protect critical sections). A particular
situation in which condition synchronization is needed is when
buffers are used to exchange data between a producer and a con-
sumer. The producer produces items the consumer needs. The
consumer cannot consume what the producer has not produced,
and the producer cannot produce if the consumer does not con-
sume. Moreover, if simultaneous deposits or extractions are pos-
sible from the buffer then mutual exclusion must be ensured so
that two producers, for example, do not corrupt the “next free
slot” pointer of the buffer. A coordination process that controls
the synchronization between the concurrent activities must basi-
cally: serialize concurrent execution requests, and select (by us-
ing a pre-defined synchronization policy like for example:
mutual-exclusion, multiple readers/only one writer, etc.) the re-
quest to be executed.
</bodyText>
<subsubsectionHeader confidence="0.983753">
2.1.4 Group Decisions
</subsubsectionHeader>
<bodyText confidence="0.9371846">
It is very common that a group of entities working together are
confronted with the problem of making coordinated decisions.
These decisions cannot be made in isolation by one of the mem-
bers, possibly because no individual has enough authority, com-
petence or information to decide. A coordination process that
controls the group decision must: ensure that all the entities will
receive an invitation to participate in the group decision, imple-
ment a decision scheme (e.g. consensus, voting, authority, etc.),
announce the final decision to the group, and decide what to do in
case of failures of the entities which participate (to terminate the
process, etc.). A particular situation in which this kind of coordi-
nation problem can occur is in the election of a new server from a
group of replicated servers. Replication of servers is a common
strategy used to guarantee the fault tolerance of a provided serv-
ice.
</bodyText>
<sectionHeader confidence="0.839274" genericHeader="method">
3 A Component-Based Approach to
</sectionHeader>
<subsectionHeader confidence="0.8642585">
Manage Evolution of
Coordination Aspects
</subsectionHeader>
<bodyText confidence="0.898385705882353">
In a component-based approach [12], each application is viewed
as only one instance of a generic class of applications, each one
being flexible composed of software components. New applica-
tion requirements are addressed by removing, replacing and re-
configuring the software components without disturbing other
parts of the application. Why not to manage the coordination as-
pects of those applications using the same approach? Why not to
develop a set of adaptable and reusable coordination components
that encapsulate standard solutions to coordination problems?
That is what we tried to in our work. The initial results of this ex-
perimental work has shown that coordination solutions are not
easily shrink-wrapped into off-the shelf components. The rea-
sons for this are analyzed in [17]. They are:
• information dependencies: Many coordination solutions
are dependent of application dependent information. Infor-
mation that is typically needed by coordination solution is:
“this method updates the state and this one only reads”, or
</bodyText>
<listItem confidence="0.9618831">
“these three method calls constitute a critical section”, etc.
• service dependencies: In some cases the computational
components need to provide coordination related services
like to store state relevant information in order to guarantee
recovery in case of failures.
• request control: Coordination solutions need to control the
ordering and adaptation of requests. They typically need
techniques like message reification, message passing con-
trol or method wrapping, etc.
• complex system requirements: Coordination solutions are
</listItem>
<bodyText confidence="0.956752666666667">
subject to a complex set of requirements for Open Systems
like [8]: interoperability, concurrency, distribution, relia-
bility, security, etc. A systems developer who develops co-
ordination solutions, therefore has to deal with many of the
above requirements. Every application has its own unique
mix of specific requirements.
In the design and development of the coordination compo-
nents we have investigated how framework technology can help
us to deal with this complex set of system requirements in the
packaging of coordination solutions. Particularly, we had look at
the design guidelines for building “tailorable frameworks” as
presented in [6].
</bodyText>
<subsectionHeader confidence="0.64785">
Example
</subsectionHeader>
<bodyText confidence="0.999603113636363">
As an example of what is being done, we show access policy com-
ponents for a shared resource in a toy banking system. In this case
the resource is an account database which is shared by multiple
teller machines. The teller machines need to get information from
the account database in order to check a client’s account. They
also need to update account information if they have given money
to a client. To keep the database consistent we need an access pol-
icy to regulate the multiple requests.
As a solution for this regulation problem we introduce an ac-
cess policy component. This solution not only provides access
regulation, but also explicitness of architecture and flexibility. We
can imagine a banking system which initially starts with a basic
FIFO policy, but which, as more and more teller machines get
connected to the system, needs a more sophisticated policy to
handle the increasing number of incoming requests. By creating
a structure which allows us to change policies transparently, the
banking system can be adapted without having to change other
parts of the system. Our solution is shown in Figure 1. In its de-
sign we used ideas from the Command and Strategy pattern from
Gamma et al. [7], and from the Active Object pattern [13].
The class Wrapper is the interface to the resource for the rest
of the system. For every command which is invoked by an incom-
ing request (1), a ConcreteCommand object is created (2).
This explicit representation of commands allows us to buffer the
commands, change their order, execute them in parallel, or what-
ever a policy needs to do with them. This is, for instance, needed
for a readers/writer policy, which allows multiple readers to ac-
cess the database simultaneously. These commands are then giv-
en (3) to the policy which is connected (through
parameterization) to the interface. This policy handles the com-
mands, i.e. determines when and in which order the requests can
access the resource. If the command is allowed, it executes (4).
A major problem with the transparency of these policies, is
that policies may need application-dependent information. A
readers/writer policy for instance needs knowledge about aget-
Balance command being a reader command and an update-
Balance command being a writer command. This problem
obviously violates the transparency of the proposed solution: by
integrating the storage and retrieval of this application-dependent
information in the Command or the Policy, the change and re-
use of policies is much more difficult. We tackle this problem by
introducing a context object. This object contains the application-
dependent information of the policy, so it can tell the policy if a
certain command is a reader or a writer command.
</bodyText>
<subsectionHeader confidence="0.881898">
Reusability and Flexibility
</subsectionHeader>
<bodyText confidence="0.9987912">
In the presented example it is possible to completely separate the
coordination policy from the application specific part of the ap-
plication. The information dependencies between the generic
policy and the application specific part of the application are
made explicit in the context objects. This means that the policy is
independent of the application and the application independent of
what policy is used. The context objects are used to configure a
generic policy for a specific application. In this way the policies
are reusable in different applications and within applications we
can easily switch policies.
</bodyText>
<subsectionHeader confidence="0.647786">
Limitations
</subsectionHeader>
<bodyText confidence="0.999902">
The example we have shown is limited in a couple of ways. First-
ly, it only deals with a single resource. More complex coordina-
tion problems involve distributed solutions, e.g. replicated re-
sources or distributed transactions. This is work in progress. Sec-
ondly, there are dependencies that cannot be dealt with in this
way. For instance, the set of actions that make up a transaction, is
local for every transaction, making it impossible to store this in-
formation in some kind of general transaction context object [17].
</bodyText>
<sectionHeader confidence="0.999651" genericHeader="related work">
4 Related Work
</sectionHeader>
<bodyText confidence="0.998730119047619">
Most of the work done in the area of coordination have been di-
rected to the development of coordination languages (e.g. Gam-
ma [2], Linda [3], etc.) used to describe coordination aspects in
open systems. The fact that the coordination model they imple-
ment is based on a particular paradigm makes these languages
limited in scope. Each one of these coordination languages pro-
poses its own set of coordination abstractions that realizes a par-
ticular paradigm for realizing coordination. Coordination
problems, however, do not always fit to a particular paradigm.
Language based approaches are inherently limited in scope. In-
stead of proposing a new language, we are attempting to provide
an open set of coordination components that realize various use-
ful coordination abstractions. With our components we provide
explicit separation of coordination from computation and facili-
tate reuse and evolution of the coordination aspect.
The idea of using and composing coordination components is
not new, as evidenced by work such as Manifold [1] and ConCo-
ord [9]. These languages allow composition of existing coordina-
tion components with communication operations. Dynamically
new communication configurations between components can be
reached in this way. Coordinator processes do their job with no
knowledge of the internal details of the computations done by the
processes they coordinate. The communication configuration de-
termines the coordination flow of an application. In our work we
try to explore other forms of composition of coordination compo-
nents different to communication (e.g. policies, etc.). Further-
more, we build components that are themselves configurable and
composable. Our components can be adapted to particular situa-
tions by plugging in instances of the elements that define their pa-
rameterized structure.
In a different domain, the Adaptive Communication Environ-
ment (ACE)[14] is an interesting reference. One of the most im-
portant contributions of this work is the set of coordination
patterns [13][15][16] that it proposes and that can be used to real-
ize coordination components. We have presented examples of co-
ordination components that have used some ideas from some of
these design patterns. The object-oriented network programming
toolkit includes a series of wrappers, class libraries and frame-
works for developing communication software. The main prob-
lem with these work is its closeness. Synchronization and
communication abstractions in the ACE toolkit are reduced to
those provided by some common operating systems (e.g. Mutex,
</bodyText>
<figure confidence="0.9976711">
Wrapper
RWContext
PrContext
Command
Policy
ReadersWriterPolicy PriorityPolicyFIFOPolicy
Resource
incoming
ConcreteCommand
execute()
execute()
request()
requests
request()
put(Command c)
c = new ConcreteCommand;
Resource.request();
1
3
2 4
</figure>
<figureCaption confidence="0.938346">
Figure 1 Access policy for shared resource.
</figureCaption>
<bodyText confidence="0.8695354">
Condition, Semaphore, RW, pipes, FIFOs, sockets, etc.), thus
limiting its scope. New coordination abstractions representing
solutions to more complex coordination problems cannot be in-
cluded in the environment by users. Our approach is more open in
this way.
</bodyText>
<sectionHeader confidence="0.99887" genericHeader="conclusions">
5 Conclusions
</sectionHeader>
<bodyText confidence="0.995138636363636">
In this paper we have shown that is possible to provide extend-
able and reusable coordination solutions using a component-
based approach. With these coordination components, we pro-
vide explicit separation of coordination from computation (as
promoted by coordination languages), and facilitate reuse and ev-
olution of coordination aspects. We show that although it is pos-
sible to define generic components for managing the aspect of
coordination using composition, a complete separation of coordi-
nation and computation is not possible due to dependencies of co-
ordination solutions of information and services that can only be
provided by the computational components.
</bodyText>
<sectionHeader confidence="0.992301" genericHeader="references">
References
</sectionHeader>
<reference confidence="0.999867109090909">
[1] F. Arbad, &amp;quot;The IWIM Model for Coordination of Concurrent
Activities&amp;quot;, in [4] pp. 34-56
[2] Jean-Pierre Banatre and Daniel Le Metayer, “Gamma and the
Chemical Reaction Model”, Proceedings of Coordination’95
Workshop, IC Press, London, 1995.
[3] N. Carriero and D. Gelernter, “Linda in Context”, Communi-
cations of the ACM, vol. 32, no. 4, April 1989, pp. 444-458.
[4] P. Ciancarini, C. Hankin (eds.), &amp;quot;First International Confer-
ence on Coordination Models, Languages and Applications
COORDINATION’96&amp;quot;, Cesena, Italy, 15-17 April, 1996,
LNCS 1061, Springer Verlag.
[5] George Coulouris, Jean Dollimore and Tim Kindberg, “Dis-
tributed Systems Concepts and Design”, Addison-Wesley,
1994.
[6] Serger Demeyer, Theo Dirk Meijler, Oscar Nierstrasz,
Patrick Steyaert, “Design Guidelines for Tailorable Frame-
works”, Communications of the ACM, vol. 40, no. 10, Octo-
ber 1997, pp. 60-64
[7] Eric Gamma, Richard Helm, Ralph Johnson and John Vlis-
sides, “Design Patterns”, Addison-Wesley, MA, 1995.
[8] C. Hewitt, “Offices are Open Systems”, ACM Transactions
Off. Inf. Syst., vol. 4, no. 3, 1986, pp. 270-287.
[9] A.A. Holzbacher, &amp;quot;A Software Environment for Concurrent
Coordinated Programming&amp;quot;, in [4] pp. 249-266.
[10] Thomas Malone, Kevin Crowston, “The Interdisciplinary
Study of Coordination”, ACM Computing Surveys, vol.
26,no. 1, March 1994
[11] Thomas Malone, &amp;quot;Free on the range: Tom Malone and the
implications of the digital age&amp;quot;, IEEE Internet Computing,
Vol 1, no. 3, May-June, 1997
[12] Oscar Nierstrasz and Laurent Dami, “Component-Oriented
Software Technology”, Object-Oriented Software Composi-
tion, O. Nierstrasz and D. Tsichritzis (Ed.), Prentice Hall,
1995, pp. 3-28.
[13] R. Greg Lavender and Douglas C. Schmidt, “Active Object:
an Object Behavioural Pattern for Concurrent Program-
ming”, Proc. Pattern Languages of Programs, September
1995.
[14] Douglas Schmidt, “The ADAPTATIVE Communication En-
vironment: An Object-Oriented Network Programming
Toolkit for Development of Communication Software”.
[15] Douglas Schmidt, “Acceptor: A Design Pattern for Passively
Initializing Network Services”, C++ Reports, SIGS, Vol. 7,
no. 8, Nov/Dec 1995.
[16] Douglas Schmidt, “Connector: A Design Pattern for Actively
Initializing Network Services”, C++ Reports, SIGS, vol. 8,
no. 1, January 1996.
[17] Sander Tichelaar, Juan Carlos Cruz, Serge Demeyer, “Coor-
dination as a Variability Aspect of Open Distributed Sys-
tems”, SCG-Report, IAM, University of Berne, February
1998.
[18] Dennis Tsichritzis, “Object-Oriented Development for Open
Systems”, Information Processing 89 (Proceedings
IFIP’89), North Holland, San Francisco, Aug. 28-Sept. 1,
1989, pp. 1033-1040.
</reference>
</variant>
</algorithm>
<algorithm name="ParsHed" version="110505">
<variant no="0" confidence="0.695550">
<title confidence="0.999996">Managing Evolution of Coordination Aspects in Open Systems</title>
<author confidence="0.999068">Juan Carlos Cruz</author>
<author confidence="0.999068">Sander Tichelaar</author>
<affiliation confidence="0.969939">Software Composition Group, University of Berne</affiliation>
<email confidence="0.888058">E-mail:{cruz,tichel}@iam.unibe.ch.WWW:http://www.iam.unibe.ch/~scg.</email>
<abstract confidence="0.993311517241379">Most of the work on coordination technology so far has focused on the development of special coordination languages and environments that provide the basic mechanisms for realizing the coordination layer of an open system. It is clear that the idea of managing separately the coordination aspect from the computation in a language has a lot of advantages in the development of those systems. Nevertheless, most of the coordination languages do not take care that additionally to managing coordination requirements, they must manage other kinds of “openness” related requirements in Open Systems. The most important requirement being to support the evolution of the coordination requirements themselves. This problem manifests during the software development process by the development over and over again of solutions to similar coordination problems. To tackle this problem, and instead of proposing a new language, we are attempting to develop an open set of adaptable and reusable software components that realize various useful coordination abstractions. With these components we provide explicit separation of coordination from computation, and facilitate reuse and evolution of coordination aspects in Open Systems.</abstract>
</variant>
</algorithm>
<algorithm name="ParsCit" version="110505">
<citationList>
<citation valid="false">
<authors>
<author>F Arbad</author>
</authors>
<title>The IWIM Model for Coordination of Concurrent Activities&amp;quot;,</title>
<volume>4</volume>
<pages>34--56</pages>
<contexts>
<context position="18865" citStr="[1]" startWordPosition="2923" endWordPosition="2923">s a particular paradigm for realizing coordination. Coordination problems, however, do not always fit to a particular paradigm. Language based approaches are inherently limited in scope. Instead of proposing a new language, we are attempting to provide an open set of coordination components that realize various useful coordination abstractions. With our components we provide explicit separation of coordination from computation and facilitate reuse and evolution of the coordination aspect. The idea of using and composing coordination components is not new, as evidenced by work such as Manifold [1] and ConCoord [9]. These languages allow composition of existing coordination components with communication operations. Dynamically new communication configurations between components can be reached in this way. Coordinator processes do their job with no knowledge of the internal details of the computations done by the processes they coordinate. The communication configuration determines the coordination flow of an application. In our work we try to explore other forms of composition of coordination components different to communication (e.g. policies, etc.). Furthermore, we build components t</context>
</contexts>
<marker>[1]</marker>
<rawString>F. Arbad, &amp;quot;The IWIM Model for Coordination of Concurrent Activities&amp;quot;, in [4] pp. 34-56</rawString>
</citation>
<citation valid="true">
<authors>
<author>Jean-Pierre Banatre</author>
<author>Daniel Le Metayer</author>
</authors>
<title>Gamma and the Chemical Reaction Model”,</title>
<date>1995</date>
<booktitle>Proceedings of Coordination’95 Workshop,</booktitle>
<publisher>IC Press,</publisher>
<location>London,</location>
<contexts>
<context position="17959" citStr="[2]" startWordPosition="2784" endWordPosition="2784">tly, it only deals with a single resource. More complex coordination problems involve distributed solutions, e.g. replicated resources or distributed transactions. This is work in progress. Secondly, there are dependencies that cannot be dealt with in this way. For instance, the set of actions that make up a transaction, is local for every transaction, making it impossible to store this information in some kind of general transaction context object [17]. 4 Related Work Most of the work done in the area of coordination have been directed to the development of coordination languages (e.g. Gamma [2], Linda [3], etc.) used to describe coordination aspects in open systems. The fact that the coordination model they implement is based on a particular paradigm makes these languages limited in scope. Each one of these coordination languages proposes its own set of coordination abstractions that realizes a particular paradigm for realizing coordination. Coordination problems, however, do not always fit to a particular paradigm. Language based approaches are inherently limited in scope. Instead of proposing a new language, we are attempting to provide an open set of coordination components that </context>
</contexts>
<marker>[2]</marker>
<rawString>Jean-Pierre Banatre and Daniel Le Metayer, “Gamma and the Chemical Reaction Model”, Proceedings of Coordination’95 Workshop, IC Press, London, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>N Carriero</author>
<author>D Gelernter</author>
</authors>
<title>Linda in Context”,</title>
<date>1989</date>
<journal>Communications of the ACM,</journal>
<volume>32</volume>
<pages>444--458</pages>
<contexts>
<context position="2522" citStr="[3]" startWordPosition="375" endWordPosition="375">olving. Evolution is the most difficult requirement to meet, since not all the application requirements can be known in advance[12]. Development of Open Systems is a difficult task, because in addition to requirements concerning openness, they have special computational constraints. One of the most important constraints concerns the coordination of the interaction of the different software entities that compose those systems. Coordination in this context concerns the management of possible interdependencies between the activities performed by the entities of the system. Carriero and Gelernter [3] have proposed to manage separately the coordination aspect from the computation in the development of Open Systems. They propose to use what they call Coordination Languages. The idea of separating these two aspects during the system development seems to have a lot of advantages, mainly related with a simplification in the complexity of the development. Nevertheless, most of the coordination languages do not take care of satisfying the “openness” related requirements Open Systems have to. This is particularly true in which concerns the management of the evolution of the coordination aspect it</context>
<context position="17970" citStr="[3]" startWordPosition="2786" endWordPosition="2786">y deals with a single resource. More complex coordination problems involve distributed solutions, e.g. replicated resources or distributed transactions. This is work in progress. Secondly, there are dependencies that cannot be dealt with in this way. For instance, the set of actions that make up a transaction, is local for every transaction, making it impossible to store this information in some kind of general transaction context object [17]. 4 Related Work Most of the work done in the area of coordination have been directed to the development of coordination languages (e.g. Gamma [2], Linda [3], etc.) used to describe coordination aspects in open systems. The fact that the coordination model they implement is based on a particular paradigm makes these languages limited in scope. Each one of these coordination languages proposes its own set of coordination abstractions that realizes a particular paradigm for realizing coordination. Coordination problems, however, do not always fit to a particular paradigm. Language based approaches are inherently limited in scope. Instead of proposing a new language, we are attempting to provide an open set of coordination components that realize var</context>
</contexts>
<marker>[3]</marker>
<rawString>N. Carriero and D. Gelernter, “Linda in Context”, Communications of the ACM, vol. 32, no. 4, April 1989, pp. 444-458.</rawString>
</citation>
<citation valid="true">
<date>1996</date>
<booktitle>First International Conference on Coordination Models, Languages and Applications COORDINATION’96&amp;quot;,</booktitle>
<pages>1061</pages>
<editor>P. Ciancarini, C. Hankin (eds.),</editor>
<publisher>Springer Verlag.</publisher>
<location>Cesena, Italy,</location>
<marker>[4]</marker>
<rawString>P. Ciancarini, C. Hankin (eds.), &amp;quot;First International Conference on Coordination Models, Languages and Applications COORDINATION’96&amp;quot;, Cesena, Italy, 15-17 April, 1996, LNCS 1061, Springer Verlag.</rawString>
</citation>
<citation valid="true">
<authors>
<author>George Coulouris</author>
<author>Jean Dollimore</author>
<author>Tim Kindberg</author>
</authors>
<date>1994</date>
<booktitle>Distributed Systems Concepts and Design”, Addison-Wesley,</booktitle>
<contexts>
<context position="7255" citStr="[5]" startWordPosition="1116" endWordPosition="1116">ings that have to fit together. Some dependencies can be viewed as specialization of others. For instance Task assignment can be seen as an special case of Sharing, where the “resource” being shared is the time of the entities that do the tasks. This list of interdependencies is not intended to be exhaustive. To our viewpoint the importance of Malone’s work is that it can be used to propose a systematic approach to identify coordination problems in open systems. The main idea consists to identify the existence of these interdependencies between the multiple activities that the system realizes [5] (e.g.communication, management of resources and services, task assignments etc.). 2.1 Coordination Problems We have selected a representative set of coordination problems that we have yet identified. For each one we give some hints about how these problems can be managed using a coordination process. 2.1.1 Management of Shared Resources Managing shared resources is one of the most common coordination problems that occurs in open systems. Whenever multiple activities share some limited resource (e.g. storage space, an actor’s time, etc.), a coordination process which controls the allocation of</context>
</contexts>
<marker>[5]</marker>
<rawString>George Coulouris, Jean Dollimore and Tim Kindberg, “Distributed Systems Concepts and Design”, Addison-Wesley, 1994.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Serger Demeyer</author>
</authors>
<title>Theo Dirk Meijler, Oscar Nierstrasz, Patrick Steyaert, “Design Guidelines for Tailorable Frameworks”,</title>
<date>1997</date>
<journal>Communications of the ACM,</journal>
<volume>40</volume>
<pages>60--64</pages>
<contexts>
<context position="13907" citStr="[6]" startWordPosition="2118" endWordPosition="2118"> Open Systems like [8]: interoperability, concurrency, distribution, reliability, security, etc. A systems developer who develops coordination solutions, therefore has to deal with many of the above requirements. Every application has its own unique mix of specific requirements. In the design and development of the coordination components we have investigated how framework technology can help us to deal with this complex set of system requirements in the packaging of coordination solutions. Particularly, we had look at the design guidelines for building “tailorable frameworks” as presented in [6]. Example As an example of what is being done, we show access policy components for a shared resource in a toy banking system. In this case the resource is an account database which is shared by multiple teller machines. The teller machines need to get information from the account database in order to check a client’s account. They also need to update account information if they have given money to a client. To keep the database consistent we need an access policy to regulate the multiple requests. As a solution for this regulation problem we introduce an access policy component. This solution</context>
</contexts>
<marker>[6]</marker>
<rawString>Serger Demeyer, Theo Dirk Meijler, Oscar Nierstrasz, Patrick Steyaert, “Design Guidelines for Tailorable Frameworks”, Communications of the ACM, vol. 40, no. 10, October 1997, pp. 60-64</rawString>
</citation>
<citation valid="true">
<authors>
<author>Eric Gamma</author>
<author>Richard Helm</author>
<author>Ralph Johnson</author>
<author>John Vlissides</author>
</authors>
<title>Design Patterns”,</title>
<date>1995</date>
<publisher>Addison-Wesley,</publisher>
<location>MA,</location>
<contexts>
<context position="15124" citStr="[7]" startWordPosition="2326" endWordPosition="2326">ides access regulation, but also explicitness of architecture and flexibility. We can imagine a banking system which initially starts with a basic FIFO policy, but which, as more and more teller machines get connected to the system, needs a more sophisticated policy to handle the increasing number of incoming requests. By creating a structure which allows us to change policies transparently, the banking system can be adapted without having to change other parts of the system. Our solution is shown in Figure 1. In its design we used ideas from the Command and Strategy pattern from Gamma et al. [7], and from the Active Object pattern [13]. The class Wrapper is the interface to the resource for the rest of the system. For every command which is invoked by an incoming request (1), a ConcreteCommand object is created (2). This explicit representation of commands allows us to buffer the commands, change their order, execute them in parallel, or whatever a policy needs to do with them. This is, for instance, needed for a readers/writer policy, which allows multiple readers to access the database simultaneously. These commands are then given (3) to the policy which is connected (through param</context>
</contexts>
<marker>[7]</marker>
<rawString>Eric Gamma, Richard Helm, Ralph Johnson and John Vlissides, “Design Patterns”, Addison-Wesley, MA, 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>C Hewitt</author>
</authors>
<title>Offices are Open Systems”,</title>
<date>1986</date>
<journal>ACM Transactions Off. Inf. Syst.,</journal>
<volume>4</volume>
<pages>270--287</pages>
<contexts>
<context position="4569" citStr="[8]" startWordPosition="692" endWordPosition="692">e Java language, an object oriented language well-suited to modelling software entities in a distributed setting. We are validating our approach by using those components in building a set of sample applications that characterize Open Systems. Our initial experiences in building this set of components has shown us, that coordination solutions are not easily shrinkwrapped into off-the shelf components. One reason is that coordination solutions affect typically more than one component. A second is that the coordination solutions are subject to a complex set of requirements for Open Systems like [8]: interoperability, concurrency, distribution, reliability, security, etc. A systems developer who develops coordination solutions, therefore has to deal with many of the above requirements. And every application has its own unique mix of interacting components and specific requirements. In this paper we present some results of our experimental work building a such set of coordination components. Section 2, discusses coordination aspects in Open Systems. Section 3, introduces an example of a coordination component, and explains how this component was designed using a component-based approach. </context>
<context position="13326" citStr="[8]" startWordPosition="2033" endWordPosition="2033">, or “these three method calls constitute a critical section”, etc. • service dependencies: In some cases the computational components need to provide coordination related services like to store state relevant information in order to guarantee recovery in case of failures. • request control: Coordination solutions need to control the ordering and adaptation of requests. They typically need techniques like message reification, message passing control or method wrapping, etc. • complex system requirements: Coordination solutions are subject to a complex set of requirements for Open Systems like [8]: interoperability, concurrency, distribution, reliability, security, etc. A systems developer who develops coordination solutions, therefore has to deal with many of the above requirements. Every application has its own unique mix of specific requirements. In the design and development of the coordination components we have investigated how framework technology can help us to deal with this complex set of system requirements in the packaging of coordination solutions. Particularly, we had look at the design guidelines for building “tailorable frameworks” as presented in [6]. Example As an exa</context>
</contexts>
<marker>[8]</marker>
<rawString>C. Hewitt, “Offices are Open Systems”, ACM Transactions Off. Inf. Syst., vol. 4, no. 3, 1986, pp. 270-287.</rawString>
</citation>
<citation valid="false">
<authors>
<author>A A Holzbacher</author>
</authors>
<title>A Software Environment for Concurrent Coordinated Programming&amp;quot;,</title>
<volume>4</volume>
<pages>249--266</pages>
<contexts>
<context position="18882" citStr="[9]" startWordPosition="2927" endWordPosition="2927">radigm for realizing coordination. Coordination problems, however, do not always fit to a particular paradigm. Language based approaches are inherently limited in scope. Instead of proposing a new language, we are attempting to provide an open set of coordination components that realize various useful coordination abstractions. With our components we provide explicit separation of coordination from computation and facilitate reuse and evolution of the coordination aspect. The idea of using and composing coordination components is not new, as evidenced by work such as Manifold [1] and ConCoord [9]. These languages allow composition of existing coordination components with communication operations. Dynamically new communication configurations between components can be reached in this way. Coordinator processes do their job with no knowledge of the internal details of the computations done by the processes they coordinate. The communication configuration determines the coordination flow of an application. In our work we try to explore other forms of composition of coordination components different to communication (e.g. policies, etc.). Furthermore, we build components that are themselve</context>
</contexts>
<marker>[9]</marker>
<rawString>A.A. Holzbacher, &amp;quot;A Software Environment for Concurrent Coordinated Programming&amp;quot;, in [4] pp. 249-266.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thomas Malone</author>
<author>Kevin Crowston</author>
</authors>
<title>The Interdisciplinary Study of Coordination”,</title>
<date>1994</date>
<journal>ACM Computing Surveys,</journal>
<volume>26</volume>
<contexts>
<context position="5775" citStr="[10]" startWordPosition="876" endWordPosition="876">ction 4 gives an overview of related work. Finally, Section 5 concludes with a discussion: evaluating our contributions and pointing-out lessons learned in this experimental work. 2 Coordination Aspects in Open Systems. Coordination problems arise in the organisation of interactions of a group of entities that collaborate and cooperate to accomplish some task and to satisfy some goals. It is because entities cooperate that they can accomplish more elaborated actions, but it is also because of their multiplicity that they must coordinate their actions and resolve conflicts. Malone and Crowston [10][11] have defined coordination as: The act of managing interdependencies between activities performed by entities in order to achieve some goals. They have identified three kinds of dependencies out of which all other important dependencies can be expressed, either by their specialization or by their combination. They are: • Flow: occurs when an activity produces something that is used by another one. Flow dependencies can be viewed as a combination of three other kind of dependencies: Prerequisite constraints (an item must be produced before it can be used), Accessibility constraints (an item</context>
</contexts>
<marker>[10]</marker>
<rawString>Thomas Malone, Kevin Crowston, “The Interdisciplinary Study of Coordination”, ACM Computing Surveys, vol. 26,no. 1, March 1994</rawString>
</citation>
<citation valid="true">
<authors>
<author>Thomas Malone</author>
</authors>
<title>Free on the range: Tom Malone and the implications of the digital age&amp;quot;,</title>
<date>1997</date>
<journal>IEEE Internet Computing,</journal>
<volume>1</volume>
<location>May-June,</location>
<contexts>
<context position="5779" citStr="[11]" startWordPosition="876" endWordPosition="876">n 4 gives an overview of related work. Finally, Section 5 concludes with a discussion: evaluating our contributions and pointing-out lessons learned in this experimental work. 2 Coordination Aspects in Open Systems. Coordination problems arise in the organisation of interactions of a group of entities that collaborate and cooperate to accomplish some task and to satisfy some goals. It is because entities cooperate that they can accomplish more elaborated actions, but it is also because of their multiplicity that they must coordinate their actions and resolve conflicts. Malone and Crowston [10][11] have defined coordination as: The act of managing interdependencies between activities performed by entities in order to achieve some goals. They have identified three kinds of dependencies out of which all other important dependencies can be expressed, either by their specialization or by their combination. They are: • Flow: occurs when an activity produces something that is used by another one. Flow dependencies can be viewed as a combination of three other kind of dependencies: Prerequisite constraints (an item must be produced before it can be used), Accessibility constraints (an item tha</context>
</contexts>
<marker>[11]</marker>
<rawString>Thomas Malone, &amp;quot;Free on the range: Tom Malone and the implications of the digital age&amp;quot;, IEEE Internet Computing, Vol 1, no. 3, May-June, 1997</rawString>
</citation>
<citation valid="true">
<authors>
<author>Oscar Nierstrasz</author>
<author>Laurent Dami</author>
</authors>
<date>1995</date>
<journal>Component-Oriented Software Technology”, Object-Oriented Software Composition, O. Nierstrasz</journal>
<pages>3--28</pages>
<publisher>Prentice Hall,</publisher>
<contexts>
<context position="2050" citStr="[12]" startWordPosition="309" endWordPosition="309">Introduction Over the last two decades software development has changed significantly. Its evolution has been motivated by the goal of producing open rather than closed, proprietary systems. Open Systems are basically “open” in terms of topology, platform and evolution [18]: they run on networks which are continuously changing and expanding, they are built on the top of a heterogeneous platform of hardware and software pieces, and their requirements are continuously evolving. Evolution is the most difficult requirement to meet, since not all the application requirements can be known in advance[12]. Development of Open Systems is a difficult task, because in addition to requirements concerning openness, they have special computational constraints. One of the most important constraints concerns the coordination of the interaction of the different software entities that compose those systems. Coordination in this context concerns the management of possible interdependencies between the activities performed by the entities of the system. Carriero and Gelernter [3] have proposed to manage separately the coordination aspect from the computation in the development of Open Systems. They propos</context>
<context position="11729" citStr="[12]" startWordPosition="1794" endWordPosition="1794">n the group decision, implement a decision scheme (e.g. consensus, voting, authority, etc.), announce the final decision to the group, and decide what to do in case of failures of the entities which participate (to terminate the process, etc.). A particular situation in which this kind of coordination problem can occur is in the election of a new server from a group of replicated servers. Replication of servers is a common strategy used to guarantee the fault tolerance of a provided service. 3 A Component-Based Approach to Manage Evolution of Coordination Aspects In a component-based approach [12], each application is viewed as only one instance of a generic class of applications, each one being flexible composed of software components. New application requirements are addressed by removing, replacing and reconfiguring the software components without disturbing other parts of the application. Why not to manage the coordination aspects of those applications using the same approach? Why not to develop a set of adaptable and reusable coordination components that encapsulate standard solutions to coordination problems? That is what we tried to in our work. The initial results of this exper</context>
</contexts>
<marker>[12]</marker>
<rawString>Oscar Nierstrasz and Laurent Dami, “Component-Oriented Software Technology”, Object-Oriented Software Composition, O. Nierstrasz and D. Tsichritzis (Ed.), Prentice Hall, 1995, pp. 3-28.</rawString>
</citation>
<citation valid="true">
<authors>
<author>R Greg Lavender</author>
<author>Douglas C Schmidt</author>
</authors>
<title>Active Object: an Object Behavioural Pattern for Concurrent Programming”,</title>
<date>1995</date>
<booktitle>Proc. Pattern Languages of Programs,</booktitle>
<contexts>
<context position="15165" citStr="[13]" startWordPosition="2333" endWordPosition="2333">tness of architecture and flexibility. We can imagine a banking system which initially starts with a basic FIFO policy, but which, as more and more teller machines get connected to the system, needs a more sophisticated policy to handle the increasing number of incoming requests. By creating a structure which allows us to change policies transparently, the banking system can be adapted without having to change other parts of the system. Our solution is shown in Figure 1. In its design we used ideas from the Command and Strategy pattern from Gamma et al. [7], and from the Active Object pattern [13]. The class Wrapper is the interface to the resource for the rest of the system. For every command which is invoked by an incoming request (1), a ConcreteCommand object is created (2). This explicit representation of commands allows us to buffer the commands, change their order, execute them in parallel, or whatever a policy needs to do with them. This is, for instance, needed for a readers/writer policy, which allows multiple readers to access the database simultaneously. These commands are then given (3) to the policy which is connected (through parameterization) to the interface. This polic</context>
<context position="19846" citStr="[13]" startWordPosition="3068" endWordPosition="3068">on determines the coordination flow of an application. In our work we try to explore other forms of composition of coordination components different to communication (e.g. policies, etc.). Furthermore, we build components that are themselves configurable and composable. Our components can be adapted to particular situations by plugging in instances of the elements that define their parameterized structure. In a different domain, the Adaptive Communication Environment (ACE)[14] is an interesting reference. One of the most important contributions of this work is the set of coordination patterns [13][15][16] that it proposes and that can be used to realize coordination components. We have presented examples of coordination components that have used some ideas from some of these design patterns. The object-oriented network programming toolkit includes a series of wrappers, class libraries and frameworks for developing communication software. The main problem with these work is its closeness. Synchronization and communication abstractions in the ACE toolkit are reduced to those provided by some common operating systems (e.g. Mutex, Wrapper RWContext PrContext Command Policy ReadersWriterPol</context>
</contexts>
<marker>[13]</marker>
<rawString>R. Greg Lavender and Douglas C. Schmidt, “Active Object: an Object Behavioural Pattern for Concurrent Programming”, Proc. Pattern Languages of Programs, September 1995.</rawString>
</citation>
<citation valid="false">
<authors>
<author>Douglas Schmidt</author>
</authors>
<title>The ADAPTATIVE Communication Environment: An Object-Oriented Network Programming Toolkit for Development of Communication Software”.</title>
<contexts>
<context position="19723" citStr="[14]" startWordPosition="3047" endWordPosition="3047"> knowledge of the internal details of the computations done by the processes they coordinate. The communication configuration determines the coordination flow of an application. In our work we try to explore other forms of composition of coordination components different to communication (e.g. policies, etc.). Furthermore, we build components that are themselves configurable and composable. Our components can be adapted to particular situations by plugging in instances of the elements that define their parameterized structure. In a different domain, the Adaptive Communication Environment (ACE)[14] is an interesting reference. One of the most important contributions of this work is the set of coordination patterns [13][15][16] that it proposes and that can be used to realize coordination components. We have presented examples of coordination components that have used some ideas from some of these design patterns. The object-oriented network programming toolkit includes a series of wrappers, class libraries and frameworks for developing communication software. The main problem with these work is its closeness. Synchronization and communication abstractions in the ACE toolkit are reduced </context>
</contexts>
<marker>[14]</marker>
<rawString>Douglas Schmidt, “The ADAPTATIVE Communication Environment: An Object-Oriented Network Programming Toolkit for Development of Communication Software”.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Douglas Schmidt</author>
</authors>
<title>Acceptor: A Design Pattern for Passively Initializing Network Services”,</title>
<date>1995</date>
<journal>C++ Reports, SIGS,</journal>
<volume>7</volume>
<location>Nov/Dec</location>
<contexts>
<context position="19850" citStr="[15]" startWordPosition="3068" endWordPosition="3068">etermines the coordination flow of an application. In our work we try to explore other forms of composition of coordination components different to communication (e.g. policies, etc.). Furthermore, we build components that are themselves configurable and composable. Our components can be adapted to particular situations by plugging in instances of the elements that define their parameterized structure. In a different domain, the Adaptive Communication Environment (ACE)[14] is an interesting reference. One of the most important contributions of this work is the set of coordination patterns [13][15][16] that it proposes and that can be used to realize coordination components. We have presented examples of coordination components that have used some ideas from some of these design patterns. The object-oriented network programming toolkit includes a series of wrappers, class libraries and frameworks for developing communication software. The main problem with these work is its closeness. Synchronization and communication abstractions in the ACE toolkit are reduced to those provided by some common operating systems (e.g. Mutex, Wrapper RWContext PrContext Command Policy ReadersWriterPolicy </context>
</contexts>
<marker>[15]</marker>
<rawString>Douglas Schmidt, “Acceptor: A Design Pattern for Passively Initializing Network Services”, C++ Reports, SIGS, Vol. 7, no. 8, Nov/Dec 1995.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Douglas Schmidt</author>
</authors>
<title>Connector: A Design Pattern for Actively Initializing Network Services”,</title>
<date>1996</date>
<journal>C++ Reports, SIGS,</journal>
<volume>8</volume>
<contexts>
<context position="19854" citStr="[16]" startWordPosition="3068" endWordPosition="3068">mines the coordination flow of an application. In our work we try to explore other forms of composition of coordination components different to communication (e.g. policies, etc.). Furthermore, we build components that are themselves configurable and composable. Our components can be adapted to particular situations by plugging in instances of the elements that define their parameterized structure. In a different domain, the Adaptive Communication Environment (ACE)[14] is an interesting reference. One of the most important contributions of this work is the set of coordination patterns [13][15][16] that it proposes and that can be used to realize coordination components. We have presented examples of coordination components that have used some ideas from some of these design patterns. The object-oriented network programming toolkit includes a series of wrappers, class libraries and frameworks for developing communication software. The main problem with these work is its closeness. Synchronization and communication abstractions in the ACE toolkit are reduced to those provided by some common operating systems (e.g. Mutex, Wrapper RWContext PrContext Command Policy ReadersWriterPolicy Prio</context>
</contexts>
<marker>[16]</marker>
<rawString>Douglas Schmidt, “Connector: A Design Pattern for Actively Initializing Network Services”, C++ Reports, SIGS, vol. 8, no. 1, January 1996.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Sander Tichelaar</author>
<author>Juan Carlos Cruz</author>
<author>Serge Demeyer</author>
</authors>
<title>Coordination as a Variability Aspect of Open Distributed Systems”, SCG-Report, IAM,</title>
<date>1998</date>
<institution>University of Berne,</institution>
<contexts>
<context position="12482" citStr="[17]" startWordPosition="1911" endWordPosition="1911">plication requirements are addressed by removing, replacing and reconfiguring the software components without disturbing other parts of the application. Why not to manage the coordination aspects of those applications using the same approach? Why not to develop a set of adaptable and reusable coordination components that encapsulate standard solutions to coordination problems? That is what we tried to in our work. The initial results of this experimental work has shown that coordination solutions are not easily shrink-wrapped into off-the shelf components. The reasons for this are analyzed in [17]. They are: • information dependencies: Many coordination solutions are dependent of application dependent information. Information that is typically needed by coordination solution is: “this method updates the state and this one only reads”, or “these three method calls constitute a critical section”, etc. • service dependencies: In some cases the computational components need to provide coordination related services like to store state relevant information in order to guarantee recovery in case of failures. • request control: Coordination solutions need to control the ordering and adaptation</context>
<context position="17813" citStr="[17]" startWordPosition="2757" endWordPosition="2757">rent applications and within applications we can easily switch policies. Limitations The example we have shown is limited in a couple of ways. Firstly, it only deals with a single resource. More complex coordination problems involve distributed solutions, e.g. replicated resources or distributed transactions. This is work in progress. Secondly, there are dependencies that cannot be dealt with in this way. For instance, the set of actions that make up a transaction, is local for every transaction, making it impossible to store this information in some kind of general transaction context object [17]. 4 Related Work Most of the work done in the area of coordination have been directed to the development of coordination languages (e.g. Gamma [2], Linda [3], etc.) used to describe coordination aspects in open systems. The fact that the coordination model they implement is based on a particular paradigm makes these languages limited in scope. Each one of these coordination languages proposes its own set of coordination abstractions that realizes a particular paradigm for realizing coordination. Coordination problems, however, do not always fit to a particular paradigm. Language based approach</context>
</contexts>
<marker>[17]</marker>
<rawString>Sander Tichelaar, Juan Carlos Cruz, Serge Demeyer, “Coordination as a Variability Aspect of Open Distributed Systems”, SCG-Report, IAM, University of Berne, February 1998.</rawString>
</citation>
<citation valid="true">
<authors>
<author>Dennis Tsichritzis</author>
</authors>
<title>Object-Oriented Development for Open Systems”,</title>
<date></date>
<booktitle>Information Processing 89 (Proceedings IFIP’89),</booktitle>
<volume>28</volume>
<pages>1033--1040</pages>
<location>North Holland, San Francisco,</location>
<contexts>
<context position="1720" citStr="[18]" startWordPosition="258" endWordPosition="258">posing a new language, we are attempting to develop an open set of adaptable and reusable software components that realize various useful coordination abstractions. With these components we provide explicit separation of coordination from computation, and facilitate reuse and evolution of coordination aspects in Open Systems. 1 Introduction Over the last two decades software development has changed significantly. Its evolution has been motivated by the goal of producing open rather than closed, proprietary systems. Open Systems are basically “open” in terms of topology, platform and evolution [18]: they run on networks which are continuously changing and expanding, they are built on the top of a heterogeneous platform of hardware and software pieces, and their requirements are continuously evolving. Evolution is the most difficult requirement to meet, since not all the application requirements can be known in advance[12]. Development of Open Systems is a difficult task, because in addition to requirements concerning openness, they have special computational constraints. One of the most important constraints concerns the coordination of the interaction of the different software entities</context>
</contexts>
<marker>[18]</marker>
<rawString>Dennis Tsichritzis, “Object-Oriented Development for Open Systems”, Information Processing 89 (Proceedings IFIP’89), North Holland, San Francisco, Aug. 28-Sept. 1, 1989, pp. 1033-1040.</rawString>
</citation>
</citationList>
</algorithm>
</algorithms>